{"ast":null,"code":"import WalletConnect from \"@walletconnect/client\";\nimport QRCodeModal from \"@walletconnect/qrcode-modal\";\nimport HttpConnection from \"@walletconnect/http-connection\";\nimport { payloadId, signingMethods, parsePersonalSign, getRpcUrl } from \"@walletconnect/utils\";\n\nconst ProviderEngine = require(\"web3-provider-engine\");\n\nconst CacheSubprovider = require(\"web3-provider-engine/subproviders/cache\");\n\nconst FixtureSubprovider = require(\"web3-provider-engine/subproviders/fixture\");\n\nconst FilterSubprovider = require(\"web3-provider-engine/subproviders/filters\");\n\nconst HookedWalletSubprovider = require(\"web3-provider-engine/subproviders/hooked-wallet\");\n\nconst NonceSubprovider = require(\"web3-provider-engine/subproviders/nonce-tracker\");\n\nconst SubscriptionsSubprovider = require(\"web3-provider-engine/subproviders/subscriptions\");\n\nclass WalletConnectProvider extends ProviderEngine {\n  constructor(opts) {\n    super({\n      pollingInterval: opts.pollingInterval || 8000\n    });\n    this.bridge = \"https://bridge.walletconnect.org\";\n    this.qrcode = true;\n    this.qrcodeModal = QRCodeModal;\n    this.qrcodeModalOptions = undefined;\n    this.rpc = null;\n    this.infuraId = \"\";\n    this.http = null;\n    this.isConnecting = false;\n    this.connected = false;\n    this.connectCallbacks = [];\n    this.accounts = [];\n    this.chainId = 1;\n    this.rpcUrl = \"\";\n\n    this.enable = async () => {\n      const wc = await this.getWalletConnector();\n\n      if (wc) {\n        this.start();\n        this.subscribeWalletConnector();\n        return wc.accounts;\n      } else {\n        throw new Error(\"Failed to connect to WalleConnect\");\n      }\n    };\n\n    this.request = async payload => {\n      return this.send(payload);\n    };\n\n    this.send = async (payload, callback) => {\n      if (typeof payload === \"string\") {\n        const method = payload;\n        let params = callback;\n\n        if (method === \"personal_sign\") {\n          params = parsePersonalSign(params);\n        }\n\n        return this.sendAsyncPromise(method, params);\n      }\n\n      payload = Object.assign({\n        id: payloadId(),\n        jsonrpc: \"2.0\"\n      }, payload);\n\n      if (payload.method === \"personal_sign\") {\n        payload.params = parsePersonalSign(payload.params);\n      }\n\n      if (callback) {\n        this.sendAsync(payload, callback);\n        return;\n      }\n\n      return this.sendAsyncPromise(payload.method, payload.params);\n    };\n\n    this.onConnect = callback => {\n      this.connectCallbacks.push(callback);\n    };\n\n    this.triggerConnect = result => {\n      if (this.connectCallbacks && this.connectCallbacks.length) {\n        this.connectCallbacks.forEach(callback => callback(result));\n      }\n    };\n\n    this.bridge = opts.connector ? opts.connector.bridge : opts.bridge || \"https://bridge.walletconnect.org\";\n    this.qrcode = typeof opts.qrcode === \"undefined\" || opts.qrcode !== false;\n    this.qrcodeModal = opts.qrcodeModal || this.qrcodeModal;\n    this.qrcodeModalOptions = opts.qrcodeModalOptions;\n    this.wc = opts.connector || new WalletConnect({\n      bridge: this.bridge,\n      qrcodeModal: this.qrcode ? this.qrcodeModal : undefined,\n      qrcodeModalOptions: this.qrcodeModalOptions,\n      storageId: opts === null || opts === void 0 ? void 0 : opts.storageId,\n      signingMethods: opts === null || opts === void 0 ? void 0 : opts.signingMethods,\n      clientMeta: opts === null || opts === void 0 ? void 0 : opts.clientMeta\n    });\n    this.rpc = opts.rpc || null;\n\n    if (!this.rpc && (!opts.infuraId || typeof opts.infuraId !== \"string\" || !opts.infuraId.trim())) {\n      throw new Error(\"Missing one of the required parameters: rpc or infuraId\");\n    }\n\n    this.infuraId = opts.infuraId || \"\";\n    this.chainId = (opts === null || opts === void 0 ? void 0 : opts.chainId) || this.chainId;\n    this.initialize();\n  }\n\n  get isWalletConnect() {\n    return true;\n  }\n\n  get connector() {\n    return this.wc;\n  }\n\n  get walletMeta() {\n    return this.wc.peerMeta;\n  }\n\n  async disconnect() {\n    this.close();\n  }\n\n  async close() {\n    const wc = await this.getWalletConnector({\n      disableSessionCreation: true\n    });\n    await wc.killSession();\n    await this.onDisconnect();\n  }\n\n  async handleRequest(payload) {\n    try {\n      let response;\n      let result = null;\n      const wc = await this.getWalletConnector();\n\n      switch (payload.method) {\n        case \"wc_killSession\":\n          await this.close();\n          result = null;\n          break;\n\n        case \"eth_accounts\":\n          result = wc.accounts;\n          break;\n\n        case \"eth_coinbase\":\n          result = wc.accounts[0];\n          break;\n\n        case \"eth_chainId\":\n          result = wc.chainId;\n          break;\n\n        case \"net_version\":\n          result = wc.chainId;\n          break;\n\n        case \"eth_uninstallFilter\":\n          this.sendAsync(payload, _ => _);\n          result = true;\n          break;\n\n        default:\n          response = await this.handleOtherRequests(payload);\n      }\n\n      if (response) {\n        return response;\n      }\n\n      return this.formatResponse(payload, result);\n    } catch (error) {\n      this.emit(\"error\", error);\n      throw error;\n    }\n  }\n\n  async handleOtherRequests(payload) {\n    if (!signingMethods.includes(payload.method) && payload.method.startsWith(\"eth_\")) {\n      return this.handleReadRequests(payload);\n    }\n\n    const wc = await this.getWalletConnector();\n    const result = await wc.sendCustomRequest(payload);\n    return this.formatResponse(payload, result);\n  }\n\n  async handleReadRequests(payload) {\n    if (!this.http) {\n      const error = new Error(\"HTTP Connection not available\");\n      this.emit(\"error\", error);\n      throw error;\n    }\n\n    return this.http.send(payload);\n  }\n\n  formatResponse(payload, result) {\n    return {\n      id: payload.id,\n      jsonrpc: payload.jsonrpc,\n      result: result\n    };\n  }\n\n  getWalletConnector(opts = {}) {\n    const {\n      disableSessionCreation = false\n    } = opts;\n    return new Promise((resolve, reject) => {\n      const wc = this.wc;\n\n      if (this.isConnecting) {\n        this.onConnect(x => resolve(x));\n      } else if (!wc.connected && !disableSessionCreation) {\n        this.isConnecting = true;\n        wc.on(\"modal_closed\", () => {\n          reject(new Error(\"User closed modal\"));\n        });\n        wc.createSession({\n          chainId: this.chainId\n        }).then(() => {\n          wc.on(\"connect\", (error, payload) => {\n            if (error) {\n              this.isConnecting = false;\n              return reject(error);\n            }\n\n            this.isConnecting = false;\n            this.connected = true;\n\n            if (payload) {\n              this.updateState(payload.params[0]);\n            }\n\n            this.emit(\"connect\");\n            this.triggerConnect(wc);\n            resolve(wc);\n          });\n        }).catch(error => {\n          this.isConnecting = false;\n          reject(error);\n        });\n      } else {\n        if (!this.connected) {\n          this.connected = true;\n          this.updateState(wc.session);\n        }\n\n        resolve(wc);\n      }\n    });\n  }\n\n  async subscribeWalletConnector() {\n    const wc = await this.getWalletConnector();\n    wc.on(\"disconnect\", error => {\n      if (error) {\n        this.emit(\"error\", error);\n        return;\n      }\n\n      this.onDisconnect();\n    });\n    wc.on(\"session_update\", (error, payload) => {\n      if (error) {\n        this.emit(\"error\", error);\n        return;\n      }\n\n      this.updateState(payload.params[0]);\n    });\n  }\n\n  async onDisconnect() {\n    await this.stop();\n    this.emit(\"close\", 1000, \"Connection closed\");\n    this.emit(\"disconnect\", 1000, \"Connection disconnected\");\n  }\n\n  async updateState(sessionParams) {\n    const {\n      accounts,\n      chainId,\n      networkId,\n      rpcUrl\n    } = sessionParams;\n\n    if (!this.accounts || accounts && this.accounts !== accounts) {\n      this.accounts = accounts;\n      this.emit(\"accountsChanged\", accounts);\n    }\n\n    if (!this.chainId || chainId && this.chainId !== chainId) {\n      this.chainId = chainId;\n      this.emit(\"chainChanged\", chainId);\n    }\n\n    if (!this.networkId || networkId && this.networkId !== networkId) {\n      this.networkId = networkId;\n      this.emit(\"networkChanged\", networkId);\n    }\n\n    this.updateRpcUrl(this.chainId, rpcUrl || \"\");\n  }\n\n  updateRpcUrl(chainId, rpcUrl = \"\") {\n    const rpc = {\n      infuraId: this.infuraId,\n      custom: this.rpc || undefined\n    };\n    rpcUrl = rpcUrl || getRpcUrl(chainId, rpc);\n\n    if (rpcUrl) {\n      this.rpcUrl = rpcUrl;\n      this.updateHttpConnection();\n    } else {\n      this.emit(\"error\", new Error(`No RPC Url available for chainId: ${chainId}`));\n    }\n  }\n\n  updateHttpConnection() {\n    if (this.rpcUrl) {\n      this.http = new HttpConnection(this.rpcUrl);\n      this.http.on(\"payload\", payload => this.emit(\"payload\", payload));\n      this.http.on(\"error\", error => this.emit(\"error\", error));\n    }\n  }\n\n  sendAsyncPromise(method, params) {\n    return new Promise((resolve, reject) => {\n      this.sendAsync({\n        id: payloadId(),\n        jsonrpc: \"2.0\",\n        method,\n        params: params || []\n      }, (error, response) => {\n        if (error) {\n          reject(error);\n          return;\n        }\n\n        resolve(response.result);\n      });\n    });\n  }\n\n  initialize() {\n    this.updateRpcUrl(this.chainId);\n    this.addProvider(new FixtureSubprovider({\n      eth_hashrate: \"0x00\",\n      eth_mining: false,\n      eth_syncing: true,\n      net_listening: true,\n      web3_clientVersion: `WalletConnect/v1.x.x/javascript`\n    }));\n    this.addProvider(new CacheSubprovider());\n    this.addProvider(new SubscriptionsSubprovider());\n    this.addProvider(new FilterSubprovider());\n    this.addProvider(new NonceSubprovider());\n    this.addProvider(new HookedWalletSubprovider(this.configWallet()));\n    this.addProvider({\n      handleRequest: async (payload, next, end) => {\n        try {\n          const {\n            error,\n            result\n          } = await this.handleRequest(payload);\n          end(error, result);\n        } catch (error) {\n          end(error);\n        }\n      },\n      setEngine: _ => _\n    });\n  }\n\n  configWallet() {\n    return {\n      getAccounts: async cb => {\n        try {\n          const wc = await this.getWalletConnector();\n          const accounts = wc.accounts;\n\n          if (accounts && accounts.length) {\n            cb(null, accounts);\n          } else {\n            cb(new Error(\"Failed to get accounts\"));\n          }\n        } catch (error) {\n          cb(error);\n        }\n      },\n      processMessage: async (msgParams, cb) => {\n        try {\n          const wc = await this.getWalletConnector();\n          const result = await wc.signMessage([msgParams.from, msgParams.data]);\n          cb(null, result);\n        } catch (error) {\n          cb(error);\n        }\n      },\n      processPersonalMessage: async (msgParams, cb) => {\n        try {\n          const wc = await this.getWalletConnector();\n          const result = await wc.signPersonalMessage([msgParams.data, msgParams.from]);\n          cb(null, result);\n        } catch (error) {\n          cb(error);\n        }\n      },\n      processSignTransaction: async (txParams, cb) => {\n        try {\n          const wc = await this.getWalletConnector();\n          const result = await wc.signTransaction(txParams);\n          cb(null, result);\n        } catch (error) {\n          cb(error);\n        }\n      },\n      processTransaction: async (txParams, cb) => {\n        try {\n          const wc = await this.getWalletConnector();\n          const result = await wc.sendTransaction(txParams);\n          cb(null, result);\n        } catch (error) {\n          cb(error);\n        }\n      },\n      processTypedMessage: async (msgParams, cb) => {\n        try {\n          const wc = await this.getWalletConnector();\n          const result = await wc.signTypedData([msgParams.from, msgParams.data]);\n          cb(null, result);\n        } catch (error) {\n          cb(error);\n        }\n      }\n    };\n  }\n\n}\n\nexport default WalletConnectProvider;","map":{"version":3,"sources":["../../src/index.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import WalletConnect from \"@walletconnect/client\";\nimport QRCodeModal from \"@walletconnect/qrcode-modal\";\nimport HttpConnection from \"@walletconnect/http-connection\";\nimport { payloadId, signingMethods, parsePersonalSign, getRpcUrl } from \"@walletconnect/utils\";\nconst ProviderEngine = require(\"web3-provider-engine\");\nconst CacheSubprovider = require(\"web3-provider-engine/subproviders/cache\");\nconst FixtureSubprovider = require(\"web3-provider-engine/subproviders/fixture\");\nconst FilterSubprovider = require(\"web3-provider-engine/subproviders/filters\");\nconst HookedWalletSubprovider = require(\"web3-provider-engine/subproviders/hooked-wallet\");\nconst NonceSubprovider = require(\"web3-provider-engine/subproviders/nonce-tracker\");\nconst SubscriptionsSubprovider = require(\"web3-provider-engine/subproviders/subscriptions\");\nclass WalletConnectProvider extends ProviderEngine {\n    constructor(opts) {\n        super({ pollingInterval: opts.pollingInterval || 8000 });\n        this.bridge = \"https://bridge.walletconnect.org\";\n        this.qrcode = true;\n        this.qrcodeModal = QRCodeModal;\n        this.qrcodeModalOptions = undefined;\n        this.rpc = null;\n        this.infuraId = \"\";\n        this.http = null;\n        this.isConnecting = false;\n        this.connected = false;\n        this.connectCallbacks = [];\n        this.accounts = [];\n        this.chainId = 1;\n        this.rpcUrl = \"\";\n        this.enable = async () => {\n            const wc = await this.getWalletConnector();\n            if (wc) {\n                this.start();\n                this.subscribeWalletConnector();\n                return wc.accounts;\n            }\n            else {\n                throw new Error(\"Failed to connect to WalleConnect\");\n            }\n        };\n        this.request = async (payload) => {\n            return this.send(payload);\n        };\n        this.send = async (payload, callback) => {\n            if (typeof payload === \"string\") {\n                const method = payload;\n                let params = callback;\n                if (method === \"personal_sign\") {\n                    params = parsePersonalSign(params);\n                }\n                return this.sendAsyncPromise(method, params);\n            }\n            payload = Object.assign({ id: payloadId(), jsonrpc: \"2.0\" }, payload);\n            if (payload.method === \"personal_sign\") {\n                payload.params = parsePersonalSign(payload.params);\n            }\n            if (callback) {\n                this.sendAsync(payload, callback);\n                return;\n            }\n            return this.sendAsyncPromise(payload.method, payload.params);\n        };\n        this.onConnect = (callback) => {\n            this.connectCallbacks.push(callback);\n        };\n        this.triggerConnect = (result) => {\n            if (this.connectCallbacks && this.connectCallbacks.length) {\n                this.connectCallbacks.forEach(callback => callback(result));\n            }\n        };\n        this.bridge = opts.connector\n            ? opts.connector.bridge\n            : opts.bridge || \"https://bridge.walletconnect.org\";\n        this.qrcode = typeof opts.qrcode === \"undefined\" || opts.qrcode !== false;\n        this.qrcodeModal = opts.qrcodeModal || this.qrcodeModal;\n        this.qrcodeModalOptions = opts.qrcodeModalOptions;\n        this.wc =\n            opts.connector ||\n                new WalletConnect({\n                    bridge: this.bridge,\n                    qrcodeModal: this.qrcode ? this.qrcodeModal : undefined,\n                    qrcodeModalOptions: this.qrcodeModalOptions,\n                    storageId: opts === null || opts === void 0 ? void 0 : opts.storageId,\n                    signingMethods: opts === null || opts === void 0 ? void 0 : opts.signingMethods,\n                    clientMeta: opts === null || opts === void 0 ? void 0 : opts.clientMeta,\n                });\n        this.rpc = opts.rpc || null;\n        if (!this.rpc &&\n            (!opts.infuraId || typeof opts.infuraId !== \"string\" || !opts.infuraId.trim())) {\n            throw new Error(\"Missing one of the required parameters: rpc or infuraId\");\n        }\n        this.infuraId = opts.infuraId || \"\";\n        this.chainId = (opts === null || opts === void 0 ? void 0 : opts.chainId) || this.chainId;\n        this.initialize();\n    }\n    get isWalletConnect() {\n        return true;\n    }\n    get connector() {\n        return this.wc;\n    }\n    get walletMeta() {\n        return this.wc.peerMeta;\n    }\n    async disconnect() {\n        this.close();\n    }\n    async close() {\n        const wc = await this.getWalletConnector({ disableSessionCreation: true });\n        await wc.killSession();\n        await this.onDisconnect();\n    }\n    async handleRequest(payload) {\n        try {\n            let response;\n            let result = null;\n            const wc = await this.getWalletConnector();\n            switch (payload.method) {\n                case \"wc_killSession\":\n                    await this.close();\n                    result = null;\n                    break;\n                case \"eth_accounts\":\n                    result = wc.accounts;\n                    break;\n                case \"eth_coinbase\":\n                    result = wc.accounts[0];\n                    break;\n                case \"eth_chainId\":\n                    result = wc.chainId;\n                    break;\n                case \"net_version\":\n                    result = wc.chainId;\n                    break;\n                case \"eth_uninstallFilter\":\n                    this.sendAsync(payload, (_) => _);\n                    result = true;\n                    break;\n                default:\n                    response = await this.handleOtherRequests(payload);\n            }\n            if (response) {\n                return response;\n            }\n            return this.formatResponse(payload, result);\n        }\n        catch (error) {\n            this.emit(\"error\", error);\n            throw error;\n        }\n    }\n    async handleOtherRequests(payload) {\n        if (!signingMethods.includes(payload.method) && payload.method.startsWith(\"eth_\")) {\n            return this.handleReadRequests(payload);\n        }\n        const wc = await this.getWalletConnector();\n        const result = await wc.sendCustomRequest(payload);\n        return this.formatResponse(payload, result);\n    }\n    async handleReadRequests(payload) {\n        if (!this.http) {\n            const error = new Error(\"HTTP Connection not available\");\n            this.emit(\"error\", error);\n            throw error;\n        }\n        return this.http.send(payload);\n    }\n    formatResponse(payload, result) {\n        return {\n            id: payload.id,\n            jsonrpc: payload.jsonrpc,\n            result: result,\n        };\n    }\n    getWalletConnector(opts = {}) {\n        const { disableSessionCreation = false } = opts;\n        return new Promise((resolve, reject) => {\n            const wc = this.wc;\n            if (this.isConnecting) {\n                this.onConnect((x) => resolve(x));\n            }\n            else if (!wc.connected && !disableSessionCreation) {\n                this.isConnecting = true;\n                wc.on(\"modal_closed\", () => {\n                    reject(new Error(\"User closed modal\"));\n                });\n                wc.createSession({ chainId: this.chainId })\n                    .then(() => {\n                    wc.on(\"connect\", (error, payload) => {\n                        if (error) {\n                            this.isConnecting = false;\n                            return reject(error);\n                        }\n                        this.isConnecting = false;\n                        this.connected = true;\n                        if (payload) {\n                            this.updateState(payload.params[0]);\n                        }\n                        this.emit(\"connect\");\n                        this.triggerConnect(wc);\n                        resolve(wc);\n                    });\n                })\n                    .catch(error => {\n                    this.isConnecting = false;\n                    reject(error);\n                });\n            }\n            else {\n                if (!this.connected) {\n                    this.connected = true;\n                    this.updateState(wc.session);\n                }\n                resolve(wc);\n            }\n        });\n    }\n    async subscribeWalletConnector() {\n        const wc = await this.getWalletConnector();\n        wc.on(\"disconnect\", error => {\n            if (error) {\n                this.emit(\"error\", error);\n                return;\n            }\n            this.onDisconnect();\n        });\n        wc.on(\"session_update\", (error, payload) => {\n            if (error) {\n                this.emit(\"error\", error);\n                return;\n            }\n            this.updateState(payload.params[0]);\n        });\n    }\n    async onDisconnect() {\n        await this.stop();\n        this.emit(\"close\", 1000, \"Connection closed\");\n        this.emit(\"disconnect\", 1000, \"Connection disconnected\");\n    }\n    async updateState(sessionParams) {\n        const { accounts, chainId, networkId, rpcUrl } = sessionParams;\n        if (!this.accounts || (accounts && this.accounts !== accounts)) {\n            this.accounts = accounts;\n            this.emit(\"accountsChanged\", accounts);\n        }\n        if (!this.chainId || (chainId && this.chainId !== chainId)) {\n            this.chainId = chainId;\n            this.emit(\"chainChanged\", chainId);\n        }\n        if (!this.networkId || (networkId && this.networkId !== networkId)) {\n            this.networkId = networkId;\n            this.emit(\"networkChanged\", networkId);\n        }\n        this.updateRpcUrl(this.chainId, rpcUrl || \"\");\n    }\n    updateRpcUrl(chainId, rpcUrl = \"\") {\n        const rpc = { infuraId: this.infuraId, custom: this.rpc || undefined };\n        rpcUrl = rpcUrl || getRpcUrl(chainId, rpc);\n        if (rpcUrl) {\n            this.rpcUrl = rpcUrl;\n            this.updateHttpConnection();\n        }\n        else {\n            this.emit(\"error\", new Error(`No RPC Url available for chainId: ${chainId}`));\n        }\n    }\n    updateHttpConnection() {\n        if (this.rpcUrl) {\n            this.http = new HttpConnection(this.rpcUrl);\n            this.http.on(\"payload\", payload => this.emit(\"payload\", payload));\n            this.http.on(\"error\", error => this.emit(\"error\", error));\n        }\n    }\n    sendAsyncPromise(method, params) {\n        return new Promise((resolve, reject) => {\n            this.sendAsync({\n                id: payloadId(),\n                jsonrpc: \"2.0\",\n                method,\n                params: params || [],\n            }, (error, response) => {\n                if (error) {\n                    reject(error);\n                    return;\n                }\n                resolve(response.result);\n            });\n        });\n    }\n    initialize() {\n        this.updateRpcUrl(this.chainId);\n        this.addProvider(new FixtureSubprovider({\n            eth_hashrate: \"0x00\",\n            eth_mining: false,\n            eth_syncing: true,\n            net_listening: true,\n            web3_clientVersion: `WalletConnect/v1.x.x/javascript`,\n        }));\n        this.addProvider(new CacheSubprovider());\n        this.addProvider(new SubscriptionsSubprovider());\n        this.addProvider(new FilterSubprovider());\n        this.addProvider(new NonceSubprovider());\n        this.addProvider(new HookedWalletSubprovider(this.configWallet()));\n        this.addProvider({\n            handleRequest: async (payload, next, end) => {\n                try {\n                    const { error, result } = await this.handleRequest(payload);\n                    end(error, result);\n                }\n                catch (error) {\n                    end(error);\n                }\n            },\n            setEngine: (_) => _,\n        });\n    }\n    configWallet() {\n        return {\n            getAccounts: async (cb) => {\n                try {\n                    const wc = await this.getWalletConnector();\n                    const accounts = wc.accounts;\n                    if (accounts && accounts.length) {\n                        cb(null, accounts);\n                    }\n                    else {\n                        cb(new Error(\"Failed to get accounts\"));\n                    }\n                }\n                catch (error) {\n                    cb(error);\n                }\n            },\n            processMessage: async (msgParams, cb) => {\n                try {\n                    const wc = await this.getWalletConnector();\n                    const result = await wc.signMessage([msgParams.from, msgParams.data]);\n                    cb(null, result);\n                }\n                catch (error) {\n                    cb(error);\n                }\n            },\n            processPersonalMessage: async (msgParams, cb) => {\n                try {\n                    const wc = await this.getWalletConnector();\n                    const result = await wc.signPersonalMessage([msgParams.data, msgParams.from]);\n                    cb(null, result);\n                }\n                catch (error) {\n                    cb(error);\n                }\n            },\n            processSignTransaction: async (txParams, cb) => {\n                try {\n                    const wc = await this.getWalletConnector();\n                    const result = await wc.signTransaction(txParams);\n                    cb(null, result);\n                }\n                catch (error) {\n                    cb(error);\n                }\n            },\n            processTransaction: async (txParams, cb) => {\n                try {\n                    const wc = await this.getWalletConnector();\n                    const result = await wc.sendTransaction(txParams);\n                    cb(null, result);\n                }\n                catch (error) {\n                    cb(error);\n                }\n            },\n            processTypedMessage: async (msgParams, cb) => {\n                try {\n                    const wc = await this.getWalletConnector();\n                    const result = await wc.signTypedData([msgParams.from, msgParams.data]);\n                    cb(null, result);\n                }\n                catch (error) {\n                    cb(error);\n                }\n            },\n        };\n    }\n}\nexport default WalletConnectProvider;\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"module"}