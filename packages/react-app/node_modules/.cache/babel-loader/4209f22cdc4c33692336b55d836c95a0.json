{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport { locToRange, offsetToPosition } from 'graphql-language-service-utils';\nexport const LANGUAGE = 'GraphQL';\n\nfunction assert(value, message) {\n  if (!value) {\n    throw new Error(message);\n  }\n}\n\nfunction getRange(text, node) {\n  const location = node.loc;\n  assert(location, 'Expected ASTNode to have a location.');\n  return locToRange(text, location);\n}\n\nfunction getPosition(text, node) {\n  const location = node.loc;\n  assert(location, 'Expected ASTNode to have a location.');\n  return offsetToPosition(text, location.start);\n}\n\nexport function getDefinitionQueryResultForNamedType(text, node, dependencies) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const name = node.name.value;\n    const defNodes = dependencies.filter(({\n      definition\n    }) => definition.name && definition.name.value === name);\n\n    if (defNodes.length === 0) {\n      throw Error(`Definition not found for GraphQL type ${name}`);\n    }\n\n    const definitions = defNodes.map(({\n      filePath,\n      content,\n      definition\n    }) => getDefinitionForNodeDefinition(filePath || '', content, definition));\n    return {\n      definitions,\n      queryRange: definitions.map(_ => getRange(text, node))\n    };\n  });\n}\nexport function getDefinitionQueryResultForFragmentSpread(text, fragment, dependencies) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const name = fragment.name.value;\n    const defNodes = dependencies.filter(({\n      definition\n    }) => definition.name.value === name);\n\n    if (defNodes.length === 0) {\n      throw Error(`Definition not found for GraphQL fragment ${name}`);\n    }\n\n    const definitions = defNodes.map(({\n      filePath,\n      content,\n      definition\n    }) => getDefinitionForFragmentDefinition(filePath || '', content, definition));\n    return {\n      definitions,\n      queryRange: definitions.map(_ => getRange(text, fragment))\n    };\n  });\n}\nexport function getDefinitionQueryResultForDefinitionNode(path, text, definition) {\n  return {\n    definitions: [getDefinitionForFragmentDefinition(path, text, definition)],\n    queryRange: definition.name ? [getRange(text, definition.name)] : []\n  };\n}\n\nfunction getDefinitionForFragmentDefinition(path, text, definition) {\n  const name = definition.name;\n\n  if (!name) {\n    throw Error('Expected ASTNode to have a Name.');\n  }\n\n  return {\n    path,\n    position: getPosition(text, definition),\n    range: getRange(text, definition),\n    name: name.value || '',\n    language: LANGUAGE,\n    projectRoot: path\n  };\n}\n\nfunction getDefinitionForNodeDefinition(path, text, definition) {\n  const name = definition.name;\n  assert(name, 'Expected ASTNode to have a Name.');\n  return {\n    path,\n    position: getPosition(text, definition),\n    range: getRange(text, definition),\n    name: name.value || '',\n    language: LANGUAGE,\n    projectRoot: path\n  };\n}","map":{"version":3,"sources":["../src/getDefinition.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { locToRange, offsetToPosition, } from 'graphql-language-service-utils';\nexport const LANGUAGE = 'GraphQL';\nfunction assert(value, message) {\n    if (!value) {\n        throw new Error(message);\n    }\n}\nfunction getRange(text, node) {\n    const location = node.loc;\n    assert(location, 'Expected ASTNode to have a location.');\n    return locToRange(text, location);\n}\nfunction getPosition(text, node) {\n    const location = node.loc;\n    assert(location, 'Expected ASTNode to have a location.');\n    return offsetToPosition(text, location.start);\n}\nexport function getDefinitionQueryResultForNamedType(text, node, dependencies) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const name = node.name.value;\n        const defNodes = dependencies.filter(({ definition }) => definition.name && definition.name.value === name);\n        if (defNodes.length === 0) {\n            throw Error(`Definition not found for GraphQL type ${name}`);\n        }\n        const definitions = defNodes.map(({ filePath, content, definition }) => getDefinitionForNodeDefinition(filePath || '', content, definition));\n        return {\n            definitions,\n            queryRange: definitions.map(_ => getRange(text, node)),\n        };\n    });\n}\nexport function getDefinitionQueryResultForFragmentSpread(text, fragment, dependencies) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const name = fragment.name.value;\n        const defNodes = dependencies.filter(({ definition }) => definition.name.value === name);\n        if (defNodes.length === 0) {\n            throw Error(`Definition not found for GraphQL fragment ${name}`);\n        }\n        const definitions = defNodes.map(({ filePath, content, definition }) => getDefinitionForFragmentDefinition(filePath || '', content, definition));\n        return {\n            definitions,\n            queryRange: definitions.map(_ => getRange(text, fragment)),\n        };\n    });\n}\nexport function getDefinitionQueryResultForDefinitionNode(path, text, definition) {\n    return {\n        definitions: [getDefinitionForFragmentDefinition(path, text, definition)],\n        queryRange: definition.name ? [getRange(text, definition.name)] : [],\n    };\n}\nfunction getDefinitionForFragmentDefinition(path, text, definition) {\n    const name = definition.name;\n    if (!name) {\n        throw Error('Expected ASTNode to have a Name.');\n    }\n    return {\n        path,\n        position: getPosition(text, definition),\n        range: getRange(text, definition),\n        name: name.value || '',\n        language: LANGUAGE,\n        projectRoot: path,\n    };\n}\nfunction getDefinitionForNodeDefinition(path, text, definition) {\n    const name = definition.name;\n    assert(name, 'Expected ASTNode to have a Name.');\n    return {\n        path,\n        position: getPosition(text, definition),\n        range: getRange(text, definition),\n        name: name.value || '',\n        language: LANGUAGE,\n        projectRoot: path,\n    };\n}\n//# sourceMappingURL=getDefinition.js.map"]},"metadata":{},"sourceType":"module"}