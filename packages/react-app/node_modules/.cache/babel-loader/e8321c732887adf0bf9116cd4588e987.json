{"ast":null,"code":"var ethers = require('ethers');\n\nvar fs = require('fs');\n\nconst ProviderEngine = require('web3-provider-engine'); //const CacheSubprovider = require('web3-provider-engine/subproviders/cache.js')\n\n\nconst FixtureSubprovider = require('web3-provider-engine/subproviders/fixture.js');\n\nconst FilterSubprovider = require('web3-provider-engine/subproviders/filters.js');\n\nconst HookedWalletSubprovider = require('web3-provider-engine/subproviders/hooked-wallet-ethtx.js'); // const VmSubprovider = require('web3-provider-engine/subproviders/vm.js')\n\n\nconst NonceSubprovider = require('web3-provider-engine/subproviders/nonce-tracker.js');\n\nconst RpcSubprovider = require('web3-provider-engine/subproviders/rpc.js');\n\nconst WebSocketSubProvider = require('web3-provider-engine/subproviders/websocket.js');\n\nconst sigUtil = require('eth-sig-util');\n\nmodule.exports = BurnerProvider;\nlet metaAccount;\n\nfunction BurnerProvider(opts = {}) {\n  var engine; // = new ProviderEngine()\n\n  console.log(\"ðŸš›ðŸš›ðŸš›ðŸš›ðŸš›ðŸš›ðŸš› BurnerProvider ðŸš›ðŸš›ðŸš›ðŸš›ðŸš›ðŸš›ðŸš›\"); // let them pass in a simple string for the options and use that as infura or whatevs\n\n  if (typeof opts == \"string\") {\n    let rpcUrl = opts;\n    opts = {\n      rpcUrl\n    };\n  }\n\n  if (opts && opts.provider) {\n    //console.log(\"Adding optional provider: \",opts.provider)\n    //engine.addProvider(opts.provider)\n    engine = opts.provider; //console.log(\"Adding optional provider: \",opts.provider)\n  } else {\n    /*engine.addProvider(opts.provider)*/\n    engine = new ProviderEngine();\n  }\n\n  let provider = new ethers.providers.Web3Provider(engine);\n  let privateKeyStorageString = \"metaPrivateKey\";\n\n  if (opts.namespace) {\n    privateKeyStorageString = privateKeyStorageString + \"_\" + opts.namespace;\n  }\n\n  if (opts && opts.privateKey) {\n    //if they passed in a private key, use it to generate an account\n    //metaAccount = provider.eth.accounts.privateKeyToAccount(opts.privateKey)\n    metaAccount = new ethers.Wallet(opts.privateKey, provider); //console.log(\"metaAccount from pk\",metaAccount)\n  } else if (typeof localStorage != \"undefined\" && typeof localStorage.setItem == \"function\") {\n    //load private key out of local storage\n    let metaPrivateKey = localStorage.getItem(privateKeyStorageString);\n    if (metaPrivateKey == \"0\") metaPrivateKey = false;\n    if (metaPrivateKey && metaPrivateKey.length !== 66) metaPrivateKey = false; //if(metaPrivateKey) metaAccount = provider.eth.accounts.privateKeyToAccount(metaPrivateKey)\n\n    if (metaPrivateKey) metaAccount = new ethers.Wallet(metaPrivateKey, provider);\n  } else {\n    //local storage isn't an option and they didn't pass in a pk attempted to use the filesystem\n    try {\n      let fsPk = fs.readFileSync(\".pk\").toString();\n\n      if (fsPk) {\n        metaAccount = new ethers.Wallet(fsPk, provider);\n      }\n    } catch (e) {} // if not just generate a temp account in memory for this session\n    // (just leave metaAccount false and it will be created in the next block)\n\n  }\n\n  if (!metaAccount) {\n    //generate account either from a provided mnemonic, pk, or random generation\n    if (opts.mnemonic) {\n      const bip39 = require('bip39');\n\n      const hdkey = require('ethereumjs-wallet/hdkey');\n\n      let index = \"0\";\n\n      if (typeof opts.index != \"undefined\") {\n        index = opts.index;\n      }\n\n      const seed = bip39.mnemonicToSeedSync(opts.mnemonic);\n      const hdwallet = hdkey.fromMasterSeed(seed);\n      const wallet_hdpath = \"m/44'/60'/0'/0/\";\n      const wallet = hdwallet.derivePath(wallet_hdpath + index).getWallet();\n      const privateKey = \"0x\" + wallet.getPrivateKey().toString(\"hex\"); //metaAccount = provider.eth.accounts.privateKeyToAccount(privateKey)\n\n      metaAccount = new ethers.Wallet(privateKey, provider);\n    } else {\n      //metaAccount = provider.eth.accounts.create();\n      metaAccount = ethers.Wallet.createRandom();\n    } //if we needed to generate, save the pk to local storage\n\n\n    if (typeof localStorage != \"undefined\" && typeof localStorage.setItem == \"function\") {\n      localStorage.setItem(privateKeyStorageString, metaAccount.privateKey);\n    } else {\n      //if we can't use local storage try saving it to the filesystem\n      try {\n        fs.writeFileSync(\".pk\", metaAccount.privateKey);\n      } catch (e) {}\n    }\n  }\n\n  opts.getPrivateKey = (address, cb) => {\n    if (address.toLowerCase() == metaAccount.address.toLowerCase()) {\n      cb(null, Buffer.from(metaAccount.privateKey.replace(\"0x\", \"\"), 'hex'));\n    } else {\n      cb(\"unknown account\");\n    }\n  };\n\n  opts.getAccounts = cb => {\n    //console.log(\"metaAccount\",metaAccount)\n    cb(false, [metaAccount.address]);\n  }; // static results\n\n\n  engine.addProvider(new FixtureSubprovider({\n    web3_clientVersion: 'ProviderEngine/v0.0.0/javascript',\n    net_listening: true,\n    eth_hashrate: '0x00',\n    eth_mining: false,\n    eth_syncing: true\n  })); // cache layer // PULLED THANKS TO A HEADS UP FROM GSN! SORRY GUYS!\n  //engine.addProvider(new CacheSubprovider())\n  // filters\n\n  engine.addProvider(new FilterSubprovider()); // pending nonce\n\n  engine.addProvider(new NonceSubprovider()); // vm\n  // engine.addProvider(new VmSubprovider())\n  // id mgmt\n\n  const hookedWalletSubprovider = new HookedWalletSubprovider(opts);\n\n  hookedWalletSubprovider.signTypedMessage = function (msgParams, cb) {\n    opts.getPrivateKey(msgParams.from, function (err, privateKey) {\n      if (err) return cb(err);\n\n      if (typeof msgParams.data === 'string') {\n        msgParams.data = JSON.parse(msgParams.data);\n      }\n\n      const serialized = sigUtil.signTypedData_v4(privateKey, msgParams);\n      cb(null, serialized);\n    });\n  };\n\n  engine.addProvider(hookedWalletSubprovider);\n\n  if (opts && opts.rpcUrl && opts.rpcUrl.indexOf && opts.rpcUrl.indexOf(\"wss://\") == 0) {\n    engine.addProvider(new WebSocketSubProvider(opts));\n  } else {\n    // data source\n    engine.addProvider(new RpcSubprovider(opts));\n  } // start polling for blocks\n\n\n  engine.start(); //do this to prevent skipCache: true -- to prevent PollingBlockTracker undefined errors from eth-block-tracker/src/polling.js\n  //engine._blockTracker._setSkipCacheFlag = false\n\n  return engine;\n}","map":{"version":3,"sources":["/Users/chrisbuonocore/personal/hackathons/hackfs21/node_modules/burner-provider/index.js"],"names":["ethers","require","fs","ProviderEngine","FixtureSubprovider","FilterSubprovider","HookedWalletSubprovider","NonceSubprovider","RpcSubprovider","WebSocketSubProvider","sigUtil","module","exports","BurnerProvider","metaAccount","opts","engine","console","log","rpcUrl","provider","providers","Web3Provider","privateKeyStorageString","namespace","privateKey","Wallet","localStorage","setItem","metaPrivateKey","getItem","length","fsPk","readFileSync","toString","e","mnemonic","bip39","hdkey","index","seed","mnemonicToSeedSync","hdwallet","fromMasterSeed","wallet_hdpath","wallet","derivePath","getWallet","getPrivateKey","createRandom","writeFileSync","address","cb","toLowerCase","Buffer","from","replace","getAccounts","addProvider","web3_clientVersion","net_listening","eth_hashrate","eth_mining","eth_syncing","hookedWalletSubprovider","signTypedMessage","msgParams","err","data","JSON","parse","serialized","signTypedData_v4","indexOf","start"],"mappings":"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","sourcesContent":["var ethers = require('ethers');\nvar fs = require('fs');\nconst ProviderEngine = require('web3-provider-engine')\n//const CacheSubprovider = require('web3-provider-engine/subproviders/cache.js')\nconst FixtureSubprovider = require('web3-provider-engine/subproviders/fixture.js')\nconst FilterSubprovider = require('web3-provider-engine/subproviders/filters.js')\nconst HookedWalletSubprovider = require('web3-provider-engine/subproviders/hooked-wallet-ethtx.js')\n// const VmSubprovider = require('web3-provider-engine/subproviders/vm.js')\nconst NonceSubprovider = require('web3-provider-engine/subproviders/nonce-tracker.js')\nconst RpcSubprovider = require('web3-provider-engine/subproviders/rpc.js')\nconst WebSocketSubProvider = require('web3-provider-engine/subproviders/websocket.js')\n\nconst sigUtil = require('eth-sig-util')\n\nmodule.exports = BurnerProvider\n\nlet metaAccount\n\nfunction BurnerProvider(opts = {}){\n  var engine;// = new ProviderEngine()\n\n  console.log(\"ðŸš›ðŸš›ðŸš›ðŸš›ðŸš›ðŸš›ðŸš› BurnerProvider ðŸš›ðŸš›ðŸš›ðŸš›ðŸš›ðŸš›ðŸš›\")\n\n  // let them pass in a simple string for the options and use that as infura or whatevs\n  if(typeof opts == \"string\"){\n    let rpcUrl = opts\n    opts = {rpcUrl}\n  }\n\n  if(opts && opts.provider){\n    //console.log(\"Adding optional provider: \",opts.provider)\n    //engine.addProvider(opts.provider)\n    engine = opts.provider\n    //console.log(\"Adding optional provider: \",opts.provider)\n  }else{/*engine.addProvider(opts.provider)*/\n    engine = new ProviderEngine()\n  }\n\n  let provider = new ethers.providers.Web3Provider(engine)\n\n\n  let privateKeyStorageString = \"metaPrivateKey\"\n  if(opts.namespace){\n    privateKeyStorageString = privateKeyStorageString+\"_\"+opts.namespace\n  }\n\n  if(opts&&opts.privateKey){\n    //if they passed in a private key, use it to generate an account\n    //metaAccount = provider.eth.accounts.privateKeyToAccount(opts.privateKey)\n    metaAccount = new ethers.Wallet(opts.privateKey, provider);\n    //console.log(\"metaAccount from pk\",metaAccount)\n  } else if(typeof localStorage != \"undefined\"&&typeof localStorage.setItem == \"function\"){\n    //load private key out of local storage\n    let metaPrivateKey = localStorage.getItem(privateKeyStorageString)\n    if(metaPrivateKey==\"0\") metaPrivateKey=false;\n    if(metaPrivateKey && metaPrivateKey.length!==66) metaPrivateKey=false;\n    //if(metaPrivateKey) metaAccount = provider.eth.accounts.privateKeyToAccount(metaPrivateKey)\n    if(metaPrivateKey) metaAccount = new ethers.Wallet(metaPrivateKey, provider);\n  }else{\n    //local storage isn't an option and they didn't pass in a pk attempted to use the filesystem\n    try{\n      let fsPk = fs.readFileSync(\".pk\").toString()\n      if(fsPk){\n        metaAccount = new ethers.Wallet(fsPk, provider);\n      }\n    }catch(e){}\n    // if not just generate a temp account in memory for this session\n    // (just leave metaAccount false and it will be created in the next block)\n  }\n\n  if(!metaAccount){\n    //generate account either from a provided mnemonic, pk, or random generation\n    if(opts.mnemonic){\n      const bip39 = require('bip39');\n      const hdkey = require('ethereumjs-wallet/hdkey');\n      let index = \"0\"\n      if(typeof opts.index != \"undefined\"){\n        index = opts.index\n      }\n      const seed = bip39.mnemonicToSeedSync(opts.mnemonic);\n      const hdwallet = hdkey.fromMasterSeed(seed);\n      const wallet_hdpath = \"m/44'/60'/0'/0/\";\n      const wallet = hdwallet.derivePath(wallet_hdpath + index).getWallet();\n      const privateKey =\"0x\"+wallet.getPrivateKey().toString(\"hex\")\n      //metaAccount = provider.eth.accounts.privateKeyToAccount(privateKey)\n      metaAccount = new ethers.Wallet(privateKey, provider);\n    }else{\n      //metaAccount = provider.eth.accounts.create();\n      metaAccount = ethers.Wallet.createRandom()\n    }\n    //if we needed to generate, save the pk to local storage\n    if(typeof localStorage != \"undefined\"&&typeof localStorage.setItem == \"function\"){\n      localStorage.setItem(privateKeyStorageString,metaAccount.privateKey)\n    }else{\n      //if we can't use local storage try saving it to the filesystem\n      try{\n        fs.writeFileSync(\".pk\",metaAccount.privateKey)\n      }catch(e){}\n    }\n  }\n\n  opts.getPrivateKey = (address,cb)=>{\n    if(address.toLowerCase()==metaAccount.address.toLowerCase()){\n      cb(null,Buffer.from(metaAccount.privateKey.replace(\"0x\",\"\"),'hex'))\n    }else{\n      cb(\"unknown account\")\n    }\n  }\n\n  opts.getAccounts = (cb)=>{\n    //console.log(\"metaAccount\",metaAccount)\n    cb(false,[metaAccount.address])\n  }\n\n  // static results\n  engine.addProvider(new FixtureSubprovider({\n    web3_clientVersion: 'ProviderEngine/v0.0.0/javascript',\n    net_listening: true,\n    eth_hashrate: '0x00',\n    eth_mining: false,\n    eth_syncing: true,\n  }))\n\n\n  // cache layer // PULLED THANKS TO A HEADS UP FROM GSN! SORRY GUYS!\n  //engine.addProvider(new CacheSubprovider())\n\n  // filters\n  engine.addProvider(new FilterSubprovider())\n\n  // pending nonce\n  engine.addProvider(new NonceSubprovider())\n\n  // vm\n  // engine.addProvider(new VmSubprovider())\n\n  // id mgmt\n  const hookedWalletSubprovider = new HookedWalletSubprovider(opts)\n\n  hookedWalletSubprovider.signTypedMessage = function (msgParams, cb) {\n    opts.getPrivateKey(msgParams.from, function(err, privateKey) {\n      if (err) return cb(err)\n\n      if (typeof msgParams.data === 'string') {\n        msgParams.data = JSON.parse(msgParams.data);\n      }\n\n      const serialized = sigUtil.signTypedData_v4(privateKey, msgParams)\n      cb(null, serialized)\n    })\n  }\n  engine.addProvider(hookedWalletSubprovider)\n\n\n\n  if(opts&&opts.rpcUrl&&opts.rpcUrl.indexOf&&opts.rpcUrl.indexOf(\"wss://\")==0){\n    engine.addProvider(new WebSocketSubProvider(opts))\n  }else{\n    // data source\n    engine.addProvider(new RpcSubprovider(opts))\n  }\n\n  // start polling for blocks\n  engine.start()\n\n\n  //do this to prevent skipCache: true -- to prevent PollingBlockTracker undefined errors from eth-block-tracker/src/polling.js\n  //engine._blockTracker._setSkipCacheFlag = false\n\n  return engine\n}\n"]},"metadata":{},"sourceType":"script"}