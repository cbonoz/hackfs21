{"ast":null,"code":"import { print } from 'graphql';\nimport { findDeprecatedUsages, parse } from 'graphql';\nimport { CharacterStream, onlineParser } from 'graphql-language-service-parser';\nimport { Range, validateWithCustomRules, Position } from 'graphql-language-service-utils';\nexport const SEVERITY = {\n  Error: 'Error',\n  Warning: 'Warning',\n  Information: 'Information',\n  Hint: 'Hint'\n};\nexport const DIAGNOSTIC_SEVERITY = {\n  [SEVERITY.Error]: 1,\n  [SEVERITY.Warning]: 2,\n  [SEVERITY.Information]: 3,\n  [SEVERITY.Hint]: 4\n};\n\nconst invariant = (condition, message) => {\n  if (!condition) {\n    throw new Error(message);\n  }\n};\n\nexport function getDiagnostics(query, schema = null, customRules, isRelayCompatMode, externalFragments) {\n  let ast = null;\n\n  if (externalFragments) {\n    if (typeof externalFragments === 'string') {\n      query += '\\n\\n' + externalFragments;\n    } else {\n      query += '\\n\\n' + externalFragments.reduce((agg, node) => {\n        agg += print(node) + '\\n\\n';\n        return agg;\n      }, '');\n    }\n  }\n\n  try {\n    ast = parse(query);\n  } catch (error) {\n    const range = getRange(error.locations[0], query);\n    return [{\n      severity: DIAGNOSTIC_SEVERITY.Error,\n      message: error.message,\n      source: 'GraphQL: Syntax',\n      range\n    }];\n  }\n\n  return validateQuery(ast, schema, customRules, isRelayCompatMode);\n}\nexport function validateQuery(ast, schema = null, customRules, isRelayCompatMode) {\n  if (!schema) {\n    return [];\n  }\n\n  const validationErrorAnnotations = mapCat(validateWithCustomRules(schema, ast, customRules, isRelayCompatMode), error => annotations(error, DIAGNOSTIC_SEVERITY.Error, 'Validation'));\n  const deprecationWarningAnnotations = mapCat(findDeprecatedUsages(schema, ast), error => annotations(error, DIAGNOSTIC_SEVERITY.Warning, 'Deprecation'));\n  return validationErrorAnnotations.concat(deprecationWarningAnnotations);\n}\n\nfunction mapCat(array, mapper) {\n  return Array.prototype.concat.apply([], array.map(mapper));\n}\n\nfunction annotations(error, severity, type) {\n  if (!error.nodes) {\n    return [];\n  }\n\n  const highlightedNodes = [];\n  error.nodes.forEach(node => {\n    const highlightNode = node.kind !== 'Variable' && 'name' in node && node.name !== undefined ? node.name : 'variable' in node && node.variable !== undefined ? node.variable : node;\n\n    if (highlightNode) {\n      invariant(error.locations, 'GraphQL validation error requires locations.');\n      const loc = error.locations[0];\n      const highlightLoc = getLocation(highlightNode);\n      const end = loc.column + (highlightLoc.end - highlightLoc.start);\n      highlightedNodes.push({\n        source: `GraphQL: ${type}`,\n        message: error.message,\n        severity,\n        range: new Range(new Position(loc.line - 1, loc.column - 1), new Position(loc.line - 1, end))\n      });\n    }\n  });\n  return highlightedNodes;\n}\n\nexport function getRange(location, queryText) {\n  const parser = onlineParser();\n  const state = parser.startState();\n  const lines = queryText.split('\\n');\n  invariant(lines.length >= location.line, 'Query text must have more lines than where the error happened');\n  let stream = null;\n\n  for (let i = 0; i < location.line; i++) {\n    stream = new CharacterStream(lines[i]);\n\n    while (!stream.eol()) {\n      const style = parser.token(stream, state);\n\n      if (style === 'invalidchar') {\n        break;\n      }\n    }\n  }\n\n  invariant(stream, 'Expected Parser stream to be available.');\n  const line = location.line - 1;\n  const start = stream.getStartOfToken();\n  const end = stream.getCurrentPosition();\n  return new Range(new Position(line, start), new Position(line, end));\n}\n\nfunction getLocation(node) {\n  const typeCastedNode = node;\n  const location = typeCastedNode.loc;\n  invariant(location, 'Expected ASTNode to have a location.');\n  return location;\n}","map":{"version":3,"sources":["../src/getDiagnostics.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { print, } from 'graphql';\nimport { findDeprecatedUsages, parse } from 'graphql';\nimport { CharacterStream, onlineParser } from 'graphql-language-service-parser';\nimport { Range, validateWithCustomRules, Position, } from 'graphql-language-service-utils';\nexport const SEVERITY = {\n    Error: 'Error',\n    Warning: 'Warning',\n    Information: 'Information',\n    Hint: 'Hint',\n};\nexport const DIAGNOSTIC_SEVERITY = {\n    [SEVERITY.Error]: 1,\n    [SEVERITY.Warning]: 2,\n    [SEVERITY.Information]: 3,\n    [SEVERITY.Hint]: 4,\n};\nconst invariant = (condition, message) => {\n    if (!condition) {\n        throw new Error(message);\n    }\n};\nexport function getDiagnostics(query, schema = null, customRules, isRelayCompatMode, externalFragments) {\n    let ast = null;\n    if (externalFragments) {\n        if (typeof externalFragments === 'string') {\n            query += '\\n\\n' + externalFragments;\n        }\n        else {\n            query +=\n                '\\n\\n' +\n                    externalFragments.reduce((agg, node) => {\n                        agg += print(node) + '\\n\\n';\n                        return agg;\n                    }, '');\n        }\n    }\n    try {\n        ast = parse(query);\n    }\n    catch (error) {\n        const range = getRange(error.locations[0], query);\n        return [\n            {\n                severity: DIAGNOSTIC_SEVERITY.Error,\n                message: error.message,\n                source: 'GraphQL: Syntax',\n                range,\n            },\n        ];\n    }\n    return validateQuery(ast, schema, customRules, isRelayCompatMode);\n}\nexport function validateQuery(ast, schema = null, customRules, isRelayCompatMode) {\n    if (!schema) {\n        return [];\n    }\n    const validationErrorAnnotations = mapCat(validateWithCustomRules(schema, ast, customRules, isRelayCompatMode), error => annotations(error, DIAGNOSTIC_SEVERITY.Error, 'Validation'));\n    const deprecationWarningAnnotations = mapCat(findDeprecatedUsages(schema, ast), error => annotations(error, DIAGNOSTIC_SEVERITY.Warning, 'Deprecation'));\n    return validationErrorAnnotations.concat(deprecationWarningAnnotations);\n}\nfunction mapCat(array, mapper) {\n    return Array.prototype.concat.apply([], array.map(mapper));\n}\nfunction annotations(error, severity, type) {\n    if (!error.nodes) {\n        return [];\n    }\n    const highlightedNodes = [];\n    error.nodes.forEach(node => {\n        const highlightNode = node.kind !== 'Variable' && 'name' in node && node.name !== undefined\n            ? node.name\n            : 'variable' in node && node.variable !== undefined\n                ? node.variable\n                : node;\n        if (highlightNode) {\n            invariant(error.locations, 'GraphQL validation error requires locations.');\n            const loc = error.locations[0];\n            const highlightLoc = getLocation(highlightNode);\n            const end = loc.column + (highlightLoc.end - highlightLoc.start);\n            highlightedNodes.push({\n                source: `GraphQL: ${type}`,\n                message: error.message,\n                severity,\n                range: new Range(new Position(loc.line - 1, loc.column - 1), new Position(loc.line - 1, end)),\n            });\n        }\n    });\n    return highlightedNodes;\n}\nexport function getRange(location, queryText) {\n    const parser = onlineParser();\n    const state = parser.startState();\n    const lines = queryText.split('\\n');\n    invariant(lines.length >= location.line, 'Query text must have more lines than where the error happened');\n    let stream = null;\n    for (let i = 0; i < location.line; i++) {\n        stream = new CharacterStream(lines[i]);\n        while (!stream.eol()) {\n            const style = parser.token(stream, state);\n            if (style === 'invalidchar') {\n                break;\n            }\n        }\n    }\n    invariant(stream, 'Expected Parser stream to be available.');\n    const line = location.line - 1;\n    const start = stream.getStartOfToken();\n    const end = stream.getCurrentPosition();\n    return new Range(new Position(line, start), new Position(line, end));\n}\nfunction getLocation(node) {\n    const typeCastedNode = node;\n    const location = typeCastedNode.loc;\n    invariant(location, 'Expected ASTNode to have a location.');\n    return location;\n}\n//# sourceMappingURL=getDiagnostics.js.map"]},"metadata":{},"sourceType":"module"}