{"ast":null,"code":"import { Kind, specifiedRules, validate, NoUnusedFragmentsRule, KnownFragmentNamesRule } from 'graphql';\nimport { ExecutableDefinitions } from 'graphql/validation/rules/ExecutableDefinitions';\nexport function validateWithCustomRules(schema, ast, customRules, isRelayCompatMode) {\n  const rules = specifiedRules.filter(rule => {\n    if (rule === NoUnusedFragmentsRule || rule === ExecutableDefinitions) {\n      return false;\n    }\n\n    if (isRelayCompatMode && rule === KnownFragmentNamesRule) {\n      return false;\n    }\n\n    return true;\n  });\n\n  if (customRules) {\n    Array.prototype.push.apply(rules, customRules);\n  }\n\n  const errors = validate(schema, ast, rules);\n  return errors.filter(error => {\n    if (error.message.indexOf('Unknown directive') !== -1 && error.nodes) {\n      const node = error.nodes[0];\n\n      if (node && node.kind === Kind.DIRECTIVE) {\n        const name = node.name.value;\n\n        if (name === 'arguments' || name === 'argumentDefinitions') {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  });\n}","map":{"version":3,"sources":["../src/validateWithCustomRules.ts"],"names":[],"mappings":"AASA,SAGE,IAHF,EAIE,cAJF,EAKE,QALF,EAQE,qBARF,EASE,sBATF,QAUO,SAVP;AAWA,SAAS,qBAAT,QAAsC,gDAAtC;AAKA,OAAM,SAAU,uBAAV,CACJ,MADI,EAEJ,GAFI,EAGJ,WAHI,EAIJ,iBAJI,EAIuB;AAE3B,QAAM,KAAK,GAAG,cAAc,CAAC,MAAf,CAAsB,IAAI,IAAG;AAIzC,QAAI,IAAI,KAAK,qBAAT,IAAkC,IAAI,KAAK,qBAA/C,EAAsE;AACpE,aAAO,KAAP;AACD;;AACD,QAAI,iBAAiB,IAAI,IAAI,KAAK,sBAAlC,EAA0D;AACxD,aAAO,KAAP;AACD;;AACD,WAAO,IAAP;AACD,GAXa,CAAd;;AAaA,MAAI,WAAJ,EAAiB;AACf,IAAA,KAAK,CAAC,SAAN,CAAgB,IAAhB,CAAqB,KAArB,CAA2B,KAA3B,EAAkC,WAAlC;AACD;;AAED,QAAM,MAAM,GAAG,QAAQ,CAAC,MAAD,EAAS,GAAT,EAAc,KAAd,CAAvB;AACA,SAAO,MAAM,CAAC,MAAP,CAAc,KAAK,IAAG;AAC3B,QAAI,KAAK,CAAC,OAAN,CAAc,OAAd,CAAsB,mBAAtB,MAA+C,CAAC,CAAhD,IAAqD,KAAK,CAAC,KAA/D,EAAsE;AACpE,YAAM,IAAI,GAAG,KAAK,CAAC,KAAN,CAAY,CAAZ,CAAb;;AACA,UAAI,IAAI,IAAI,IAAI,CAAC,IAAL,KAAc,IAAI,CAAC,SAA/B,EAA0C;AACxC,cAAM,IAAI,GAAG,IAAI,CAAC,IAAL,CAAU,KAAvB;;AACA,YAAI,IAAI,KAAK,WAAT,IAAwB,IAAI,KAAK,qBAArC,EAA4D;AAC1D,iBAAO,KAAP;AACD;AACF;AACF;;AACD,WAAO,IAAP;AACD,GAXM,CAAP;AAYD","sourceRoot":"","sourcesContent":["import { Kind, specifiedRules, validate, NoUnusedFragmentsRule, KnownFragmentNamesRule, } from 'graphql';\nimport { ExecutableDefinitions } from 'graphql/validation/rules/ExecutableDefinitions';\nexport function validateWithCustomRules(schema, ast, customRules, isRelayCompatMode) {\n    const rules = specifiedRules.filter(rule => {\n        if (rule === NoUnusedFragmentsRule || rule === ExecutableDefinitions) {\n            return false;\n        }\n        if (isRelayCompatMode && rule === KnownFragmentNamesRule) {\n            return false;\n        }\n        return true;\n    });\n    if (customRules) {\n        Array.prototype.push.apply(rules, customRules);\n    }\n    const errors = validate(schema, ast, rules);\n    return errors.filter(error => {\n        if (error.message.indexOf('Unknown directive') !== -1 && error.nodes) {\n            const node = error.nodes[0];\n            if (node && node.kind === Kind.DIRECTIVE) {\n                const name = node.name.value;\n                if (name === 'arguments' || name === 'argumentDefinitions') {\n                    return false;\n                }\n            }\n        }\n        return true;\n    });\n}\n//# sourceMappingURL=validateWithCustomRules.js.map"]},"metadata":{},"sourceType":"module"}