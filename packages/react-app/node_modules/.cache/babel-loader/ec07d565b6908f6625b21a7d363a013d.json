{"ast":null,"code":"import { opt, list, butNot, t, p } from './RuleHelpers';\nexport const isIgnored = ch => ch === ' ' || ch === '\\t' || ch === ',' || ch === '\\n' || ch === '\\r' || ch === '\\uFEFF' || ch === '\\u00A0';\nexport const LexRules = {\n  Name: /^[_A-Za-z][_0-9A-Za-z]*/,\n  Punctuation: /^(?:!|\\$|\\(|\\)|\\.\\.\\.|:|=|&|@|\\[|]|\\{|\\||\\})/,\n  Number: /^-?(?:0|(?:[1-9][0-9]*))(?:\\.[0-9]*)?(?:[eE][+-]?[0-9]+)?/,\n  String: /^(?:\"\"\"(?:\\\\\"\"\"|[^\"]|\"[^\"]|\"\"[^\"])*(?:\"\"\")?|\"(?:[^\"\\\\]|\\\\(?:\"|\\/|\\\\|b|f|n|r|t|u[0-9a-fA-F]{4}))*\"?)/,\n  Comment: /^#.*/\n};\nexport const ParseRules = {\n  Document: [list('Definition')],\n\n  Definition(token) {\n    switch (token.value) {\n      case '{':\n        return 'ShortQuery';\n\n      case 'query':\n        return 'Query';\n\n      case 'mutation':\n        return 'Mutation';\n\n      case 'subscription':\n        return 'Subscription';\n\n      case 'fragment':\n        return 'FragmentDefinition';\n\n      case 'schema':\n        return 'SchemaDef';\n\n      case 'scalar':\n        return 'ScalarDef';\n\n      case 'type':\n        return 'ObjectTypeDef';\n\n      case 'interface':\n        return 'InterfaceDef';\n\n      case 'union':\n        return 'UnionDef';\n\n      case 'enum':\n        return 'EnumDef';\n\n      case 'input':\n        return 'InputDef';\n\n      case 'extend':\n        return 'ExtendDef';\n\n      case 'directive':\n        return 'DirectiveDef';\n    }\n  },\n\n  ShortQuery: ['SelectionSet'],\n  Query: [word('query'), opt(name('def')), opt('VariableDefinitions'), list('Directive'), 'SelectionSet'],\n  Mutation: [word('mutation'), opt(name('def')), opt('VariableDefinitions'), list('Directive'), 'SelectionSet'],\n  Subscription: [word('subscription'), opt(name('def')), opt('VariableDefinitions'), list('Directive'), 'SelectionSet'],\n  VariableDefinitions: [p('('), list('VariableDefinition'), p(')')],\n  VariableDefinition: ['Variable', p(':'), 'Type', opt('DefaultValue')],\n  Variable: [p('$', 'variable'), name('variable')],\n  DefaultValue: [p('='), 'Value'],\n  SelectionSet: [p('{'), list('Selection'), p('}')],\n\n  Selection(token, stream) {\n    return token.value === '...' ? stream.match(/[\\s\\u00a0,]*(on\\b|@|{)/, false) ? 'InlineFragment' : 'FragmentSpread' : stream.match(/[\\s\\u00a0,]*:/, false) ? 'AliasedField' : 'Field';\n  },\n\n  AliasedField: [name('property'), p(':'), name('qualifier'), opt('Arguments'), list('Directive'), opt('SelectionSet')],\n  Field: [name('property'), opt('Arguments'), list('Directive'), opt('SelectionSet')],\n  Arguments: [p('('), list('Argument'), p(')')],\n  Argument: [name('attribute'), p(':'), 'Value'],\n  FragmentSpread: [p('...'), name('def'), list('Directive')],\n  InlineFragment: [p('...'), opt('TypeCondition'), list('Directive'), 'SelectionSet'],\n  FragmentDefinition: [word('fragment'), opt(butNot(name('def'), [word('on')])), 'TypeCondition', list('Directive'), 'SelectionSet'],\n  TypeCondition: [word('on'), 'NamedType'],\n\n  Value(token) {\n    switch (token.kind) {\n      case 'Number':\n        return 'NumberValue';\n\n      case 'String':\n        return 'StringValue';\n\n      case 'Punctuation':\n        switch (token.value) {\n          case '[':\n            return 'ListValue';\n\n          case '{':\n            return 'ObjectValue';\n\n          case '$':\n            return 'Variable';\n\n          case '&':\n            return 'NamedType';\n        }\n\n        return null;\n\n      case 'Name':\n        switch (token.value) {\n          case 'true':\n          case 'false':\n            return 'BooleanValue';\n        }\n\n        if (token.value === 'null') {\n          return 'NullValue';\n        }\n\n        return 'EnumValue';\n    }\n  },\n\n  NumberValue: [t('Number', 'number')],\n  StringValue: [t('String', 'string')],\n  BooleanValue: [t('Name', 'builtin')],\n  NullValue: [t('Name', 'keyword')],\n  EnumValue: [name('string-2')],\n  ListValue: [p('['), list('Value'), p(']')],\n  ObjectValue: [p('{'), list('ObjectField'), p('}')],\n  ObjectField: [name('attribute'), p(':'), 'Value'],\n\n  Type(token) {\n    return token.value === '[' ? 'ListType' : 'NonNullType';\n  },\n\n  ListType: [p('['), 'Type', p(']'), opt(p('!'))],\n  NonNullType: ['NamedType', opt(p('!'))],\n  NamedType: [type('atom')],\n  Directive: [p('@', 'meta'), name('meta'), opt('Arguments')],\n  DirectiveDef: [word('directive'), p('@', 'meta'), name('meta'), opt('ArgumentsDef'), word('on'), list('DirectiveLocation', p('|'))],\n  InterfaceDef: [word('interface'), name('atom'), opt('Implements'), list('Directive'), p('{'), list('FieldDef'), p('}')],\n  Implements: [word('implements'), list('NamedType', p('&'))],\n  DirectiveLocation: [name('string-2')],\n  SchemaDef: [word('schema'), list('Directive'), p('{'), list('OperationTypeDef'), p('}')],\n  OperationTypeDef: [name('keyword'), p(':'), name('atom')],\n  ScalarDef: [word('scalar'), name('atom'), list('Directive')],\n  ObjectTypeDef: [word('type'), name('atom'), opt('Implements'), list('Directive'), p('{'), list('FieldDef'), p('}')],\n  FieldDef: [name('property'), opt('ArgumentsDef'), p(':'), 'Type', list('Directive')],\n  ArgumentsDef: [p('('), list('InputValueDef'), p(')')],\n  InputValueDef: [name('attribute'), p(':'), 'Type', opt('DefaultValue'), list('Directive')],\n  UnionDef: [word('union'), name('atom'), list('Directive'), p('='), list('UnionMember', p('|'))],\n  UnionMember: ['NamedType'],\n  EnumDef: [word('enum'), name('atom'), list('Directive'), p('{'), list('EnumValueDef'), p('}')],\n  EnumValueDef: [name('string-2'), list('Directive')],\n  InputDef: [word('input'), name('atom'), list('Directive'), p('{'), list('InputValueDef'), p('}')],\n  ExtendDef: [word('extend'), 'ObjectTypeDef']\n};\n\nfunction word(value) {\n  return {\n    style: 'keyword',\n    match: token => token.kind === 'Name' && token.value === value\n  };\n}\n\nfunction name(style) {\n  return {\n    style,\n    match: token => token.kind === 'Name',\n\n    update(state, token) {\n      state.name = token.value;\n    }\n\n  };\n}\n\nfunction type(style) {\n  return {\n    style,\n    match: token => token.kind === 'Name',\n\n    update(state, token) {\n      if (state.prevState && state.prevState.prevState) {\n        state.name = token.value;\n        state.prevState.prevState.type = token.value;\n      }\n    }\n\n  };\n}","map":{"version":3,"sources":["../src/Rules.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { opt, list, butNot, t, p } from './RuleHelpers';\nexport const isIgnored = (ch) => ch === ' ' ||\n    ch === '\\t' ||\n    ch === ',' ||\n    ch === '\\n' ||\n    ch === '\\r' ||\n    ch === '\\uFEFF' ||\n    ch === '\\u00A0';\nexport const LexRules = {\n    Name: /^[_A-Za-z][_0-9A-Za-z]*/,\n    Punctuation: /^(?:!|\\$|\\(|\\)|\\.\\.\\.|:|=|&|@|\\[|]|\\{|\\||\\})/,\n    Number: /^-?(?:0|(?:[1-9][0-9]*))(?:\\.[0-9]*)?(?:[eE][+-]?[0-9]+)?/,\n    String: /^(?:\"\"\"(?:\\\\\"\"\"|[^\"]|\"[^\"]|\"\"[^\"])*(?:\"\"\")?|\"(?:[^\"\\\\]|\\\\(?:\"|\\/|\\\\|b|f|n|r|t|u[0-9a-fA-F]{4}))*\"?)/,\n    Comment: /^#.*/,\n};\nexport const ParseRules = {\n    Document: [list('Definition')],\n    Definition(token) {\n        switch (token.value) {\n            case '{':\n                return 'ShortQuery';\n            case 'query':\n                return 'Query';\n            case 'mutation':\n                return 'Mutation';\n            case 'subscription':\n                return 'Subscription';\n            case 'fragment':\n                return 'FragmentDefinition';\n            case 'schema':\n                return 'SchemaDef';\n            case 'scalar':\n                return 'ScalarDef';\n            case 'type':\n                return 'ObjectTypeDef';\n            case 'interface':\n                return 'InterfaceDef';\n            case 'union':\n                return 'UnionDef';\n            case 'enum':\n                return 'EnumDef';\n            case 'input':\n                return 'InputDef';\n            case 'extend':\n                return 'ExtendDef';\n            case 'directive':\n                return 'DirectiveDef';\n        }\n    },\n    ShortQuery: ['SelectionSet'],\n    Query: [\n        word('query'),\n        opt(name('def')),\n        opt('VariableDefinitions'),\n        list('Directive'),\n        'SelectionSet',\n    ],\n    Mutation: [\n        word('mutation'),\n        opt(name('def')),\n        opt('VariableDefinitions'),\n        list('Directive'),\n        'SelectionSet',\n    ],\n    Subscription: [\n        word('subscription'),\n        opt(name('def')),\n        opt('VariableDefinitions'),\n        list('Directive'),\n        'SelectionSet',\n    ],\n    VariableDefinitions: [p('('), list('VariableDefinition'), p(')')],\n    VariableDefinition: ['Variable', p(':'), 'Type', opt('DefaultValue')],\n    Variable: [p('$', 'variable'), name('variable')],\n    DefaultValue: [p('='), 'Value'],\n    SelectionSet: [p('{'), list('Selection'), p('}')],\n    Selection(token, stream) {\n        return token.value === '...'\n            ? stream.match(/[\\s\\u00a0,]*(on\\b|@|{)/, false)\n                ? 'InlineFragment'\n                : 'FragmentSpread'\n            : stream.match(/[\\s\\u00a0,]*:/, false)\n                ? 'AliasedField'\n                : 'Field';\n    },\n    AliasedField: [\n        name('property'),\n        p(':'),\n        name('qualifier'),\n        opt('Arguments'),\n        list('Directive'),\n        opt('SelectionSet'),\n    ],\n    Field: [\n        name('property'),\n        opt('Arguments'),\n        list('Directive'),\n        opt('SelectionSet'),\n    ],\n    Arguments: [p('('), list('Argument'), p(')')],\n    Argument: [name('attribute'), p(':'), 'Value'],\n    FragmentSpread: [p('...'), name('def'), list('Directive')],\n    InlineFragment: [\n        p('...'),\n        opt('TypeCondition'),\n        list('Directive'),\n        'SelectionSet',\n    ],\n    FragmentDefinition: [\n        word('fragment'),\n        opt(butNot(name('def'), [word('on')])),\n        'TypeCondition',\n        list('Directive'),\n        'SelectionSet',\n    ],\n    TypeCondition: [word('on'), 'NamedType'],\n    Value(token) {\n        switch (token.kind) {\n            case 'Number':\n                return 'NumberValue';\n            case 'String':\n                return 'StringValue';\n            case 'Punctuation':\n                switch (token.value) {\n                    case '[':\n                        return 'ListValue';\n                    case '{':\n                        return 'ObjectValue';\n                    case '$':\n                        return 'Variable';\n                    case '&':\n                        return 'NamedType';\n                }\n                return null;\n            case 'Name':\n                switch (token.value) {\n                    case 'true':\n                    case 'false':\n                        return 'BooleanValue';\n                }\n                if (token.value === 'null') {\n                    return 'NullValue';\n                }\n                return 'EnumValue';\n        }\n    },\n    NumberValue: [t('Number', 'number')],\n    StringValue: [t('String', 'string')],\n    BooleanValue: [t('Name', 'builtin')],\n    NullValue: [t('Name', 'keyword')],\n    EnumValue: [name('string-2')],\n    ListValue: [p('['), list('Value'), p(']')],\n    ObjectValue: [p('{'), list('ObjectField'), p('}')],\n    ObjectField: [name('attribute'), p(':'), 'Value'],\n    Type(token) {\n        return token.value === '[' ? 'ListType' : 'NonNullType';\n    },\n    ListType: [p('['), 'Type', p(']'), opt(p('!'))],\n    NonNullType: ['NamedType', opt(p('!'))],\n    NamedType: [type('atom')],\n    Directive: [p('@', 'meta'), name('meta'), opt('Arguments')],\n    DirectiveDef: [\n        word('directive'),\n        p('@', 'meta'),\n        name('meta'),\n        opt('ArgumentsDef'),\n        word('on'),\n        list('DirectiveLocation', p('|')),\n    ],\n    InterfaceDef: [\n        word('interface'),\n        name('atom'),\n        opt('Implements'),\n        list('Directive'),\n        p('{'),\n        list('FieldDef'),\n        p('}'),\n    ],\n    Implements: [word('implements'), list('NamedType', p('&'))],\n    DirectiveLocation: [name('string-2')],\n    SchemaDef: [\n        word('schema'),\n        list('Directive'),\n        p('{'),\n        list('OperationTypeDef'),\n        p('}'),\n    ],\n    OperationTypeDef: [name('keyword'), p(':'), name('atom')],\n    ScalarDef: [word('scalar'), name('atom'), list('Directive')],\n    ObjectTypeDef: [\n        word('type'),\n        name('atom'),\n        opt('Implements'),\n        list('Directive'),\n        p('{'),\n        list('FieldDef'),\n        p('}'),\n    ],\n    FieldDef: [\n        name('property'),\n        opt('ArgumentsDef'),\n        p(':'),\n        'Type',\n        list('Directive'),\n    ],\n    ArgumentsDef: [p('('), list('InputValueDef'), p(')')],\n    InputValueDef: [\n        name('attribute'),\n        p(':'),\n        'Type',\n        opt('DefaultValue'),\n        list('Directive'),\n    ],\n    UnionDef: [\n        word('union'),\n        name('atom'),\n        list('Directive'),\n        p('='),\n        list('UnionMember', p('|')),\n    ],\n    UnionMember: ['NamedType'],\n    EnumDef: [\n        word('enum'),\n        name('atom'),\n        list('Directive'),\n        p('{'),\n        list('EnumValueDef'),\n        p('}'),\n    ],\n    EnumValueDef: [name('string-2'), list('Directive')],\n    InputDef: [\n        word('input'),\n        name('atom'),\n        list('Directive'),\n        p('{'),\n        list('InputValueDef'),\n        p('}'),\n    ],\n    ExtendDef: [word('extend'), 'ObjectTypeDef'],\n};\nfunction word(value) {\n    return {\n        style: 'keyword',\n        match: (token) => token.kind === 'Name' && token.value === value,\n    };\n}\nfunction name(style) {\n    return {\n        style,\n        match: (token) => token.kind === 'Name',\n        update(state, token) {\n            state.name = token.value;\n        },\n    };\n}\nfunction type(style) {\n    return {\n        style,\n        match: (token) => token.kind === 'Name',\n        update(state, token) {\n            if (state.prevState && state.prevState.prevState) {\n                state.name = token.value;\n                state.prevState.prevState.type = token.value;\n            }\n        },\n    };\n}\n//# sourceMappingURL=Rules.js.map"]},"metadata":{},"sourceType":"module"}