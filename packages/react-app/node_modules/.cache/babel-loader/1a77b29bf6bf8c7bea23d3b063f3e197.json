{"ast":null,"code":"const util = require('./util');\n\nconst abi = require('./abi');\n\nconst TYPED_MESSAGE_SCHEMA = {\n  type: 'object',\n  properties: {\n    types: {\n      type: 'object',\n      additionalProperties: {\n        type: 'array',\n        items: {\n          type: 'object',\n          properties: {\n            name: {\n              type: 'string'\n            },\n            type: {\n              type: 'string'\n            }\n          },\n          required: ['name', 'type']\n        }\n      }\n    },\n    primaryType: {\n      type: 'string'\n    },\n    domain: {\n      type: 'object'\n    },\n    message: {\n      type: 'object'\n    }\n  },\n  required: ['types', 'primaryType', 'domain', 'message']\n};\n/**\n * A collection of utility functions used for signing typed data\n */\n\nconst TypedDataUtils = {\n  /**\n   * Encodes an object by encoding and concatenating each of its members\n   *\n   * @param {string} primaryType - Root type\n   * @param {Object} data - Object to encode\n   * @param {Object} types - Type definitions\n   * @returns {string} - Encoded representation of an object\n   */\n  encodeData(primaryType, data, types, useV4 = true) {\n    const encodedTypes = ['bytes32'];\n    const encodedValues = [this.hashType(primaryType, types)];\n\n    if (useV4) {\n      const encodeField = (name, type, value) => {\n        if (types[type] !== undefined) {\n          return ['bytes32', value == null ? '0x0000000000000000000000000000000000000000000000000000000000000000' : util.keccak(this.encodeData(type, value, types, useV4))];\n        }\n\n        if (value === undefined) throw new Error(`missing value for field ${name} of type ${type}`);\n\n        if (type === 'bytes') {\n          return ['bytes32', util.keccak(value)];\n        }\n\n        if (type === 'string') {\n          // convert string to buffer - prevents ethUtil from interpreting strings like '0xabcd' as hex\n          if (typeof value === 'string') {\n            value = Buffer.from(value, 'utf8');\n          }\n\n          return ['bytes32', util.keccak(value)];\n        }\n\n        if (type.lastIndexOf(']') === type.length - 1) {\n          const parsedType = type.slice(0, type.lastIndexOf('['));\n          const typeValuePairs = value.map(item => encodeField(name, parsedType, item));\n          return ['bytes32', util.keccak(abi.rawEncode(typeValuePairs.map(([type]) => type), typeValuePairs.map(([, value]) => value)))];\n        }\n\n        return [type, value];\n      };\n\n      for (const field of types[primaryType]) {\n        const [type, value] = encodeField(field.name, field.type, data[field.name]);\n        encodedTypes.push(type);\n        encodedValues.push(value);\n      }\n    } else {\n      for (const field of types[primaryType]) {\n        let value = data[field.name];\n\n        if (value !== undefined) {\n          if (field.type === 'bytes') {\n            encodedTypes.push('bytes32');\n            value = util.keccak(value);\n            encodedValues.push(value);\n          } else if (field.type === 'string') {\n            encodedTypes.push('bytes32'); // convert string to buffer - prevents ethUtil from interpreting strings like '0xabcd' as hex\n\n            if (typeof value === 'string') {\n              value = Buffer.from(value, 'utf8');\n            }\n\n            value = util.keccak(value);\n            encodedValues.push(value);\n          } else if (types[field.type] !== undefined) {\n            encodedTypes.push('bytes32');\n            value = util.keccak(this.encodeData(field.type, value, types, useV4));\n            encodedValues.push(value);\n          } else if (field.type.lastIndexOf(']') === field.type.length - 1) {\n            throw new Error('Arrays currently unimplemented in encodeData');\n          } else {\n            encodedTypes.push(field.type);\n            encodedValues.push(value);\n          }\n        }\n      }\n    }\n\n    return abi.rawEncode(encodedTypes, encodedValues);\n  },\n\n  /**\n   * Encodes the type of an object by encoding a comma delimited list of its members\n   *\n   * @param {string} primaryType - Root type to encode\n   * @param {Object} types - Type definitions\n   * @returns {string} - Encoded representation of the type of an object\n   */\n  encodeType(primaryType, types) {\n    let result = '';\n    let deps = this.findTypeDependencies(primaryType, types).filter(dep => dep !== primaryType);\n    deps = [primaryType].concat(deps.sort());\n\n    for (const type of deps) {\n      const children = types[type];\n\n      if (!children) {\n        throw new Error('No type definition specified: ' + type);\n      }\n\n      result += type + '(' + types[type].map(({\n        name,\n        type\n      }) => type + ' ' + name).join(',') + ')';\n    }\n\n    return result;\n  },\n\n  /**\n   * Finds all types within a type defintion object\n   *\n   * @param {string} primaryType - Root type\n   * @param {Object} types - Type definitions\n   * @param {Array} results - current set of accumulated types\n   * @returns {Array} - Set of all types found in the type definition\n   */\n  findTypeDependencies(primaryType, types, results = []) {\n    primaryType = primaryType.match(/^\\w*/)[0];\n\n    if (results.includes(primaryType) || types[primaryType] === undefined) {\n      return results;\n    }\n\n    results.push(primaryType);\n\n    for (const field of types[primaryType]) {\n      for (const dep of this.findTypeDependencies(field.type, types, results)) {\n        !results.includes(dep) && results.push(dep);\n      }\n    }\n\n    return results;\n  },\n\n  /**\n   * Hashes an object\n   *\n   * @param {string} primaryType - Root type\n   * @param {Object} data - Object to hash\n   * @param {Object} types - Type definitions\n   * @returns {string} - Hash of an object\n   */\n  hashStruct(primaryType, data, types, useV4 = true) {\n    return util.keccak(this.encodeData(primaryType, data, types, useV4));\n  },\n\n  /**\n   * Hashes the type of an object\n   *\n   * @param {string} primaryType - Root type to hash\n   * @param {Object} types - Type definitions\n   * @returns {string} - Hash of an object\n   */\n  hashType(primaryType, types) {\n    return util.keccak(this.encodeType(primaryType, types));\n  },\n\n  /**\n   * Removes properties from a message object that are not defined per EIP-712\n   *\n   * @param {Object} data - typed message object\n   * @returns {Object} - typed message object with only allowed fields\n   */\n  sanitizeData(data) {\n    const sanitizedData = {};\n\n    for (const key in TYPED_MESSAGE_SCHEMA.properties) {\n      data[key] && (sanitizedData[key] = data[key]);\n    }\n\n    if (sanitizedData.types) {\n      sanitizedData.types = Object.assign({\n        EIP712Domain: []\n      }, sanitizedData.types);\n    }\n\n    return sanitizedData;\n  },\n\n  /**\n   * Returns the hash of a typed message as per EIP-712 for signing\n   *\n   * @param {Object} typedData - Types message data to sign\n   * @returns {string} - sha3 hash for signing\n   */\n  hash(typedData, useV4 = true) {\n    const sanitizedData = this.sanitizeData(typedData);\n    const parts = [Buffer.from('1901', 'hex')];\n    parts.push(this.hashStruct('EIP712Domain', sanitizedData.domain, sanitizedData.types, useV4));\n\n    if (sanitizedData.primaryType !== 'EIP712Domain') {\n      parts.push(this.hashStruct(sanitizedData.primaryType, sanitizedData.message, sanitizedData.types, useV4));\n    }\n\n    return util.keccak(Buffer.concat(parts));\n  }\n\n};\nmodule.exports = {\n  TYPED_MESSAGE_SCHEMA,\n  TypedDataUtils,\n  hashForSignTypedDataLegacy: function (msgParams) {\n    return typedSignatureHashLegacy(msgParams.data);\n  },\n  hashForSignTypedData_v3: function (msgParams) {\n    return TypedDataUtils.hash(msgParams.data, false);\n  },\n  hashForSignTypedData_v4: function (msgParams) {\n    return TypedDataUtils.hash(msgParams.data);\n  }\n};\n/**\n * @param typedData - Array of data along with types, as per EIP712.\n * @returns Buffer\n */\n\nfunction typedSignatureHashLegacy(typedData) {\n  const error = new Error('Expect argument to be non-empty array');\n  if (typeof typedData !== 'object' || !typedData.length) throw error;\n  const data = typedData.map(function (e) {\n    return e.type === 'bytes' ? util.toBuffer(e.value) : e.value;\n  });\n  const types = typedData.map(function (e) {\n    return e.type;\n  });\n  const schema = typedData.map(function (e) {\n    if (!e.name) throw error;\n    return e.type + ' ' + e.name;\n  });\n  return abi.soliditySHA3(['bytes32', 'bytes32'], [abi.soliditySHA3(new Array(typedData.length).fill('string'), schema), abi.soliditySHA3(types, data)]);\n}","map":{"version":3,"sources":["/Users/chrisbuonocore/personal/hackathons/hackfs21/node_modules/walletlink/dist/vendor-js/eth-eip712-util/index.js"],"names":["util","require","abi","TYPED_MESSAGE_SCHEMA","type","properties","types","additionalProperties","items","name","required","primaryType","domain","message","TypedDataUtils","encodeData","data","useV4","encodedTypes","encodedValues","hashType","encodeField","value","undefined","keccak","Error","Buffer","from","lastIndexOf","length","parsedType","slice","typeValuePairs","map","item","rawEncode","field","push","encodeType","result","deps","findTypeDependencies","filter","dep","concat","sort","children","join","results","match","includes","hashStruct","sanitizeData","sanitizedData","key","Object","assign","EIP712Domain","hash","typedData","parts","module","exports","hashForSignTypedDataLegacy","msgParams","typedSignatureHashLegacy","hashForSignTypedData_v3","hashForSignTypedData_v4","error","e","toBuffer","schema","soliditySHA3","Array","fill"],"mappings":"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","sourcesContent":["const util = require('./util')\nconst abi = require('./abi')\n\nconst TYPED_MESSAGE_SCHEMA = {\n  type: 'object',\n  properties: {\n    types: {\n      type: 'object',\n      additionalProperties: {\n        type: 'array',\n        items: {\n          type: 'object',\n          properties: {\n            name: {type: 'string'},\n            type: {type: 'string'},\n          },\n          required: ['name', 'type'],\n        },\n      },\n    },\n    primaryType: {type: 'string'},\n    domain: {type: 'object'},\n    message: {type: 'object'},\n  },\n  required: ['types', 'primaryType', 'domain', 'message'],\n}\n\n/**\n * A collection of utility functions used for signing typed data\n */\nconst TypedDataUtils = {\n  /**\n   * Encodes an object by encoding and concatenating each of its members\n   *\n   * @param {string} primaryType - Root type\n   * @param {Object} data - Object to encode\n   * @param {Object} types - Type definitions\n   * @returns {string} - Encoded representation of an object\n   */\n  encodeData (primaryType, data, types, useV4 = true) {\n    const encodedTypes = ['bytes32']\n    const encodedValues = [this.hashType(primaryType, types)]\n\n    if(useV4) {\n      const encodeField = (name, type, value) => {\n        if (types[type] !== undefined) {\n          return ['bytes32', value == null ?\n            '0x0000000000000000000000000000000000000000000000000000000000000000' :\n            util.keccak(this.encodeData(type, value, types, useV4))]\n        }\n\n        if(value === undefined)\n          throw new Error(`missing value for field ${name} of type ${type}`)\n\n        if (type === 'bytes') {\n          return ['bytes32', util.keccak(value)]\n        }\n\n        if (type === 'string') {\n          // convert string to buffer - prevents ethUtil from interpreting strings like '0xabcd' as hex\n          if (typeof value === 'string') {\n            value = Buffer.from(value, 'utf8')\n          }\n          return ['bytes32', util.keccak(value)]\n        }\n\n        if (type.lastIndexOf(']') === type.length - 1) {\n          const parsedType = type.slice(0, type.lastIndexOf('['))\n          const typeValuePairs = value.map(item =>\n            encodeField(name, parsedType, item))\n          return ['bytes32', util.keccak(abi.rawEncode(\n            typeValuePairs.map(([type]) => type),\n            typeValuePairs.map(([, value]) => value),\n          ))]\n        }\n\n        return [type, value]\n      }\n\n      for (const field of types[primaryType]) {\n        const [type, value] = encodeField(field.name, field.type, data[field.name])\n        encodedTypes.push(type)\n        encodedValues.push(value)\n      }\n    } else {\n      for (const field of types[primaryType]) {\n        let value = data[field.name]\n        if (value !== undefined) {\n          if (field.type === 'bytes') {\n            encodedTypes.push('bytes32')\n            value = util.keccak(value)\n            encodedValues.push(value)\n          } else if (field.type === 'string') {\n            encodedTypes.push('bytes32')\n            // convert string to buffer - prevents ethUtil from interpreting strings like '0xabcd' as hex\n            if (typeof value === 'string') {\n              value = Buffer.from(value, 'utf8')\n            }\n            value = util.keccak(value)\n            encodedValues.push(value)\n          } else if (types[field.type] !== undefined) {\n            encodedTypes.push('bytes32')\n            value = util.keccak(this.encodeData(field.type, value, types, useV4))\n            encodedValues.push(value)\n          } else if (field.type.lastIndexOf(']') === field.type.length - 1) {\n            throw new Error('Arrays currently unimplemented in encodeData')\n          } else {\n            encodedTypes.push(field.type)\n            encodedValues.push(value)\n          }\n        }\n      }\n    }\n\n    return abi.rawEncode(encodedTypes, encodedValues)\n  },\n\n  /**\n   * Encodes the type of an object by encoding a comma delimited list of its members\n   *\n   * @param {string} primaryType - Root type to encode\n   * @param {Object} types - Type definitions\n   * @returns {string} - Encoded representation of the type of an object\n   */\n  encodeType (primaryType, types) {\n    let result = ''\n    let deps = this.findTypeDependencies(primaryType, types).filter(dep => dep !== primaryType)\n    deps = [primaryType].concat(deps.sort())\n    for (const type of deps) {\n      const children = types[type]\n      if (!children) {\n        throw new Error('No type definition specified: ' + type)\n      }\n      result += type + '(' + types[type].map(({ name, type }) => type + ' ' + name).join(',') + ')'\n    }\n    return result\n  },\n\n  /**\n   * Finds all types within a type defintion object\n   *\n   * @param {string} primaryType - Root type\n   * @param {Object} types - Type definitions\n   * @param {Array} results - current set of accumulated types\n   * @returns {Array} - Set of all types found in the type definition\n   */\n  findTypeDependencies (primaryType, types, results = []) {\n    primaryType = primaryType.match(/^\\w*/)[0]\n    if (results.includes(primaryType) || types[primaryType] === undefined) { return results }\n    results.push(primaryType)\n    for (const field of types[primaryType]) {\n      for (const dep of this.findTypeDependencies(field.type, types, results)) {\n        !results.includes(dep) && results.push(dep)\n      }\n    }\n    return results\n  },\n\n  /**\n   * Hashes an object\n   *\n   * @param {string} primaryType - Root type\n   * @param {Object} data - Object to hash\n   * @param {Object} types - Type definitions\n   * @returns {string} - Hash of an object\n   */\n  hashStruct (primaryType, data, types, useV4 = true) {\n    return util.keccak(this.encodeData(primaryType, data, types, useV4))\n  },\n\n  /**\n   * Hashes the type of an object\n   *\n   * @param {string} primaryType - Root type to hash\n   * @param {Object} types - Type definitions\n   * @returns {string} - Hash of an object\n   */\n  hashType (primaryType, types) {\n    return util.keccak(this.encodeType(primaryType, types))\n  },\n\n  /**\n   * Removes properties from a message object that are not defined per EIP-712\n   *\n   * @param {Object} data - typed message object\n   * @returns {Object} - typed message object with only allowed fields\n   */\n  sanitizeData (data) {\n    const sanitizedData = {}\n    for (const key in TYPED_MESSAGE_SCHEMA.properties) {\n      data[key] && (sanitizedData[key] = data[key])\n    }\n    if (sanitizedData.types) {\n      sanitizedData.types = Object.assign({ EIP712Domain: [] }, sanitizedData.types)\n    }\n    return sanitizedData\n  },\n\n  /**\n   * Returns the hash of a typed message as per EIP-712 for signing\n   *\n   * @param {Object} typedData - Types message data to sign\n   * @returns {string} - sha3 hash for signing\n   */\n  hash (typedData, useV4 = true) {\n    const sanitizedData = this.sanitizeData(typedData)\n    const parts = [Buffer.from('1901', 'hex')]\n    parts.push(this.hashStruct('EIP712Domain', sanitizedData.domain, sanitizedData.types, useV4))\n    if (sanitizedData.primaryType !== 'EIP712Domain') {\n      parts.push(this.hashStruct(sanitizedData.primaryType, sanitizedData.message, sanitizedData.types, useV4))\n    }\n    return util.keccak(Buffer.concat(parts))\n  },\n}\n\nmodule.exports = {\n  TYPED_MESSAGE_SCHEMA,\n  TypedDataUtils,\n\n  hashForSignTypedDataLegacy: function (msgParams) {\n    return typedSignatureHashLegacy(msgParams.data)\n  },\n\n  hashForSignTypedData_v3: function (msgParams) {\n    return TypedDataUtils.hash(msgParams.data, false)\n  },\n\n  hashForSignTypedData_v4: function (msgParams) {\n    return TypedDataUtils.hash(msgParams.data)\n  },\n}\n\n/**\n * @param typedData - Array of data along with types, as per EIP712.\n * @returns Buffer\n */\nfunction typedSignatureHashLegacy(typedData) {\n  const error = new Error('Expect argument to be non-empty array')\n  if (typeof typedData !== 'object' || !typedData.length) throw error\n\n  const data = typedData.map(function (e) {\n    return e.type === 'bytes' ? util.toBuffer(e.value) : e.value\n  })\n  const types = typedData.map(function (e) { return e.type })\n  const schema = typedData.map(function (e) {\n    if (!e.name) throw error\n    return e.type + ' ' + e.name\n  })\n\n  return abi.soliditySHA3(\n    ['bytes32', 'bytes32'],\n    [\n      abi.soliditySHA3(new Array(typedData.length).fill('string'), schema),\n      abi.soliditySHA3(types, data)\n    ]\n  )\n}\n"]},"metadata":{},"sourceType":"script"}