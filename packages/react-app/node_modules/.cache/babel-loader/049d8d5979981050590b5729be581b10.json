{"ast":null,"code":"//      Copyright (c) 2012 Mathieu Turcotte\n//      Licensed under the MIT license.\nvar events = require('events');\n\nvar util = require('util');\n\nfunction isDef(value) {\n  return value !== undefined && value !== null;\n} // Abstract class defining the skeleton for the backoff strategies. Accepts an\n// object holding the options for the backoff strategy:\n//\n//  * `randomisationFactor`: The randomisation factor which must be between 0\n//     and 1 where 1 equates to a randomization factor of 100% and 0 to no\n//     randomization.\n//  * `initialDelay`: The backoff initial delay in milliseconds.\n//  * `maxDelay`: The backoff maximal delay in milliseconds.\n\n\nfunction BackoffStrategy(options) {\n  options = options || {};\n\n  if (isDef(options.initialDelay) && options.initialDelay < 1) {\n    throw new Error('The initial timeout must be greater than 0.');\n  } else if (isDef(options.maxDelay) && options.maxDelay < 1) {\n    throw new Error('The maximal timeout must be greater than 0.');\n  }\n\n  this.initialDelay_ = options.initialDelay || 100;\n  this.maxDelay_ = options.maxDelay || 10000;\n\n  if (this.maxDelay_ <= this.initialDelay_) {\n    throw new Error('The maximal backoff delay must be ' + 'greater than the initial backoff delay.');\n  }\n\n  if (isDef(options.randomisationFactor) && (options.randomisationFactor < 0 || options.randomisationFactor > 1)) {\n    throw new Error('The randomisation factor must be between 0 and 1.');\n  }\n\n  this.randomisationFactor_ = options.randomisationFactor || 0;\n} // Gets the maximal backoff delay.\n\n\nBackoffStrategy.prototype.getMaxDelay = function () {\n  return this.maxDelay_;\n}; // Gets the initial backoff delay.\n\n\nBackoffStrategy.prototype.getInitialDelay = function () {\n  return this.initialDelay_;\n}; // Template method that computes and returns the next backoff delay in\n// milliseconds.\n\n\nBackoffStrategy.prototype.next = function () {\n  var backoffDelay = this.next_();\n  var randomisationMultiple = 1 + Math.random() * this.randomisationFactor_;\n  var randomizedDelay = Math.round(backoffDelay * randomisationMultiple);\n  return randomizedDelay;\n}; // Computes and returns the next backoff delay. Intended to be overridden by\n// subclasses.\n\n\nBackoffStrategy.prototype.next_ = function () {\n  throw new Error('BackoffStrategy.next_() unimplemented.');\n}; // Template method that resets the backoff delay to its initial value.\n\n\nBackoffStrategy.prototype.reset = function () {\n  this.reset_();\n}; // Resets the backoff delay to its initial value. Intended to be overridden by\n// subclasses.\n\n\nBackoffStrategy.prototype.reset_ = function () {\n  throw new Error('BackoffStrategy.reset_() unimplemented.');\n};\n\nmodule.exports = BackoffStrategy;","map":{"version":3,"sources":["/Users/chrisbuonocore/personal/hackathons/hackfs21/node_modules/backoff/lib/strategy/strategy.js"],"names":["events","require","util","isDef","value","undefined","BackoffStrategy","options","initialDelay","Error","maxDelay","initialDelay_","maxDelay_","randomisationFactor","randomisationFactor_","prototype","getMaxDelay","getInitialDelay","next","backoffDelay","next_","randomisationMultiple","Math","random","randomizedDelay","round","reset","reset_","module","exports"],"mappings":"AAAA;AACA;AAEA,IAAIA,MAAM,GAAGC,OAAO,CAAC,QAAD,CAApB;;AACA,IAAIC,IAAI,GAAGD,OAAO,CAAC,MAAD,CAAlB;;AAEA,SAASE,KAAT,CAAeC,KAAf,EAAsB;AAClB,SAAOA,KAAK,KAAKC,SAAV,IAAuBD,KAAK,KAAK,IAAxC;AACH,C,CAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASE,eAAT,CAAyBC,OAAzB,EAAkC;AAC9BA,EAAAA,OAAO,GAAGA,OAAO,IAAI,EAArB;;AAEA,MAAIJ,KAAK,CAACI,OAAO,CAACC,YAAT,CAAL,IAA+BD,OAAO,CAACC,YAAR,GAAuB,CAA1D,EAA6D;AACzD,UAAM,IAAIC,KAAJ,CAAU,6CAAV,CAAN;AACH,GAFD,MAEO,IAAIN,KAAK,CAACI,OAAO,CAACG,QAAT,CAAL,IAA2BH,OAAO,CAACG,QAAR,GAAmB,CAAlD,EAAqD;AACxD,UAAM,IAAID,KAAJ,CAAU,6CAAV,CAAN;AACH;;AAED,OAAKE,aAAL,GAAqBJ,OAAO,CAACC,YAAR,IAAwB,GAA7C;AACA,OAAKI,SAAL,GAAiBL,OAAO,CAACG,QAAR,IAAoB,KAArC;;AAEA,MAAI,KAAKE,SAAL,IAAkB,KAAKD,aAA3B,EAA0C;AACtC,UAAM,IAAIF,KAAJ,CAAU,uCACA,yCADV,CAAN;AAEH;;AAED,MAAIN,KAAK,CAACI,OAAO,CAACM,mBAAT,CAAL,KACCN,OAAO,CAACM,mBAAR,GAA8B,CAA9B,IAAmCN,OAAO,CAACM,mBAAR,GAA8B,CADlE,CAAJ,EAC0E;AACtE,UAAM,IAAIJ,KAAJ,CAAU,mDAAV,CAAN;AACH;;AAED,OAAKK,oBAAL,GAA4BP,OAAO,CAACM,mBAAR,IAA+B,CAA3D;AACH,C,CAED;;;AACAP,eAAe,CAACS,SAAhB,CAA0BC,WAA1B,GAAwC,YAAW;AAC/C,SAAO,KAAKJ,SAAZ;AACH,CAFD,C,CAIA;;;AACAN,eAAe,CAACS,SAAhB,CAA0BE,eAA1B,GAA4C,YAAW;AACnD,SAAO,KAAKN,aAAZ;AACH,CAFD,C,CAIA;AACA;;;AACAL,eAAe,CAACS,SAAhB,CAA0BG,IAA1B,GAAiC,YAAW;AACxC,MAAIC,YAAY,GAAG,KAAKC,KAAL,EAAnB;AACA,MAAIC,qBAAqB,GAAG,IAAIC,IAAI,CAACC,MAAL,KAAgB,KAAKT,oBAArD;AACA,MAAIU,eAAe,GAAGF,IAAI,CAACG,KAAL,CAAWN,YAAY,GAAGE,qBAA1B,CAAtB;AACA,SAAOG,eAAP;AACH,CALD,C,CAOA;AACA;;;AACAlB,eAAe,CAACS,SAAhB,CAA0BK,KAA1B,GAAkC,YAAW;AACzC,QAAM,IAAIX,KAAJ,CAAU,wCAAV,CAAN;AACH,CAFD,C,CAIA;;;AACAH,eAAe,CAACS,SAAhB,CAA0BW,KAA1B,GAAkC,YAAW;AACzC,OAAKC,MAAL;AACH,CAFD,C,CAIA;AACA;;;AACArB,eAAe,CAACS,SAAhB,CAA0BY,MAA1B,GAAmC,YAAW;AAC1C,QAAM,IAAIlB,KAAJ,CAAU,yCAAV,CAAN;AACH,CAFD;;AAIAmB,MAAM,CAACC,OAAP,GAAiBvB,eAAjB","sourcesContent":["//      Copyright (c) 2012 Mathieu Turcotte\n//      Licensed under the MIT license.\n\nvar events = require('events');\nvar util = require('util');\n\nfunction isDef(value) {\n    return value !== undefined && value !== null;\n}\n\n// Abstract class defining the skeleton for the backoff strategies. Accepts an\n// object holding the options for the backoff strategy:\n//\n//  * `randomisationFactor`: The randomisation factor which must be between 0\n//     and 1 where 1 equates to a randomization factor of 100% and 0 to no\n//     randomization.\n//  * `initialDelay`: The backoff initial delay in milliseconds.\n//  * `maxDelay`: The backoff maximal delay in milliseconds.\nfunction BackoffStrategy(options) {\n    options = options || {};\n\n    if (isDef(options.initialDelay) && options.initialDelay < 1) {\n        throw new Error('The initial timeout must be greater than 0.');\n    } else if (isDef(options.maxDelay) && options.maxDelay < 1) {\n        throw new Error('The maximal timeout must be greater than 0.');\n    }\n\n    this.initialDelay_ = options.initialDelay || 100;\n    this.maxDelay_ = options.maxDelay || 10000;\n\n    if (this.maxDelay_ <= this.initialDelay_) {\n        throw new Error('The maximal backoff delay must be ' +\n                        'greater than the initial backoff delay.');\n    }\n\n    if (isDef(options.randomisationFactor) &&\n        (options.randomisationFactor < 0 || options.randomisationFactor > 1)) {\n        throw new Error('The randomisation factor must be between 0 and 1.');\n    }\n\n    this.randomisationFactor_ = options.randomisationFactor || 0;\n}\n\n// Gets the maximal backoff delay.\nBackoffStrategy.prototype.getMaxDelay = function() {\n    return this.maxDelay_;\n};\n\n// Gets the initial backoff delay.\nBackoffStrategy.prototype.getInitialDelay = function() {\n    return this.initialDelay_;\n};\n\n// Template method that computes and returns the next backoff delay in\n// milliseconds.\nBackoffStrategy.prototype.next = function() {\n    var backoffDelay = this.next_();\n    var randomisationMultiple = 1 + Math.random() * this.randomisationFactor_;\n    var randomizedDelay = Math.round(backoffDelay * randomisationMultiple);\n    return randomizedDelay;\n};\n\n// Computes and returns the next backoff delay. Intended to be overridden by\n// subclasses.\nBackoffStrategy.prototype.next_ = function() {\n    throw new Error('BackoffStrategy.next_() unimplemented.');\n};\n\n// Template method that resets the backoff delay to its initial value.\nBackoffStrategy.prototype.reset = function() {\n    this.reset_();\n};\n\n// Resets the backoff delay to its initial value. Intended to be overridden by\n// subclasses.\nBackoffStrategy.prototype.reset_ = function() {\n    throw new Error('BackoffStrategy.reset_() unimplemented.');\n};\n\nmodule.exports = BackoffStrategy;\n"]},"metadata":{},"sourceType":"script"}