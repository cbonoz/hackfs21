{"ast":null,"code":"import { WordArray, Hasher } from './core.js'; // Initialization and round constants tables\n\nconst H = [];\nconst K = []; // Compute constants\n\nconst isPrime = n => {\n  const sqrtN = Math.sqrt(n);\n\n  for (let factor = 2; factor <= sqrtN; factor += 1) {\n    if (!(n % factor)) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\nconst getFractionalBits = n => (n - (n | 0)) * 0x100000000 | 0;\n\nlet n = 2;\nlet nPrime = 0;\n\nwhile (nPrime < 64) {\n  if (isPrime(n)) {\n    if (nPrime < 8) {\n      H[nPrime] = getFractionalBits(n ** (1 / 2));\n    }\n\n    K[nPrime] = getFractionalBits(n ** (1 / 3));\n    nPrime += 1;\n  }\n\n  n += 1;\n} // Reusable object\n\n\nconst W = [];\n/**\n * SHA-256 hash algorithm.\n */\n\nexport class SHA256Algo extends Hasher {\n  _doReset() {\n    this._hash = new WordArray(H.slice(0));\n  }\n\n  _doProcessBlock(M, offset) {\n    // Shortcut\n    const _H = this._hash.words; // Working variables\n\n    let a = _H[0];\n    let b = _H[1];\n    let c = _H[2];\n    let d = _H[3];\n    let e = _H[4];\n    let f = _H[5];\n    let g = _H[6];\n    let h = _H[7]; // Computation\n\n    for (let i = 0; i < 64; i += 1) {\n      if (i < 16) {\n        W[i] = M[offset + i] | 0;\n      } else {\n        const gamma0x = W[i - 15];\n        const gamma0 = (gamma0x << 25 | gamma0x >>> 7) ^ (gamma0x << 14 | gamma0x >>> 18) ^ gamma0x >>> 3;\n        const gamma1x = W[i - 2];\n        const gamma1 = (gamma1x << 15 | gamma1x >>> 17) ^ (gamma1x << 13 | gamma1x >>> 19) ^ gamma1x >>> 10;\n        W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16];\n      }\n\n      const ch = e & f ^ ~e & g;\n      const maj = a & b ^ a & c ^ b & c;\n      const sigma0 = (a << 30 | a >>> 2) ^ (a << 19 | a >>> 13) ^ (a << 10 | a >>> 22);\n      const sigma1 = (e << 26 | e >>> 6) ^ (e << 21 | e >>> 11) ^ (e << 7 | e >>> 25);\n      const t1 = h + sigma1 + ch + K[i] + W[i];\n      const t2 = sigma0 + maj;\n      h = g;\n      g = f;\n      f = e;\n      e = d + t1 | 0;\n      d = c;\n      c = b;\n      b = a;\n      a = t1 + t2 | 0;\n    } // Intermediate hash value\n\n\n    _H[0] = _H[0] + a | 0;\n    _H[1] = _H[1] + b | 0;\n    _H[2] = _H[2] + c | 0;\n    _H[3] = _H[3] + d | 0;\n    _H[4] = _H[4] + e | 0;\n    _H[5] = _H[5] + f | 0;\n    _H[6] = _H[6] + g | 0;\n    _H[7] = _H[7] + h | 0;\n  }\n\n  _doFinalize() {\n    // Shortcuts\n    const data = this._data;\n    const dataWords = data.words;\n    const nBitsTotal = this._nDataBytes * 8;\n    const nBitsLeft = data.sigBytes * 8; // Add padding\n\n    dataWords[nBitsLeft >>> 5] |= 0x80 << 24 - nBitsLeft % 32;\n    dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);\n    dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = nBitsTotal;\n    data.sigBytes = dataWords.length * 4; // Hash final blocks\n\n    this._process(); // Return final computed hash\n\n\n    return this._hash;\n  }\n\n  clone() {\n    const clone = super.clone.call(this);\n    clone._hash = this._hash.clone();\n    return clone;\n  }\n\n}\n/**\n * Shortcut function to the hasher's object interface.\n *\n * @param {WordArray|string} message The message to hash.\n *\n * @return {WordArray} The hash.\n *\n * @static\n *\n * @example\n *\n *     var hash = CryptoJS.SHA256('message');\n *     var hash = CryptoJS.SHA256(wordArray);\n */\n\nexport const SHA256 = Hasher._createHelper(SHA256Algo);\n/**\n * Shortcut function to the HMAC's object interface.\n *\n * @param {WordArray|string} message The message to hash.\n * @param {WordArray|string} key The secret key.\n *\n * @return {WordArray} The HMAC.\n *\n * @static\n *\n * @example\n *\n *     var hmac = CryptoJS.HmacSHA256(message, key);\n */\n\nexport const HmacSHA256 = Hasher._createHmacHelper(SHA256Algo);","map":{"version":3,"sources":["/Users/chrisbuonocore/personal/hackathons/hackfs21/node_modules/crypto-es/lib/sha256.js"],"names":["WordArray","Hasher","H","K","isPrime","n","sqrtN","Math","sqrt","factor","getFractionalBits","nPrime","W","SHA256Algo","_doReset","_hash","slice","_doProcessBlock","M","offset","_H","words","a","b","c","d","e","f","g","h","i","gamma0x","gamma0","gamma1x","gamma1","ch","maj","sigma0","sigma1","t1","t2","_doFinalize","data","_data","dataWords","nBitsTotal","_nDataBytes","nBitsLeft","sigBytes","floor","length","_process","clone","call","SHA256","_createHelper","HmacSHA256","_createHmacHelper"],"mappings":"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","sourcesContent":["import {\n  WordArray,\n  Hasher,\n} from './core.js';\n\n// Initialization and round constants tables\nconst H = [];\nconst K = [];\n\n// Compute constants\nconst isPrime = (n) => {\n  const sqrtN = Math.sqrt(n);\n  for (let factor = 2; factor <= sqrtN; factor += 1) {\n    if (!(n % factor)) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\nconst getFractionalBits = n => ((n - (n | 0)) * 0x100000000) | 0;\n\nlet n = 2;\nlet nPrime = 0;\nwhile (nPrime < 64) {\n  if (isPrime(n)) {\n    if (nPrime < 8) {\n      H[nPrime] = getFractionalBits(n ** (1 / 2));\n    }\n    K[nPrime] = getFractionalBits(n ** (1 / 3));\n\n    nPrime += 1;\n  }\n\n  n += 1;\n}\n\n// Reusable object\nconst W = [];\n\n/**\n * SHA-256 hash algorithm.\n */\nexport class SHA256Algo extends Hasher {\n  _doReset() {\n    this._hash = new WordArray(H.slice(0));\n  }\n\n  _doProcessBlock(M, offset) {\n    // Shortcut\n    const _H = this._hash.words;\n\n    // Working variables\n    let a = _H[0];\n    let b = _H[1];\n    let c = _H[2];\n    let d = _H[3];\n    let e = _H[4];\n    let f = _H[5];\n    let g = _H[6];\n    let h = _H[7];\n\n    // Computation\n    for (let i = 0; i < 64; i += 1) {\n      if (i < 16) {\n        W[i] = M[offset + i] | 0;\n      } else {\n        const gamma0x = W[i - 15];\n        const gamma0 = ((gamma0x << 25) | (gamma0x >>> 7))\n          ^ ((gamma0x << 14) | (gamma0x >>> 18))\n          ^ (gamma0x >>> 3);\n\n        const gamma1x = W[i - 2];\n        const gamma1 = ((gamma1x << 15) | (gamma1x >>> 17))\n          ^ ((gamma1x << 13) | (gamma1x >>> 19))\n          ^ (gamma1x >>> 10);\n\n        W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16];\n      }\n\n      const ch = (e & f) ^ (~e & g);\n      const maj = (a & b) ^ (a & c) ^ (b & c);\n\n      const sigma0 = ((a << 30) | (a >>> 2)) ^ ((a << 19) | (a >>> 13)) ^ ((a << 10) | (a >>> 22));\n      const sigma1 = ((e << 26) | (e >>> 6)) ^ ((e << 21) | (e >>> 11)) ^ ((e << 7) | (e >>> 25));\n\n      const t1 = h + sigma1 + ch + K[i] + W[i];\n      const t2 = sigma0 + maj;\n\n      h = g;\n      g = f;\n      f = e;\n      e = (d + t1) | 0;\n      d = c;\n      c = b;\n      b = a;\n      a = (t1 + t2) | 0;\n    }\n\n    // Intermediate hash value\n    _H[0] = (_H[0] + a) | 0;\n    _H[1] = (_H[1] + b) | 0;\n    _H[2] = (_H[2] + c) | 0;\n    _H[3] = (_H[3] + d) | 0;\n    _H[4] = (_H[4] + e) | 0;\n    _H[5] = (_H[5] + f) | 0;\n    _H[6] = (_H[6] + g) | 0;\n    _H[7] = (_H[7] + h) | 0;\n  }\n\n  _doFinalize() {\n    // Shortcuts\n    const data = this._data;\n    const dataWords = data.words;\n\n    const nBitsTotal = this._nDataBytes * 8;\n    const nBitsLeft = data.sigBytes * 8;\n\n    // Add padding\n    dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - (nBitsLeft % 32));\n    dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);\n    dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = nBitsTotal;\n    data.sigBytes = dataWords.length * 4;\n\n    // Hash final blocks\n    this._process();\n\n    // Return final computed hash\n    return this._hash;\n  }\n\n  clone() {\n    const clone = super.clone.call(this);\n    clone._hash = this._hash.clone();\n\n    return clone;\n  }\n}\n\n/**\n * Shortcut function to the hasher's object interface.\n *\n * @param {WordArray|string} message The message to hash.\n *\n * @return {WordArray} The hash.\n *\n * @static\n *\n * @example\n *\n *     var hash = CryptoJS.SHA256('message');\n *     var hash = CryptoJS.SHA256(wordArray);\n */\nexport const SHA256 = Hasher._createHelper(SHA256Algo);\n\n/**\n * Shortcut function to the HMAC's object interface.\n *\n * @param {WordArray|string} message The message to hash.\n * @param {WordArray|string} key The secret key.\n *\n * @return {WordArray} The HMAC.\n *\n * @static\n *\n * @example\n *\n *     var hmac = CryptoJS.HmacSHA256(message, key);\n */\nexport const HmacSHA256 = Hasher._createHmacHelper(SHA256Algo);\n"]},"metadata":{},"sourceType":"module"}