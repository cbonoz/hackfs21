{"ast":null,"code":"//      Copyright (c) 2012 Mathieu Turcotte\n//      Licensed under the MIT license.\nvar events = require('events');\n\nvar precond = require('precond');\n\nvar util = require('util');\n\nvar Backoff = require('./backoff');\n\nvar FibonacciBackoffStrategy = require('./strategy/fibonacci'); // Wraps a function to be called in a backoff loop.\n\n\nfunction FunctionCall(fn, args, callback) {\n  events.EventEmitter.call(this);\n  precond.checkIsFunction(fn, 'Expected fn to be a function.');\n  precond.checkIsArray(args, 'Expected args to be an array.');\n  precond.checkIsFunction(callback, 'Expected callback to be a function.');\n  this.function_ = fn;\n  this.arguments_ = args;\n  this.callback_ = callback;\n  this.lastResult_ = [];\n  this.numRetries_ = 0;\n  this.backoff_ = null;\n  this.strategy_ = null;\n  this.failAfter_ = -1;\n  this.retryPredicate_ = FunctionCall.DEFAULT_RETRY_PREDICATE_;\n  this.state_ = FunctionCall.State_.PENDING;\n}\n\nutil.inherits(FunctionCall, events.EventEmitter); // States in which the call can be.\n\nFunctionCall.State_ = {\n  // Call isn't started yet.\n  PENDING: 0,\n  // Call is in progress.\n  RUNNING: 1,\n  // Call completed successfully which means that either the wrapped function\n  // returned successfully or the maximal number of backoffs was reached.\n  COMPLETED: 2,\n  // The call was aborted.\n  ABORTED: 3\n}; // The default retry predicate which considers any error as retriable.\n\nFunctionCall.DEFAULT_RETRY_PREDICATE_ = function (err) {\n  return true;\n}; // Checks whether the call is pending.\n\n\nFunctionCall.prototype.isPending = function () {\n  return this.state_ == FunctionCall.State_.PENDING;\n}; // Checks whether the call is in progress.\n\n\nFunctionCall.prototype.isRunning = function () {\n  return this.state_ == FunctionCall.State_.RUNNING;\n}; // Checks whether the call is completed.\n\n\nFunctionCall.prototype.isCompleted = function () {\n  return this.state_ == FunctionCall.State_.COMPLETED;\n}; // Checks whether the call is aborted.\n\n\nFunctionCall.prototype.isAborted = function () {\n  return this.state_ == FunctionCall.State_.ABORTED;\n}; // Sets the backoff strategy to use. Can only be called before the call is\n// started otherwise an exception will be thrown.\n\n\nFunctionCall.prototype.setStrategy = function (strategy) {\n  precond.checkState(this.isPending(), 'FunctionCall in progress.');\n  this.strategy_ = strategy;\n  return this; // Return this for chaining.\n}; // Sets the predicate which will be used to determine whether the errors\n// returned from the wrapped function should be retried or not, e.g. a\n// network error would be retriable while a type error would stop the\n// function call.\n\n\nFunctionCall.prototype.retryIf = function (retryPredicate) {\n  precond.checkState(this.isPending(), 'FunctionCall in progress.');\n  this.retryPredicate_ = retryPredicate;\n  return this;\n}; // Returns all intermediary results returned by the wrapped function since\n// the initial call.\n\n\nFunctionCall.prototype.getLastResult = function () {\n  return this.lastResult_.concat();\n}; // Returns the number of times the wrapped function call was retried.\n\n\nFunctionCall.prototype.getNumRetries = function () {\n  return this.numRetries_;\n}; // Sets the backoff limit.\n\n\nFunctionCall.prototype.failAfter = function (maxNumberOfRetry) {\n  precond.checkState(this.isPending(), 'FunctionCall in progress.');\n  this.failAfter_ = maxNumberOfRetry;\n  return this; // Return this for chaining.\n}; // Aborts the call.\n\n\nFunctionCall.prototype.abort = function () {\n  if (this.isCompleted() || this.isAborted()) {\n    return;\n  }\n\n  if (this.isRunning()) {\n    this.backoff_.reset();\n  }\n\n  this.state_ = FunctionCall.State_.ABORTED;\n  this.lastResult_ = [new Error('Backoff aborted.')];\n  this.emit('abort');\n  this.doCallback_();\n}; // Initiates the call to the wrapped function. Accepts an optional factory\n// function used to create the backoff instance; used when testing.\n\n\nFunctionCall.prototype.start = function (backoffFactory) {\n  precond.checkState(!this.isAborted(), 'FunctionCall is aborted.');\n  precond.checkState(this.isPending(), 'FunctionCall already started.');\n  var strategy = this.strategy_ || new FibonacciBackoffStrategy();\n  this.backoff_ = backoffFactory ? backoffFactory(strategy) : new Backoff(strategy);\n  this.backoff_.on('ready', this.doCall_.bind(this, true\n  /* isRetry */\n  ));\n  this.backoff_.on('fail', this.doCallback_.bind(this));\n  this.backoff_.on('backoff', this.handleBackoff_.bind(this));\n\n  if (this.failAfter_ > 0) {\n    this.backoff_.failAfter(this.failAfter_);\n  }\n\n  this.state_ = FunctionCall.State_.RUNNING;\n  this.doCall_(false\n  /* isRetry */\n  );\n}; // Calls the wrapped function.\n\n\nFunctionCall.prototype.doCall_ = function (isRetry) {\n  if (isRetry) {\n    this.numRetries_++;\n  }\n\n  var eventArgs = ['call'].concat(this.arguments_);\n  events.EventEmitter.prototype.emit.apply(this, eventArgs);\n  var callback = this.handleFunctionCallback_.bind(this);\n  this.function_.apply(null, this.arguments_.concat(callback));\n}; // Calls the wrapped function's callback with the last result returned by the\n// wrapped function.\n\n\nFunctionCall.prototype.doCallback_ = function () {\n  this.callback_.apply(null, this.lastResult_);\n}; // Handles wrapped function's completion. This method acts as a replacement\n// for the original callback function.\n\n\nFunctionCall.prototype.handleFunctionCallback_ = function () {\n  if (this.isAborted()) {\n    return;\n  }\n\n  var args = Array.prototype.slice.call(arguments);\n  this.lastResult_ = args; // Save last callback arguments.\n\n  events.EventEmitter.prototype.emit.apply(this, ['callback'].concat(args));\n  var err = args[0];\n\n  if (err && this.retryPredicate_(err)) {\n    this.backoff_.backoff(err);\n  } else {\n    this.state_ = FunctionCall.State_.COMPLETED;\n    this.doCallback_();\n  }\n}; // Handles the backoff event by reemitting it.\n\n\nFunctionCall.prototype.handleBackoff_ = function (number, delay, err) {\n  this.emit('backoff', number, delay, err);\n};\n\nmodule.exports = FunctionCall;","map":{"version":3,"sources":["/Users/chrisbuonocore/personal/hackathons/hackfs21/node_modules/backoff/lib/function_call.js"],"names":["events","require","precond","util","Backoff","FibonacciBackoffStrategy","FunctionCall","fn","args","callback","EventEmitter","call","checkIsFunction","checkIsArray","function_","arguments_","callback_","lastResult_","numRetries_","backoff_","strategy_","failAfter_","retryPredicate_","DEFAULT_RETRY_PREDICATE_","state_","State_","PENDING","inherits","RUNNING","COMPLETED","ABORTED","err","prototype","isPending","isRunning","isCompleted","isAborted","setStrategy","strategy","checkState","retryIf","retryPredicate","getLastResult","concat","getNumRetries","failAfter","maxNumberOfRetry","abort","reset","Error","emit","doCallback_","start","backoffFactory","on","doCall_","bind","handleBackoff_","isRetry","eventArgs","apply","handleFunctionCallback_","Array","slice","arguments","backoff","number","delay","module","exports"],"mappings":"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","sourcesContent":["//      Copyright (c) 2012 Mathieu Turcotte\n//      Licensed under the MIT license.\n\nvar events = require('events');\nvar precond = require('precond');\nvar util = require('util');\n\nvar Backoff = require('./backoff');\nvar FibonacciBackoffStrategy = require('./strategy/fibonacci');\n\n// Wraps a function to be called in a backoff loop.\nfunction FunctionCall(fn, args, callback) {\n    events.EventEmitter.call(this);\n\n    precond.checkIsFunction(fn, 'Expected fn to be a function.');\n    precond.checkIsArray(args, 'Expected args to be an array.');\n    precond.checkIsFunction(callback, 'Expected callback to be a function.');\n\n    this.function_ = fn;\n    this.arguments_ = args;\n    this.callback_ = callback;\n    this.lastResult_ = [];\n    this.numRetries_ = 0;\n\n    this.backoff_ = null;\n    this.strategy_ = null;\n    this.failAfter_ = -1;\n    this.retryPredicate_ = FunctionCall.DEFAULT_RETRY_PREDICATE_;\n\n    this.state_ = FunctionCall.State_.PENDING;\n}\nutil.inherits(FunctionCall, events.EventEmitter);\n\n// States in which the call can be.\nFunctionCall.State_ = {\n    // Call isn't started yet.\n    PENDING: 0,\n    // Call is in progress.\n    RUNNING: 1,\n    // Call completed successfully which means that either the wrapped function\n    // returned successfully or the maximal number of backoffs was reached.\n    COMPLETED: 2,\n    // The call was aborted.\n    ABORTED: 3\n};\n\n// The default retry predicate which considers any error as retriable.\nFunctionCall.DEFAULT_RETRY_PREDICATE_ = function(err) {\n  return true;\n};\n\n// Checks whether the call is pending.\nFunctionCall.prototype.isPending = function() {\n    return this.state_ == FunctionCall.State_.PENDING;\n};\n\n// Checks whether the call is in progress.\nFunctionCall.prototype.isRunning = function() {\n    return this.state_ == FunctionCall.State_.RUNNING;\n};\n\n// Checks whether the call is completed.\nFunctionCall.prototype.isCompleted = function() {\n    return this.state_ == FunctionCall.State_.COMPLETED;\n};\n\n// Checks whether the call is aborted.\nFunctionCall.prototype.isAborted = function() {\n    return this.state_ == FunctionCall.State_.ABORTED;\n};\n\n// Sets the backoff strategy to use. Can only be called before the call is\n// started otherwise an exception will be thrown.\nFunctionCall.prototype.setStrategy = function(strategy) {\n    precond.checkState(this.isPending(), 'FunctionCall in progress.');\n    this.strategy_ = strategy;\n    return this; // Return this for chaining.\n};\n\n// Sets the predicate which will be used to determine whether the errors\n// returned from the wrapped function should be retried or not, e.g. a\n// network error would be retriable while a type error would stop the\n// function call.\nFunctionCall.prototype.retryIf = function(retryPredicate) {\n    precond.checkState(this.isPending(), 'FunctionCall in progress.');\n    this.retryPredicate_ = retryPredicate;\n    return this;\n};\n\n// Returns all intermediary results returned by the wrapped function since\n// the initial call.\nFunctionCall.prototype.getLastResult = function() {\n    return this.lastResult_.concat();\n};\n\n// Returns the number of times the wrapped function call was retried.\nFunctionCall.prototype.getNumRetries = function() {\n    return this.numRetries_;\n};\n\n// Sets the backoff limit.\nFunctionCall.prototype.failAfter = function(maxNumberOfRetry) {\n    precond.checkState(this.isPending(), 'FunctionCall in progress.');\n    this.failAfter_ = maxNumberOfRetry;\n    return this; // Return this for chaining.\n};\n\n// Aborts the call.\nFunctionCall.prototype.abort = function() {\n    if (this.isCompleted() || this.isAborted()) {\n      return;\n    }\n\n    if (this.isRunning()) {\n        this.backoff_.reset();\n    }\n\n    this.state_ = FunctionCall.State_.ABORTED;\n    this.lastResult_ = [new Error('Backoff aborted.')];\n    this.emit('abort');\n    this.doCallback_();\n};\n\n// Initiates the call to the wrapped function. Accepts an optional factory\n// function used to create the backoff instance; used when testing.\nFunctionCall.prototype.start = function(backoffFactory) {\n    precond.checkState(!this.isAborted(), 'FunctionCall is aborted.');\n    precond.checkState(this.isPending(), 'FunctionCall already started.');\n\n    var strategy = this.strategy_ || new FibonacciBackoffStrategy();\n\n    this.backoff_ = backoffFactory ?\n        backoffFactory(strategy) :\n        new Backoff(strategy);\n\n    this.backoff_.on('ready', this.doCall_.bind(this, true /* isRetry */));\n    this.backoff_.on('fail', this.doCallback_.bind(this));\n    this.backoff_.on('backoff', this.handleBackoff_.bind(this));\n\n    if (this.failAfter_ > 0) {\n        this.backoff_.failAfter(this.failAfter_);\n    }\n\n    this.state_ = FunctionCall.State_.RUNNING;\n    this.doCall_(false /* isRetry */);\n};\n\n// Calls the wrapped function.\nFunctionCall.prototype.doCall_ = function(isRetry) {\n    if (isRetry) {\n        this.numRetries_++;\n    }\n    var eventArgs = ['call'].concat(this.arguments_);\n    events.EventEmitter.prototype.emit.apply(this, eventArgs);\n    var callback = this.handleFunctionCallback_.bind(this);\n    this.function_.apply(null, this.arguments_.concat(callback));\n};\n\n// Calls the wrapped function's callback with the last result returned by the\n// wrapped function.\nFunctionCall.prototype.doCallback_ = function() {\n    this.callback_.apply(null, this.lastResult_);\n};\n\n// Handles wrapped function's completion. This method acts as a replacement\n// for the original callback function.\nFunctionCall.prototype.handleFunctionCallback_ = function() {\n    if (this.isAborted()) {\n        return;\n    }\n\n    var args = Array.prototype.slice.call(arguments);\n    this.lastResult_ = args; // Save last callback arguments.\n    events.EventEmitter.prototype.emit.apply(this, ['callback'].concat(args));\n\n    var err = args[0];\n    if (err && this.retryPredicate_(err)) {\n        this.backoff_.backoff(err);\n    } else {\n        this.state_ = FunctionCall.State_.COMPLETED;\n        this.doCallback_();\n    }\n};\n\n// Handles the backoff event by reemitting it.\nFunctionCall.prototype.handleBackoff_ = function(number, delay, err) {\n    this.emit('backoff', number, delay, err);\n};\n\nmodule.exports = FunctionCall;\n"]},"metadata":{},"sourceType":"script"}