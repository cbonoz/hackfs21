{"ast":null,"code":"/* eslint-disable no-use-before-define */\nimport { Base, WordArray, BufferedBlockAlgorithm } from './core.js';\nimport { Base64 } from './enc-base64.js';\nimport { EvpKDFAlgo } from './evpkdf.js';\n/**\n * Abstract base cipher template.\n *\n * @property {number} keySize This cipher's key size. Default: 4 (128 bits)\n * @property {number} ivSize This cipher's IV size. Default: 4 (128 bits)\n * @property {number} _ENC_XFORM_MODE A constant representing encryption mode.\n * @property {number} _DEC_XFORM_MODE A constant representing decryption mode.\n */\n\nexport class Cipher extends BufferedBlockAlgorithm {\n  /**\n   * Initializes a newly created cipher.\n   *\n   * @param {number} xformMode Either the encryption or decryption transormation mode constant.\n   * @param {WordArray} key The key.\n   * @param {Object} cfg (Optional) The configuration options to use for this operation.\n   *\n   * @example\n   *\n   *     const cipher = CryptoJS.algo.AES.create(\n   *       CryptoJS.algo.AES._ENC_XFORM_MODE, keyWordArray, { iv: ivWordArray }\n   *     );\n   */\n  constructor(xformMode, key, cfg) {\n    super();\n    /**\n     * Configuration options.\n     *\n     * @property {WordArray} iv The IV to use for this operation.\n     */\n\n    this.cfg = Object.assign(new Base(), cfg); // Store transform mode and key\n\n    this._xformMode = xformMode;\n    this._key = key; // Set initial values\n\n    this.reset();\n  }\n  /**\n   * Creates this cipher in encryption mode.\n   *\n   * @param {WordArray} key The key.\n   * @param {Object} cfg (Optional) The configuration options to use for this operation.\n   *\n   * @return {Cipher} A cipher instance.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     const cipher = CryptoJS.algo.AES.createEncryptor(keyWordArray, { iv: ivWordArray });\n   */\n\n\n  static createEncryptor(key, cfg) {\n    return this.create(this._ENC_XFORM_MODE, key, cfg);\n  }\n  /**\n   * Creates this cipher in decryption mode.\n   *\n   * @param {WordArray} key The key.\n   * @param {Object} cfg (Optional) The configuration options to use for this operation.\n   *\n   * @return {Cipher} A cipher instance.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     const cipher = CryptoJS.algo.AES.createDecryptor(keyWordArray, { iv: ivWordArray });\n   */\n\n\n  static createDecryptor(key, cfg) {\n    return this.create(this._DEC_XFORM_MODE, key, cfg);\n  }\n  /**\n   * Creates shortcut functions to a cipher's object interface.\n   *\n   * @param {Cipher} cipher The cipher to create a helper for.\n   *\n   * @return {Object} An object with encrypt and decrypt shortcut functions.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     const AES = CryptoJS.lib.Cipher._createHelper(CryptoJS.algo.AES);\n   */\n\n\n  static _createHelper(SubCipher) {\n    const selectCipherStrategy = key => {\n      if (typeof key === 'string') {\n        return PasswordBasedCipher;\n      }\n\n      return SerializableCipher;\n    };\n\n    return {\n      encrypt(message, key, cfg) {\n        return selectCipherStrategy(key).encrypt(SubCipher, message, key, cfg);\n      },\n\n      decrypt(ciphertext, key, cfg) {\n        return selectCipherStrategy(key).decrypt(SubCipher, ciphertext, key, cfg);\n      }\n\n    };\n  }\n  /**\n   * Resets this cipher to its initial state.\n   *\n   * @example\n   *\n   *     cipher.reset();\n   */\n\n\n  reset() {\n    // Reset data buffer\n    super.reset.call(this); // Perform concrete-cipher logic\n\n    this._doReset();\n  }\n  /**\n   * Adds data to be encrypted or decrypted.\n   *\n   * @param {WordArray|string} dataUpdate The data to encrypt or decrypt.\n   *\n   * @return {WordArray} The data after processing.\n   *\n   * @example\n   *\n   *     const encrypted = cipher.process('data');\n   *     const encrypted = cipher.process(wordArray);\n   */\n\n\n  process(dataUpdate) {\n    // Append\n    this._append(dataUpdate); // Process available blocks\n\n\n    return this._process();\n  }\n  /**\n   * Finalizes the encryption or decryption process.\n   * Note that the finalize operation is effectively a destructive, read-once operation.\n   *\n   * @param {WordArray|string} dataUpdate The final data to encrypt or decrypt.\n   *\n   * @return {WordArray} The data after final processing.\n   *\n   * @example\n   *\n   *     const encrypted = cipher.finalize();\n   *     const encrypted = cipher.finalize('data');\n   *     const encrypted = cipher.finalize(wordArray);\n   */\n\n\n  finalize(dataUpdate) {\n    // Final data update\n    if (dataUpdate) {\n      this._append(dataUpdate);\n    } // Perform concrete-cipher logic\n\n\n    const finalProcessedData = this._doFinalize();\n\n    return finalProcessedData;\n  }\n\n}\nCipher._ENC_XFORM_MODE = 1;\nCipher._DEC_XFORM_MODE = 2;\nCipher.keySize = 128 / 32;\nCipher.ivSize = 128 / 32;\n/**\n * Abstract base stream cipher template.\n *\n * @property {number} blockSize\n *\n *     The number of 32-bit words this cipher operates on. Default: 1 (32 bits)\n */\n\nexport class StreamCipher extends Cipher {\n  constructor(...args) {\n    super(...args);\n    this.blockSize = 1;\n  }\n\n  _doFinalize() {\n    // Process partial blocks\n    const finalProcessedBlocks = this._process(!!'flush');\n\n    return finalProcessedBlocks;\n  }\n\n}\n/**\n * Abstract base block cipher mode template.\n */\n\nexport class BlockCipherMode extends Base {\n  /**\n   * Initializes a newly created mode.\n   *\n   * @param {Cipher} cipher A block cipher instance.\n   * @param {Array} iv The IV words.\n   *\n   * @example\n   *\n   *     const mode = CryptoJS.mode.CBC.Encryptor.create(cipher, iv.words);\n   */\n  constructor(cipher, iv) {\n    super();\n    this._cipher = cipher;\n    this._iv = iv;\n  }\n  /**\n   * Creates this mode for encryption.\n   *\n   * @param {Cipher} cipher A block cipher instance.\n   * @param {Array} iv The IV words.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     const mode = CryptoJS.mode.CBC.createEncryptor(cipher, iv.words);\n   */\n\n\n  static createEncryptor(cipher, iv) {\n    return this.Encryptor.create(cipher, iv);\n  }\n  /**\n   * Creates this mode for decryption.\n   *\n   * @param {Cipher} cipher A block cipher instance.\n   * @param {Array} iv The IV words.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     const mode = CryptoJS.mode.CBC.createDecryptor(cipher, iv.words);\n   */\n\n\n  static createDecryptor(cipher, iv) {\n    return this.Decryptor.create(cipher, iv);\n  }\n\n}\n\nfunction xorBlock(words, offset, blockSize) {\n  const _words = words;\n  let block; // Shortcut\n\n  const iv = this._iv; // Choose mixing block\n\n  if (iv) {\n    block = iv; // Remove IV for subsequent blocks\n\n    this._iv = undefined;\n  } else {\n    block = this._prevBlock;\n  } // XOR blocks\n\n\n  for (let i = 0; i < blockSize; i += 1) {\n    _words[offset + i] ^= block[i];\n  }\n}\n/**\n * Cipher Block Chaining mode.\n */\n\n/**\n * Abstract base CBC mode.\n */\n\n\nexport class CBC extends BlockCipherMode {}\n/**\n * CBC encryptor.\n */\n\nCBC.Encryptor = class extends CBC {\n  /**\n   * Processes the data block at offset.\n   *\n   * @param {Array} words The data words to operate on.\n   * @param {number} offset The offset where the block starts.\n   *\n   * @example\n   *\n   *     mode.processBlock(data.words, offset);\n   */\n  processBlock(words, offset) {\n    // Shortcuts\n    const cipher = this._cipher;\n    const {\n      blockSize\n    } = cipher; // XOR and encrypt\n\n    xorBlock.call(this, words, offset, blockSize);\n    cipher.encryptBlock(words, offset); // Remember this block to use with next block\n\n    this._prevBlock = words.slice(offset, offset + blockSize);\n  }\n\n};\n/**\n * CBC decryptor.\n */\n\nCBC.Decryptor = class extends CBC {\n  /**\n   * Processes the data block at offset.\n   *\n   * @param {Array} words The data words to operate on.\n   * @param {number} offset The offset where the block starts.\n   *\n   * @example\n   *\n   *     mode.processBlock(data.words, offset);\n   */\n  processBlock(words, offset) {\n    // Shortcuts\n    const cipher = this._cipher;\n    const {\n      blockSize\n    } = cipher; // Remember this block to use with next block\n\n    const thisBlock = words.slice(offset, offset + blockSize); // Decrypt and XOR\n\n    cipher.decryptBlock(words, offset);\n    xorBlock.call(this, words, offset, blockSize); // This block becomes the previous block\n\n    this._prevBlock = thisBlock;\n  }\n\n};\n/**\n * PKCS #5/7 padding strategy.\n */\n\nexport const Pkcs7 = {\n  /**\n   * Pads data using the algorithm defined in PKCS #5/7.\n   *\n   * @param {WordArray} data The data to pad.\n   * @param {number} blockSize The multiple that the data should be padded to.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     CryptoJS.pad.Pkcs7.pad(wordArray, 4);\n   */\n  pad(data, blockSize) {\n    // Shortcut\n    const blockSizeBytes = blockSize * 4; // Count padding bytes\n\n    const nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes; // Create padding word\n\n    const paddingWord = nPaddingBytes << 24 | nPaddingBytes << 16 | nPaddingBytes << 8 | nPaddingBytes; // Create padding\n\n    const paddingWords = [];\n\n    for (let i = 0; i < nPaddingBytes; i += 4) {\n      paddingWords.push(paddingWord);\n    }\n\n    const padding = WordArray.create(paddingWords, nPaddingBytes); // Add padding\n\n    data.concat(padding);\n  },\n\n  /**\n   * Unpads data that had been padded using the algorithm defined in PKCS #5/7.\n   *\n   * @param {WordArray} data The data to unpad.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     CryptoJS.pad.Pkcs7.unpad(wordArray);\n   */\n  unpad(data) {\n    const _data = data; // Get number of padding bytes from last byte\n\n    const nPaddingBytes = _data.words[_data.sigBytes - 1 >>> 2] & 0xff; // Remove padding\n\n    _data.sigBytes -= nPaddingBytes;\n  }\n\n};\n/**\n * Abstract base block cipher template.\n *\n * @property {number} blockSize\n *\n *    The number of 32-bit words this cipher operates on. Default: 4 (128 bits)\n */\n\nexport class BlockCipher extends Cipher {\n  constructor(xformMode, key, cfg) {\n    /**\n     * Configuration options.\n     *\n     * @property {Mode} mode The block mode to use. Default: CBC\n     * @property {Padding} padding The padding strategy to use. Default: Pkcs7\n     */\n    super(xformMode, key, Object.assign({\n      mode: CBC,\n      padding: Pkcs7\n    }, cfg));\n    this.blockSize = 128 / 32;\n  }\n\n  reset() {\n    let modeCreator; // Reset cipher\n\n    super.reset.call(this); // Shortcuts\n\n    const {\n      cfg\n    } = this;\n    const {\n      iv,\n      mode\n    } = cfg; // Reset block mode\n\n    if (this._xformMode === this.constructor._ENC_XFORM_MODE) {\n      modeCreator = mode.createEncryptor;\n    } else\n      /* if (this._xformMode == this._DEC_XFORM_MODE) */\n      {\n        modeCreator = mode.createDecryptor; // Keep at least one block in the buffer for unpadding\n\n        this._minBufferSize = 1;\n      }\n\n    this._mode = modeCreator.call(mode, this, iv && iv.words);\n    this._mode.__creator = modeCreator;\n  }\n\n  _doProcessBlock(words, offset) {\n    this._mode.processBlock(words, offset);\n  }\n\n  _doFinalize() {\n    let finalProcessedBlocks; // Shortcut\n\n    const {\n      padding\n    } = this.cfg; // Finalize\n\n    if (this._xformMode === this.constructor._ENC_XFORM_MODE) {\n      // Pad data\n      padding.pad(this._data, this.blockSize); // Process final blocks\n\n      finalProcessedBlocks = this._process(!!'flush');\n    } else\n      /* if (this._xformMode == this._DEC_XFORM_MODE) */\n      {\n        // Process final blocks\n        finalProcessedBlocks = this._process(!!'flush'); // Unpad data\n\n        padding.unpad(finalProcessedBlocks);\n      }\n\n    return finalProcessedBlocks;\n  }\n\n}\n/**\n * A collection of cipher parameters.\n *\n * @property {WordArray} ciphertext The raw ciphertext.\n * @property {WordArray} key The key to this ciphertext.\n * @property {WordArray} iv The IV used in the ciphering operation.\n * @property {WordArray} salt The salt used with a key derivation function.\n * @property {Cipher} algorithm The cipher algorithm.\n * @property {Mode} mode The block mode used in the ciphering operation.\n * @property {Padding} padding The padding scheme used in the ciphering operation.\n * @property {number} blockSize The block size of the cipher.\n * @property {Format} formatter\n *    The default formatting strategy to convert this cipher params object to a string.\n */\n\nexport class CipherParams extends Base {\n  /**\n   * Initializes a newly created cipher params object.\n   *\n   * @param {Object} cipherParams An object with any of the possible cipher parameters.\n   *\n   * @example\n   *\n   *     var cipherParams = CryptoJS.lib.CipherParams.create({\n   *         ciphertext: ciphertextWordArray,\n   *         key: keyWordArray,\n   *         iv: ivWordArray,\n   *         salt: saltWordArray,\n   *         algorithm: CryptoJS.algo.AES,\n   *         mode: CryptoJS.mode.CBC,\n   *         padding: CryptoJS.pad.PKCS7,\n   *         blockSize: 4,\n   *         formatter: CryptoJS.format.OpenSSL\n   *     });\n   */\n  constructor(cipherParams) {\n    super();\n    this.mixIn(cipherParams);\n  }\n  /**\n   * Converts this cipher params object to a string.\n   *\n   * @param {Format} formatter (Optional) The formatting strategy to use.\n   *\n   * @return {string} The stringified cipher params.\n   *\n   * @throws Error If neither the formatter nor the default formatter is set.\n   *\n   * @example\n   *\n   *     var string = cipherParams + '';\n   *     var string = cipherParams.toString();\n   *     var string = cipherParams.toString(CryptoJS.format.OpenSSL);\n   */\n\n\n  toString(formatter) {\n    return (formatter || this.formatter).stringify(this);\n  }\n\n}\n/**\n * OpenSSL formatting strategy.\n */\n\nexport const OpenSSLFormatter = {\n  /**\n   * Converts a cipher params object to an OpenSSL-compatible string.\n   *\n   * @param {CipherParams} cipherParams The cipher params object.\n   *\n   * @return {string} The OpenSSL-compatible string.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var openSSLString = CryptoJS.format.OpenSSL.stringify(cipherParams);\n   */\n  stringify(cipherParams) {\n    let wordArray; // Shortcuts\n\n    const {\n      ciphertext,\n      salt\n    } = cipherParams; // Format\n\n    if (salt) {\n      wordArray = WordArray.create([0x53616c74, 0x65645f5f]).concat(salt).concat(ciphertext);\n    } else {\n      wordArray = ciphertext;\n    }\n\n    return wordArray.toString(Base64);\n  },\n\n  /**\n   * Converts an OpenSSL-compatible string to a cipher params object.\n   *\n   * @param {string} openSSLStr The OpenSSL-compatible string.\n   *\n   * @return {CipherParams} The cipher params object.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var cipherParams = CryptoJS.format.OpenSSL.parse(openSSLString);\n   */\n  parse(openSSLStr) {\n    let salt; // Parse base64\n\n    const ciphertext = Base64.parse(openSSLStr); // Shortcut\n\n    const ciphertextWords = ciphertext.words; // Test for salt\n\n    if (ciphertextWords[0] === 0x53616c74 && ciphertextWords[1] === 0x65645f5f) {\n      // Extract salt\n      salt = WordArray.create(ciphertextWords.slice(2, 4)); // Remove salt from ciphertext\n\n      ciphertextWords.splice(0, 4);\n      ciphertext.sigBytes -= 16;\n    }\n\n    return CipherParams.create({\n      ciphertext,\n      salt\n    });\n  }\n\n};\n/**\n * A cipher wrapper that returns ciphertext as a serializable cipher params object.\n */\n\nexport class SerializableCipher extends Base {\n  /**\n   * Encrypts a message.\n   *\n   * @param {Cipher} cipher The cipher algorithm to use.\n   * @param {WordArray|string} message The message to encrypt.\n   * @param {WordArray} key The key.\n   * @param {Object} cfg (Optional) The configuration options to use for this operation.\n   *\n   * @return {CipherParams} A cipher params object.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var ciphertextParams = CryptoJS.lib.SerializableCipher\n   *       .encrypt(CryptoJS.algo.AES, message, key);\n   *     var ciphertextParams = CryptoJS.lib.SerializableCipher\n   *       .encrypt(CryptoJS.algo.AES, message, key, { iv: iv });\n   *     var ciphertextParams = CryptoJS.lib.SerializableCipher\n   *       .encrypt(CryptoJS.algo.AES, message, key, { iv: iv, format: CryptoJS.format.OpenSSL });\n   */\n  static encrypt(cipher, message, key, cfg) {\n    // Apply config defaults\n    const _cfg = Object.assign(new Base(), this.cfg, cfg); // Encrypt\n\n\n    const encryptor = cipher.createEncryptor(key, _cfg);\n    const ciphertext = encryptor.finalize(message); // Shortcut\n\n    const cipherCfg = encryptor.cfg; // Create and return serializable cipher params\n\n    return CipherParams.create({\n      ciphertext,\n      key,\n      iv: cipherCfg.iv,\n      algorithm: cipher,\n      mode: cipherCfg.mode,\n      padding: cipherCfg.padding,\n      blockSize: encryptor.blockSize,\n      formatter: _cfg.format\n    });\n  }\n  /**\n   * Decrypts serialized ciphertext.\n   *\n   * @param {Cipher} cipher The cipher algorithm to use.\n   * @param {CipherParams|string} ciphertext The ciphertext to decrypt.\n   * @param {WordArray} key The key.\n   * @param {Object} cfg (Optional) The configuration options to use for this operation.\n   *\n   * @return {WordArray} The plaintext.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var plaintext = CryptoJS.lib.SerializableCipher\n   *       .decrypt(CryptoJS.algo.AES, formattedCiphertext, key,\n   *         { iv: iv, format: CryptoJS.format.OpenSSL });\n   *     var plaintext = CryptoJS.lib.SerializableCipher\n   *       .decrypt(CryptoJS.algo.AES, ciphertextParams, key,\n   *         { iv: iv, format: CryptoJS.format.OpenSSL });\n   */\n\n\n  static decrypt(cipher, ciphertext, key, cfg) {\n    let _ciphertext = ciphertext; // Apply config defaults\n\n    const _cfg = Object.assign(new Base(), this.cfg, cfg); // Convert string to CipherParams\n\n\n    _ciphertext = this._parse(_ciphertext, _cfg.format); // Decrypt\n\n    const plaintext = cipher.createDecryptor(key, _cfg).finalize(_ciphertext.ciphertext);\n    return plaintext;\n  }\n  /**\n   * Converts serialized ciphertext to CipherParams,\n   * else assumed CipherParams already and returns ciphertext unchanged.\n   *\n   * @param {CipherParams|string} ciphertext The ciphertext.\n   * @param {Formatter} format The formatting strategy to use to parse serialized ciphertext.\n   *\n   * @return {CipherParams} The unserialized ciphertext.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var ciphertextParams = CryptoJS.lib.SerializableCipher\n   *       ._parse(ciphertextStringOrParams, format);\n   */\n\n\n  static _parse(ciphertext, format) {\n    if (typeof ciphertext === 'string') {\n      return format.parse(ciphertext, this);\n    }\n\n    return ciphertext;\n  }\n\n}\n/**\n * Configuration options.\n *\n * @property {Formatter} format\n *\n *    The formatting strategy to convert cipher param objects to and from a string.\n *    Default: OpenSSL\n */\n\nSerializableCipher.cfg = Object.assign(new Base(), {\n  format: OpenSSLFormatter\n});\n/**\n * OpenSSL key derivation function.\n */\n\nexport const OpenSSLKdf = {\n  /**\n   * Derives a key and IV from a password.\n   *\n   * @param {string} password The password to derive from.\n   * @param {number} keySize The size in words of the key to generate.\n   * @param {number} ivSize The size in words of the IV to generate.\n   * @param {WordArray|string} salt\n   *     (Optional) A 64-bit salt to use. If omitted, a salt will be generated randomly.\n   *\n   * @return {CipherParams} A cipher params object with the key, IV, and salt.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32);\n   *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32, 'saltsalt');\n   */\n  execute(password, keySize, ivSize, salt) {\n    let _salt = salt; // Generate random salt\n\n    if (!_salt) {\n      _salt = WordArray.random(64 / 8);\n    } // Derive key and IV\n\n\n    const key = EvpKDFAlgo.create({\n      keySize: keySize + ivSize\n    }).compute(password, _salt); // Separate key and IV\n\n    const iv = WordArray.create(key.words.slice(keySize), ivSize * 4);\n    key.sigBytes = keySize * 4; // Return params\n\n    return CipherParams.create({\n      key,\n      iv,\n      salt: _salt\n    });\n  }\n\n};\n/**\n * A serializable cipher wrapper that derives the key from a password,\n * and returns ciphertext as a serializable cipher params object.\n */\n\nexport class PasswordBasedCipher extends SerializableCipher {\n  /**\n   * Encrypts a message using a password.\n   *\n   * @param {Cipher} cipher The cipher algorithm to use.\n   * @param {WordArray|string} message The message to encrypt.\n   * @param {string} password The password.\n   * @param {Object} cfg (Optional) The configuration options to use for this operation.\n   *\n   * @return {CipherParams} A cipher params object.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher\n   *       .encrypt(CryptoJS.algo.AES, message, 'password');\n   *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher\n   *       .encrypt(CryptoJS.algo.AES, message, 'password', { format: CryptoJS.format.OpenSSL });\n   */\n  static encrypt(cipher, message, password, cfg) {\n    // Apply config defaults\n    const _cfg = Object.assign(new Base(), this.cfg, cfg); // Derive key and other params\n\n\n    const derivedParams = _cfg.kdf.execute(password, cipher.keySize, cipher.ivSize); // Add IV to config\n\n\n    _cfg.iv = derivedParams.iv; // Encrypt\n\n    const ciphertext = SerializableCipher.encrypt.call(this, cipher, message, derivedParams.key, _cfg); // Mix in derived params\n\n    ciphertext.mixIn(derivedParams);\n    return ciphertext;\n  }\n  /**\n   * Decrypts serialized ciphertext using a password.\n   *\n   * @param {Cipher} cipher The cipher algorithm to use.\n   * @param {CipherParams|string} ciphertext The ciphertext to decrypt.\n   * @param {string} password The password.\n   * @param {Object} cfg (Optional) The configuration options to use for this operation.\n   *\n   * @return {WordArray} The plaintext.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var plaintext = CryptoJS.lib.PasswordBasedCipher\n   *       .decrypt(CryptoJS.algo.AES, formattedCiphertext, 'password',\n   *         { format: CryptoJS.format.OpenSSL });\n   *     var plaintext = CryptoJS.lib.PasswordBasedCipher\n   *       .decrypt(CryptoJS.algo.AES, ciphertextParams, 'password',\n   *         { format: CryptoJS.format.OpenSSL });\n   */\n\n\n  static decrypt(cipher, ciphertext, password, cfg) {\n    let _ciphertext = ciphertext; // Apply config defaults\n\n    const _cfg = Object.assign(new Base(), this.cfg, cfg); // Convert string to CipherParams\n\n\n    _ciphertext = this._parse(_ciphertext, _cfg.format); // Derive key and other params\n\n    const derivedParams = _cfg.kdf.execute(password, cipher.keySize, cipher.ivSize, _ciphertext.salt); // Add IV to config\n\n\n    _cfg.iv = derivedParams.iv; // Decrypt\n\n    const plaintext = SerializableCipher.decrypt.call(this, cipher, _ciphertext, derivedParams.key, _cfg);\n    return plaintext;\n  }\n\n}\n/**\n * Configuration options.\n *\n * @property {KDF} kdf\n *     The key derivation function to use to generate a key and IV from a password.\n *     Default: OpenSSL\n */\n\nPasswordBasedCipher.cfg = Object.assign(SerializableCipher.cfg, {\n  kdf: OpenSSLKdf\n});","map":{"version":3,"sources":["/Users/chrisbuonocore/personal/hackathons/hackfs21/node_modules/crypto-es/lib/cipher-core.js"],"names":["Base","WordArray","BufferedBlockAlgorithm","Base64","EvpKDFAlgo","Cipher","constructor","xformMode","key","cfg","Object","assign","_xformMode","_key","reset","createEncryptor","create","_ENC_XFORM_MODE","createDecryptor","_DEC_XFORM_MODE","_createHelper","SubCipher","selectCipherStrategy","PasswordBasedCipher","SerializableCipher","encrypt","message","decrypt","ciphertext","call","_doReset","process","dataUpdate","_append","_process","finalize","finalProcessedData","_doFinalize","keySize","ivSize","StreamCipher","args","blockSize","finalProcessedBlocks","BlockCipherMode","cipher","iv","_cipher","_iv","Encryptor","Decryptor","xorBlock","words","offset","_words","block","undefined","_prevBlock","i","CBC","processBlock","encryptBlock","slice","thisBlock","decryptBlock","Pkcs7","pad","data","blockSizeBytes","nPaddingBytes","sigBytes","paddingWord","paddingWords","push","padding","concat","unpad","_data","BlockCipher","mode","modeCreator","_minBufferSize","_mode","__creator","_doProcessBlock","CipherParams","cipherParams","mixIn","toString","formatter","stringify","OpenSSLFormatter","wordArray","salt","parse","openSSLStr","ciphertextWords","splice","_cfg","encryptor","cipherCfg","algorithm","format","_ciphertext","_parse","plaintext","OpenSSLKdf","execute","password","_salt","random","compute","derivedParams","kdf"],"mappings":"AAAA;AAEA,SACEA,IADF,EAEEC,SAFF,EAGEC,sBAHF,QAIO,WAJP;AAKA,SAASC,MAAT,QAAuB,iBAAvB;AACA,SAASC,UAAT,QAA2B,aAA3B;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,MAAMC,MAAN,SAAqBH,sBAArB,CAA4C;AACjD;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACEI,EAAAA,WAAW,CAACC,SAAD,EAAYC,GAAZ,EAAiBC,GAAjB,EAAsB;AAC/B;AAEA;AACJ;AACA;AACA;AACA;;AACI,SAAKA,GAAL,GAAWC,MAAM,CAACC,MAAP,CAAc,IAAIX,IAAJ,EAAd,EAA0BS,GAA1B,CAAX,CAR+B,CAU/B;;AACA,SAAKG,UAAL,GAAkBL,SAAlB;AACA,SAAKM,IAAL,GAAYL,GAAZ,CAZ+B,CAc/B;;AACA,SAAKM,KAAL;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACwB,SAAfC,eAAe,CAACP,GAAD,EAAMC,GAAN,EAAW;AAC/B,WAAO,KAAKO,MAAL,CAAY,KAAKC,eAAjB,EAAkCT,GAAlC,EAAuCC,GAAvC,CAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACwB,SAAfS,eAAe,CAACV,GAAD,EAAMC,GAAN,EAAW;AAC/B,WAAO,KAAKO,MAAL,CAAY,KAAKG,eAAjB,EAAkCX,GAAlC,EAAuCC,GAAvC,CAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACsB,SAAbW,aAAa,CAACC,SAAD,EAAY;AAC9B,UAAMC,oBAAoB,GAAId,GAAD,IAAS;AACpC,UAAI,OAAOA,GAAP,KAAe,QAAnB,EAA6B;AAC3B,eAAOe,mBAAP;AACD;;AACD,aAAOC,kBAAP;AACD,KALD;;AAOA,WAAO;AACLC,MAAAA,OAAO,CAACC,OAAD,EAAUlB,GAAV,EAAeC,GAAf,EAAoB;AACzB,eAAOa,oBAAoB,CAACd,GAAD,CAApB,CAA0BiB,OAA1B,CAAkCJ,SAAlC,EAA6CK,OAA7C,EAAsDlB,GAAtD,EAA2DC,GAA3D,CAAP;AACD,OAHI;;AAKLkB,MAAAA,OAAO,CAACC,UAAD,EAAapB,GAAb,EAAkBC,GAAlB,EAAuB;AAC5B,eAAOa,oBAAoB,CAACd,GAAD,CAApB,CAA0BmB,OAA1B,CAAkCN,SAAlC,EAA6CO,UAA7C,EAAyDpB,GAAzD,EAA8DC,GAA9D,CAAP;AACD;;AAPI,KAAP;AASD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;;;AACEK,EAAAA,KAAK,GAAG;AACN;AACA,UAAMA,KAAN,CAAYe,IAAZ,CAAiB,IAAjB,EAFM,CAIN;;AACA,SAAKC,QAAL;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACEC,EAAAA,OAAO,CAACC,UAAD,EAAa;AAClB;AACA,SAAKC,OAAL,CAAaD,UAAb,EAFkB,CAIlB;;;AACA,WAAO,KAAKE,QAAL,EAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACEC,EAAAA,QAAQ,CAACH,UAAD,EAAa;AACnB;AACA,QAAIA,UAAJ,EAAgB;AACd,WAAKC,OAAL,CAAaD,UAAb;AACD,KAJkB,CAMnB;;;AACA,UAAMI,kBAAkB,GAAG,KAAKC,WAAL,EAA3B;;AAEA,WAAOD,kBAAP;AACD;;AA/JgD;AAiKnD/B,MAAM,CAACY,eAAP,GAAyB,CAAzB;AACAZ,MAAM,CAACc,eAAP,GAAyB,CAAzB;AACAd,MAAM,CAACiC,OAAP,GAAiB,MAAM,EAAvB;AACAjC,MAAM,CAACkC,MAAP,GAAgB,MAAM,EAAtB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,MAAMC,YAAN,SAA2BnC,MAA3B,CAAkC;AACvCC,EAAAA,WAAW,CAAC,GAAGmC,IAAJ,EAAU;AACnB,UAAM,GAAGA,IAAT;AAEA,SAAKC,SAAL,GAAiB,CAAjB;AACD;;AAEDL,EAAAA,WAAW,GAAG;AACZ;AACA,UAAMM,oBAAoB,GAAG,KAAKT,QAAL,CAAc,CAAC,CAAC,OAAhB,CAA7B;;AAEA,WAAOS,oBAAP;AACD;;AAZsC;AAezC;AACA;AACA;;AACA,OAAO,MAAMC,eAAN,SAA8B5C,IAA9B,CAAmC;AACxC;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACEM,EAAAA,WAAW,CAACuC,MAAD,EAASC,EAAT,EAAa;AACtB;AAEA,SAAKC,OAAL,GAAeF,MAAf;AACA,SAAKG,GAAL,GAAWF,EAAX;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACwB,SAAf/B,eAAe,CAAC8B,MAAD,EAASC,EAAT,EAAa;AACjC,WAAO,KAAKG,SAAL,CAAejC,MAAf,CAAsB6B,MAAtB,EAA8BC,EAA9B,CAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACwB,SAAf5B,eAAe,CAAC2B,MAAD,EAASC,EAAT,EAAa;AACjC,WAAO,KAAKI,SAAL,CAAelC,MAAf,CAAsB6B,MAAtB,EAA8BC,EAA9B,CAAP;AACD;;AAhDuC;;AAmD1C,SAASK,QAAT,CAAkBC,KAAlB,EAAyBC,MAAzB,EAAiCX,SAAjC,EAA4C;AAC1C,QAAMY,MAAM,GAAGF,KAAf;AACA,MAAIG,KAAJ,CAF0C,CAI1C;;AACA,QAAMT,EAAE,GAAG,KAAKE,GAAhB,CAL0C,CAO1C;;AACA,MAAIF,EAAJ,EAAQ;AACNS,IAAAA,KAAK,GAAGT,EAAR,CADM,CAGN;;AACA,SAAKE,GAAL,GAAWQ,SAAX;AACD,GALD,MAKO;AACLD,IAAAA,KAAK,GAAG,KAAKE,UAAb;AACD,GAfyC,CAiB1C;;;AACA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGhB,SAApB,EAA+BgB,CAAC,IAAI,CAApC,EAAuC;AACrCJ,IAAAA,MAAM,CAACD,MAAM,GAAGK,CAAV,CAAN,IAAsBH,KAAK,CAACG,CAAD,CAA3B;AACD;AACF;AAED;AACA;AACA;;AAEA;AACA;AACA;;;AACA,OAAO,MAAMC,GAAN,SAAkBf,eAAlB,CAAkC;AAEzC;AACA;AACA;;AACAe,GAAG,CAACV,SAAJ,GAAgB,cAAcU,GAAd,CAAkB;AAChC;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACEC,EAAAA,YAAY,CAACR,KAAD,EAAQC,MAAR,EAAgB;AAC1B;AACA,UAAMR,MAAM,GAAG,KAAKE,OAApB;AACA,UAAM;AAAEL,MAAAA;AAAF,QAAgBG,MAAtB,CAH0B,CAK1B;;AACAM,IAAAA,QAAQ,CAACtB,IAAT,CAAc,IAAd,EAAoBuB,KAApB,EAA2BC,MAA3B,EAAmCX,SAAnC;AACAG,IAAAA,MAAM,CAACgB,YAAP,CAAoBT,KAApB,EAA2BC,MAA3B,EAP0B,CAS1B;;AACA,SAAKI,UAAL,GAAkBL,KAAK,CAACU,KAAN,CAAYT,MAAZ,EAAoBA,MAAM,GAAGX,SAA7B,CAAlB;AACD;;AAtB+B,CAAlC;AAwBA;AACA;AACA;;AACAiB,GAAG,CAACT,SAAJ,GAAgB,cAAcS,GAAd,CAAkB;AAChC;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACEC,EAAAA,YAAY,CAACR,KAAD,EAAQC,MAAR,EAAgB;AAC1B;AACA,UAAMR,MAAM,GAAG,KAAKE,OAApB;AACA,UAAM;AAAEL,MAAAA;AAAF,QAAgBG,MAAtB,CAH0B,CAK1B;;AACA,UAAMkB,SAAS,GAAGX,KAAK,CAACU,KAAN,CAAYT,MAAZ,EAAoBA,MAAM,GAAGX,SAA7B,CAAlB,CAN0B,CAQ1B;;AACAG,IAAAA,MAAM,CAACmB,YAAP,CAAoBZ,KAApB,EAA2BC,MAA3B;AACAF,IAAAA,QAAQ,CAACtB,IAAT,CAAc,IAAd,EAAoBuB,KAApB,EAA2BC,MAA3B,EAAmCX,SAAnC,EAV0B,CAY1B;;AACA,SAAKe,UAAL,GAAkBM,SAAlB;AACD;;AAzB+B,CAAlC;AA4BA;AACA;AACA;;AACA,OAAO,MAAME,KAAK,GAAG;AACnB;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACEC,EAAAA,GAAG,CAACC,IAAD,EAAOzB,SAAP,EAAkB;AACnB;AACA,UAAM0B,cAAc,GAAG1B,SAAS,GAAG,CAAnC,CAFmB,CAInB;;AACA,UAAM2B,aAAa,GAAGD,cAAc,GAAID,IAAI,CAACG,QAAL,GAAgBF,cAAxD,CALmB,CAOnB;;AACA,UAAMG,WAAW,GAAIF,aAAa,IAAI,EAAlB,GACfA,aAAa,IAAI,EADF,GAEfA,aAAa,IAAI,CAFF,GAGhBA,aAHJ,CARmB,CAanB;;AACA,UAAMG,YAAY,GAAG,EAArB;;AACA,SAAK,IAAId,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGW,aAApB,EAAmCX,CAAC,IAAI,CAAxC,EAA2C;AACzCc,MAAAA,YAAY,CAACC,IAAb,CAAkBF,WAAlB;AACD;;AACD,UAAMG,OAAO,GAAGzE,SAAS,CAACe,MAAV,CAAiBwD,YAAjB,EAA+BH,aAA/B,CAAhB,CAlBmB,CAoBnB;;AACAF,IAAAA,IAAI,CAACQ,MAAL,CAAYD,OAAZ;AACD,GAnCkB;;AAqCnB;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACEE,EAAAA,KAAK,CAACT,IAAD,EAAO;AACV,UAAMU,KAAK,GAAGV,IAAd,CADU,CAGV;;AACA,UAAME,aAAa,GAAGQ,KAAK,CAACzB,KAAN,CAAayB,KAAK,CAACP,QAAN,GAAiB,CAAlB,KAAyB,CAArC,IAA0C,IAAhE,CAJU,CAMV;;AACAO,IAAAA,KAAK,CAACP,QAAN,IAAkBD,aAAlB;AACD;;AAxDkB,CAAd;AA2DP;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,MAAMS,WAAN,SAA0BzE,MAA1B,CAAiC;AACtCC,EAAAA,WAAW,CAACC,SAAD,EAAYC,GAAZ,EAAiBC,GAAjB,EAAsB;AAC/B;AACJ;AACA;AACA;AACA;AACA;AACI,UAAMF,SAAN,EAAiBC,GAAjB,EAAsBE,MAAM,CAACC,MAAP,CACpB;AACEoE,MAAAA,IAAI,EAAEpB,GADR;AAEEe,MAAAA,OAAO,EAAET;AAFX,KADoB,EAKpBxD,GALoB,CAAtB;AAQA,SAAKiC,SAAL,GAAiB,MAAM,EAAvB;AACD;;AAED5B,EAAAA,KAAK,GAAG;AACN,QAAIkE,WAAJ,CADM,CAGN;;AACA,UAAMlE,KAAN,CAAYe,IAAZ,CAAiB,IAAjB,EAJM,CAMN;;AACA,UAAM;AAAEpB,MAAAA;AAAF,QAAU,IAAhB;AACA,UAAM;AAAEqC,MAAAA,EAAF;AAAMiC,MAAAA;AAAN,QAAetE,GAArB,CARM,CAUN;;AACA,QAAI,KAAKG,UAAL,KAAoB,KAAKN,WAAL,CAAiBW,eAAzC,EAA0D;AACxD+D,MAAAA,WAAW,GAAGD,IAAI,CAAChE,eAAnB;AACD,KAFD;AAEO;AAAmD;AACxDiE,QAAAA,WAAW,GAAGD,IAAI,CAAC7D,eAAnB,CADwD,CAExD;;AACA,aAAK+D,cAAL,GAAsB,CAAtB;AACD;;AAED,SAAKC,KAAL,GAAaF,WAAW,CAACnD,IAAZ,CAAiBkD,IAAjB,EAAuB,IAAvB,EAA6BjC,EAAE,IAAIA,EAAE,CAACM,KAAtC,CAAb;AACA,SAAK8B,KAAL,CAAWC,SAAX,GAAuBH,WAAvB;AACD;;AAEDI,EAAAA,eAAe,CAAChC,KAAD,EAAQC,MAAR,EAAgB;AAC7B,SAAK6B,KAAL,CAAWtB,YAAX,CAAwBR,KAAxB,EAA+BC,MAA/B;AACD;;AAEDhB,EAAAA,WAAW,GAAG;AACZ,QAAIM,oBAAJ,CADY,CAGZ;;AACA,UAAM;AAAE+B,MAAAA;AAAF,QAAc,KAAKjE,GAAzB,CAJY,CAMZ;;AACA,QAAI,KAAKG,UAAL,KAAoB,KAAKN,WAAL,CAAiBW,eAAzC,EAA0D;AACxD;AACAyD,MAAAA,OAAO,CAACR,GAAR,CAAY,KAAKW,KAAjB,EAAwB,KAAKnC,SAA7B,EAFwD,CAIxD;;AACAC,MAAAA,oBAAoB,GAAG,KAAKT,QAAL,CAAc,CAAC,CAAC,OAAhB,CAAvB;AACD,KAND;AAMO;AAAmD;AACxD;AACAS,QAAAA,oBAAoB,GAAG,KAAKT,QAAL,CAAc,CAAC,CAAC,OAAhB,CAAvB,CAFwD,CAIxD;;AACAwC,QAAAA,OAAO,CAACE,KAAR,CAAcjC,oBAAd;AACD;;AAED,WAAOA,oBAAP;AACD;;AApEqC;AAuExC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,MAAM0C,YAAN,SAA2BrF,IAA3B,CAAgC;AACrC;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACEM,EAAAA,WAAW,CAACgF,YAAD,EAAe;AACxB;AAEA,SAAKC,KAAL,CAAWD,YAAX;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACEE,EAAAA,QAAQ,CAACC,SAAD,EAAY;AAClB,WAAO,CAACA,SAAS,IAAI,KAAKA,SAAnB,EAA8BC,SAA9B,CAAwC,IAAxC,CAAP;AACD;;AA3CoC;AA8CvC;AACA;AACA;;AACA,OAAO,MAAMC,gBAAgB,GAAG;AAC9B;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACED,EAAAA,SAAS,CAACJ,YAAD,EAAe;AACtB,QAAIM,SAAJ,CADsB,CAGtB;;AACA,UAAM;AAAEhE,MAAAA,UAAF;AAAciE,MAAAA;AAAd,QAAuBP,YAA7B,CAJsB,CAMtB;;AACA,QAAIO,IAAJ,EAAU;AACRD,MAAAA,SAAS,GAAG3F,SAAS,CAACe,MAAV,CAAiB,CAAC,UAAD,EAAa,UAAb,CAAjB,EAA2C2D,MAA3C,CAAkDkB,IAAlD,EAAwDlB,MAAxD,CAA+D/C,UAA/D,CAAZ;AACD,KAFD,MAEO;AACLgE,MAAAA,SAAS,GAAGhE,UAAZ;AACD;;AAED,WAAOgE,SAAS,CAACJ,QAAV,CAAmBrF,MAAnB,CAAP;AACD,GA5B6B;;AA8B9B;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACE2F,EAAAA,KAAK,CAACC,UAAD,EAAa;AAChB,QAAIF,IAAJ,CADgB,CAGhB;;AACA,UAAMjE,UAAU,GAAGzB,MAAM,CAAC2F,KAAP,CAAaC,UAAb,CAAnB,CAJgB,CAMhB;;AACA,UAAMC,eAAe,GAAGpE,UAAU,CAACwB,KAAnC,CAPgB,CAShB;;AACA,QAAI4C,eAAe,CAAC,CAAD,CAAf,KAAuB,UAAvB,IAAqCA,eAAe,CAAC,CAAD,CAAf,KAAuB,UAAhE,EAA4E;AAC1E;AACAH,MAAAA,IAAI,GAAG5F,SAAS,CAACe,MAAV,CAAiBgF,eAAe,CAAClC,KAAhB,CAAsB,CAAtB,EAAyB,CAAzB,CAAjB,CAAP,CAF0E,CAI1E;;AACAkC,MAAAA,eAAe,CAACC,MAAhB,CAAuB,CAAvB,EAA0B,CAA1B;AACArE,MAAAA,UAAU,CAAC0C,QAAX,IAAuB,EAAvB;AACD;;AAED,WAAOe,YAAY,CAACrE,MAAb,CAAoB;AAAEY,MAAAA,UAAF;AAAciE,MAAAA;AAAd,KAApB,CAAP;AACD;;AA/D6B,CAAzB;AAkEP;AACA;AACA;;AACA,OAAO,MAAMrE,kBAAN,SAAiCxB,IAAjC,CAAsC;AAC3C;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACgB,SAAPyB,OAAO,CAACoB,MAAD,EAASnB,OAAT,EAAkBlB,GAAlB,EAAuBC,GAAvB,EAA4B;AACxC;AACA,UAAMyF,IAAI,GAAGxF,MAAM,CAACC,MAAP,CAAc,IAAIX,IAAJ,EAAd,EAA0B,KAAKS,GAA/B,EAAoCA,GAApC,CAAb,CAFwC,CAIxC;;;AACA,UAAM0F,SAAS,GAAGtD,MAAM,CAAC9B,eAAP,CAAuBP,GAAvB,EAA4B0F,IAA5B,CAAlB;AACA,UAAMtE,UAAU,GAAGuE,SAAS,CAAChE,QAAV,CAAmBT,OAAnB,CAAnB,CANwC,CAQxC;;AACA,UAAM0E,SAAS,GAAGD,SAAS,CAAC1F,GAA5B,CATwC,CAWxC;;AACA,WAAO4E,YAAY,CAACrE,MAAb,CAAoB;AACzBY,MAAAA,UADyB;AAEzBpB,MAAAA,GAFyB;AAGzBsC,MAAAA,EAAE,EAAEsD,SAAS,CAACtD,EAHW;AAIzBuD,MAAAA,SAAS,EAAExD,MAJc;AAKzBkC,MAAAA,IAAI,EAAEqB,SAAS,CAACrB,IALS;AAMzBL,MAAAA,OAAO,EAAE0B,SAAS,CAAC1B,OANM;AAOzBhC,MAAAA,SAAS,EAAEyD,SAAS,CAACzD,SAPI;AAQzB+C,MAAAA,SAAS,EAAES,IAAI,CAACI;AARS,KAApB,CAAP;AAUD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACgB,SAAP3E,OAAO,CAACkB,MAAD,EAASjB,UAAT,EAAqBpB,GAArB,EAA0BC,GAA1B,EAA+B;AAC3C,QAAI8F,WAAW,GAAG3E,UAAlB,CAD2C,CAG3C;;AACA,UAAMsE,IAAI,GAAGxF,MAAM,CAACC,MAAP,CAAc,IAAIX,IAAJ,EAAd,EAA0B,KAAKS,GAA/B,EAAoCA,GAApC,CAAb,CAJ2C,CAM3C;;;AACA8F,IAAAA,WAAW,GAAG,KAAKC,MAAL,CAAYD,WAAZ,EAAyBL,IAAI,CAACI,MAA9B,CAAd,CAP2C,CAS3C;;AACA,UAAMG,SAAS,GAAG5D,MAAM,CAAC3B,eAAP,CAAuBV,GAAvB,EAA4B0F,IAA5B,EAAkC/D,QAAlC,CAA2CoE,WAAW,CAAC3E,UAAvD,CAAlB;AAEA,WAAO6E,SAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACe,SAAND,MAAM,CAAC5E,UAAD,EAAa0E,MAAb,EAAqB;AAChC,QAAI,OAAO1E,UAAP,KAAsB,QAA1B,EAAoC;AAClC,aAAO0E,MAAM,CAACR,KAAP,CAAalE,UAAb,EAAyB,IAAzB,CAAP;AACD;;AACD,WAAOA,UAAP;AACD;;AAvG0C;AAyG7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACAJ,kBAAkB,CAACf,GAAnB,GAAyBC,MAAM,CAACC,MAAP,CACvB,IAAIX,IAAJ,EADuB,EAEvB;AAAEsG,EAAAA,MAAM,EAAEX;AAAV,CAFuB,CAAzB;AAKA;AACA;AACA;;AACA,OAAO,MAAMe,UAAU,GAAG;AACxB;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACEC,EAAAA,OAAO,CAACC,QAAD,EAAWtE,OAAX,EAAoBC,MAApB,EAA4BsD,IAA5B,EAAkC;AACvC,QAAIgB,KAAK,GAAGhB,IAAZ,CADuC,CAGvC;;AACA,QAAI,CAACgB,KAAL,EAAY;AACVA,MAAAA,KAAK,GAAG5G,SAAS,CAAC6G,MAAV,CAAiB,KAAK,CAAtB,CAAR;AACD,KANsC,CAQvC;;;AACA,UAAMtG,GAAG,GAAGJ,UAAU,CAACY,MAAX,CAAkB;AAAEsB,MAAAA,OAAO,EAAEA,OAAO,GAAGC;AAArB,KAAlB,EAAiDwE,OAAjD,CAAyDH,QAAzD,EAAmEC,KAAnE,CAAZ,CATuC,CAWvC;;AACA,UAAM/D,EAAE,GAAG7C,SAAS,CAACe,MAAV,CAAiBR,GAAG,CAAC4C,KAAJ,CAAUU,KAAV,CAAgBxB,OAAhB,CAAjB,EAA2CC,MAAM,GAAG,CAApD,CAAX;AACA/B,IAAAA,GAAG,CAAC8D,QAAJ,GAAehC,OAAO,GAAG,CAAzB,CAbuC,CAevC;;AACA,WAAO+C,YAAY,CAACrE,MAAb,CAAoB;AAAER,MAAAA,GAAF;AAAOsC,MAAAA,EAAP;AAAW+C,MAAAA,IAAI,EAAEgB;AAAjB,KAApB,CAAP;AACD;;AApCuB,CAAnB;AAuCP;AACA;AACA;AACA;;AACA,OAAO,MAAMtF,mBAAN,SAAkCC,kBAAlC,CAAqD;AAC1D;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACgB,SAAPC,OAAO,CAACoB,MAAD,EAASnB,OAAT,EAAkBkF,QAAlB,EAA4BnG,GAA5B,EAAiC;AAC7C;AACA,UAAMyF,IAAI,GAAGxF,MAAM,CAACC,MAAP,CAAc,IAAIX,IAAJ,EAAd,EAA0B,KAAKS,GAA/B,EAAoCA,GAApC,CAAb,CAF6C,CAI7C;;;AACA,UAAMuG,aAAa,GAAGd,IAAI,CAACe,GAAL,CAASN,OAAT,CAAiBC,QAAjB,EAA2B/D,MAAM,CAACP,OAAlC,EAA2CO,MAAM,CAACN,MAAlD,CAAtB,CAL6C,CAO7C;;;AACA2D,IAAAA,IAAI,CAACpD,EAAL,GAAUkE,aAAa,CAAClE,EAAxB,CAR6C,CAU7C;;AACA,UAAMlB,UAAU,GAAGJ,kBAAkB,CAACC,OAAnB,CAChBI,IADgB,CACX,IADW,EACLgB,MADK,EACGnB,OADH,EACYsF,aAAa,CAACxG,GAD1B,EAC+B0F,IAD/B,CAAnB,CAX6C,CAc7C;;AACAtE,IAAAA,UAAU,CAAC2D,KAAX,CAAiByB,aAAjB;AAEA,WAAOpF,UAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACgB,SAAPD,OAAO,CAACkB,MAAD,EAASjB,UAAT,EAAqBgF,QAArB,EAA+BnG,GAA/B,EAAoC;AAChD,QAAI8F,WAAW,GAAG3E,UAAlB,CADgD,CAGhD;;AACA,UAAMsE,IAAI,GAAGxF,MAAM,CAACC,MAAP,CAAc,IAAIX,IAAJ,EAAd,EAA0B,KAAKS,GAA/B,EAAoCA,GAApC,CAAb,CAJgD,CAMhD;;;AACA8F,IAAAA,WAAW,GAAG,KAAKC,MAAL,CAAYD,WAAZ,EAAyBL,IAAI,CAACI,MAA9B,CAAd,CAPgD,CAShD;;AACA,UAAMU,aAAa,GAAGd,IAAI,CAACe,GAAL,CACnBN,OADmB,CACXC,QADW,EACD/D,MAAM,CAACP,OADN,EACeO,MAAM,CAACN,MADtB,EAC8BgE,WAAW,CAACV,IAD1C,CAAtB,CAVgD,CAahD;;;AACAK,IAAAA,IAAI,CAACpD,EAAL,GAAUkE,aAAa,CAAClE,EAAxB,CAdgD,CAgBhD;;AACA,UAAM2D,SAAS,GAAGjF,kBAAkB,CAACG,OAAnB,CACfE,IADe,CACV,IADU,EACJgB,MADI,EACI0D,WADJ,EACiBS,aAAa,CAACxG,GAD/B,EACoC0F,IADpC,CAAlB;AAGA,WAAOO,SAAP;AACD;;AAlFyD;AAoF5D;AACA;AACA;AACA;AACA;AACA;AACA;;AACAlF,mBAAmB,CAACd,GAApB,GAA0BC,MAAM,CAACC,MAAP,CAAca,kBAAkB,CAACf,GAAjC,EAAsC;AAAEwG,EAAAA,GAAG,EAAEP;AAAP,CAAtC,CAA1B","sourcesContent":["/* eslint-disable no-use-before-define */\n\nimport {\n  Base,\n  WordArray,\n  BufferedBlockAlgorithm,\n} from './core.js';\nimport { Base64 } from './enc-base64.js';\nimport { EvpKDFAlgo } from './evpkdf.js';\n\n/**\n * Abstract base cipher template.\n *\n * @property {number} keySize This cipher's key size. Default: 4 (128 bits)\n * @property {number} ivSize This cipher's IV size. Default: 4 (128 bits)\n * @property {number} _ENC_XFORM_MODE A constant representing encryption mode.\n * @property {number} _DEC_XFORM_MODE A constant representing decryption mode.\n */\nexport class Cipher extends BufferedBlockAlgorithm {\n  /**\n   * Initializes a newly created cipher.\n   *\n   * @param {number} xformMode Either the encryption or decryption transormation mode constant.\n   * @param {WordArray} key The key.\n   * @param {Object} cfg (Optional) The configuration options to use for this operation.\n   *\n   * @example\n   *\n   *     const cipher = CryptoJS.algo.AES.create(\n   *       CryptoJS.algo.AES._ENC_XFORM_MODE, keyWordArray, { iv: ivWordArray }\n   *     );\n   */\n  constructor(xformMode, key, cfg) {\n    super();\n\n    /**\n     * Configuration options.\n     *\n     * @property {WordArray} iv The IV to use for this operation.\n     */\n    this.cfg = Object.assign(new Base(), cfg);\n\n    // Store transform mode and key\n    this._xformMode = xformMode;\n    this._key = key;\n\n    // Set initial values\n    this.reset();\n  }\n\n  /**\n   * Creates this cipher in encryption mode.\n   *\n   * @param {WordArray} key The key.\n   * @param {Object} cfg (Optional) The configuration options to use for this operation.\n   *\n   * @return {Cipher} A cipher instance.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     const cipher = CryptoJS.algo.AES.createEncryptor(keyWordArray, { iv: ivWordArray });\n   */\n  static createEncryptor(key, cfg) {\n    return this.create(this._ENC_XFORM_MODE, key, cfg);\n  }\n\n  /**\n   * Creates this cipher in decryption mode.\n   *\n   * @param {WordArray} key The key.\n   * @param {Object} cfg (Optional) The configuration options to use for this operation.\n   *\n   * @return {Cipher} A cipher instance.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     const cipher = CryptoJS.algo.AES.createDecryptor(keyWordArray, { iv: ivWordArray });\n   */\n  static createDecryptor(key, cfg) {\n    return this.create(this._DEC_XFORM_MODE, key, cfg);\n  }\n\n  /**\n   * Creates shortcut functions to a cipher's object interface.\n   *\n   * @param {Cipher} cipher The cipher to create a helper for.\n   *\n   * @return {Object} An object with encrypt and decrypt shortcut functions.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     const AES = CryptoJS.lib.Cipher._createHelper(CryptoJS.algo.AES);\n   */\n  static _createHelper(SubCipher) {\n    const selectCipherStrategy = (key) => {\n      if (typeof key === 'string') {\n        return PasswordBasedCipher;\n      }\n      return SerializableCipher;\n    };\n\n    return {\n      encrypt(message, key, cfg) {\n        return selectCipherStrategy(key).encrypt(SubCipher, message, key, cfg);\n      },\n\n      decrypt(ciphertext, key, cfg) {\n        return selectCipherStrategy(key).decrypt(SubCipher, ciphertext, key, cfg);\n      },\n    };\n  }\n\n  /**\n   * Resets this cipher to its initial state.\n   *\n   * @example\n   *\n   *     cipher.reset();\n   */\n  reset() {\n    // Reset data buffer\n    super.reset.call(this);\n\n    // Perform concrete-cipher logic\n    this._doReset();\n  }\n\n  /**\n   * Adds data to be encrypted or decrypted.\n   *\n   * @param {WordArray|string} dataUpdate The data to encrypt or decrypt.\n   *\n   * @return {WordArray} The data after processing.\n   *\n   * @example\n   *\n   *     const encrypted = cipher.process('data');\n   *     const encrypted = cipher.process(wordArray);\n   */\n  process(dataUpdate) {\n    // Append\n    this._append(dataUpdate);\n\n    // Process available blocks\n    return this._process();\n  }\n\n  /**\n   * Finalizes the encryption or decryption process.\n   * Note that the finalize operation is effectively a destructive, read-once operation.\n   *\n   * @param {WordArray|string} dataUpdate The final data to encrypt or decrypt.\n   *\n   * @return {WordArray} The data after final processing.\n   *\n   * @example\n   *\n   *     const encrypted = cipher.finalize();\n   *     const encrypted = cipher.finalize('data');\n   *     const encrypted = cipher.finalize(wordArray);\n   */\n  finalize(dataUpdate) {\n    // Final data update\n    if (dataUpdate) {\n      this._append(dataUpdate);\n    }\n\n    // Perform concrete-cipher logic\n    const finalProcessedData = this._doFinalize();\n\n    return finalProcessedData;\n  }\n}\nCipher._ENC_XFORM_MODE = 1;\nCipher._DEC_XFORM_MODE = 2;\nCipher.keySize = 128 / 32;\nCipher.ivSize = 128 / 32;\n\n/**\n * Abstract base stream cipher template.\n *\n * @property {number} blockSize\n *\n *     The number of 32-bit words this cipher operates on. Default: 1 (32 bits)\n */\nexport class StreamCipher extends Cipher {\n  constructor(...args) {\n    super(...args);\n\n    this.blockSize = 1;\n  }\n\n  _doFinalize() {\n    // Process partial blocks\n    const finalProcessedBlocks = this._process(!!'flush');\n\n    return finalProcessedBlocks;\n  }\n}\n\n/**\n * Abstract base block cipher mode template.\n */\nexport class BlockCipherMode extends Base {\n  /**\n   * Initializes a newly created mode.\n   *\n   * @param {Cipher} cipher A block cipher instance.\n   * @param {Array} iv The IV words.\n   *\n   * @example\n   *\n   *     const mode = CryptoJS.mode.CBC.Encryptor.create(cipher, iv.words);\n   */\n  constructor(cipher, iv) {\n    super();\n\n    this._cipher = cipher;\n    this._iv = iv;\n  }\n\n  /**\n   * Creates this mode for encryption.\n   *\n   * @param {Cipher} cipher A block cipher instance.\n   * @param {Array} iv The IV words.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     const mode = CryptoJS.mode.CBC.createEncryptor(cipher, iv.words);\n   */\n  static createEncryptor(cipher, iv) {\n    return this.Encryptor.create(cipher, iv);\n  }\n\n  /**\n   * Creates this mode for decryption.\n   *\n   * @param {Cipher} cipher A block cipher instance.\n   * @param {Array} iv The IV words.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     const mode = CryptoJS.mode.CBC.createDecryptor(cipher, iv.words);\n   */\n  static createDecryptor(cipher, iv) {\n    return this.Decryptor.create(cipher, iv);\n  }\n}\n\nfunction xorBlock(words, offset, blockSize) {\n  const _words = words;\n  let block;\n\n  // Shortcut\n  const iv = this._iv;\n\n  // Choose mixing block\n  if (iv) {\n    block = iv;\n\n    // Remove IV for subsequent blocks\n    this._iv = undefined;\n  } else {\n    block = this._prevBlock;\n  }\n\n  // XOR blocks\n  for (let i = 0; i < blockSize; i += 1) {\n    _words[offset + i] ^= block[i];\n  }\n}\n\n/**\n * Cipher Block Chaining mode.\n */\n\n/**\n * Abstract base CBC mode.\n */\nexport class CBC extends BlockCipherMode {\n}\n/**\n * CBC encryptor.\n */\nCBC.Encryptor = class extends CBC {\n  /**\n   * Processes the data block at offset.\n   *\n   * @param {Array} words The data words to operate on.\n   * @param {number} offset The offset where the block starts.\n   *\n   * @example\n   *\n   *     mode.processBlock(data.words, offset);\n   */\n  processBlock(words, offset) {\n    // Shortcuts\n    const cipher = this._cipher;\n    const { blockSize } = cipher;\n\n    // XOR and encrypt\n    xorBlock.call(this, words, offset, blockSize);\n    cipher.encryptBlock(words, offset);\n\n    // Remember this block to use with next block\n    this._prevBlock = words.slice(offset, offset + blockSize);\n  }\n};\n/**\n * CBC decryptor.\n */\nCBC.Decryptor = class extends CBC {\n  /**\n   * Processes the data block at offset.\n   *\n   * @param {Array} words The data words to operate on.\n   * @param {number} offset The offset where the block starts.\n   *\n   * @example\n   *\n   *     mode.processBlock(data.words, offset);\n   */\n  processBlock(words, offset) {\n    // Shortcuts\n    const cipher = this._cipher;\n    const { blockSize } = cipher;\n\n    // Remember this block to use with next block\n    const thisBlock = words.slice(offset, offset + blockSize);\n\n    // Decrypt and XOR\n    cipher.decryptBlock(words, offset);\n    xorBlock.call(this, words, offset, blockSize);\n\n    // This block becomes the previous block\n    this._prevBlock = thisBlock;\n  }\n};\n\n/**\n * PKCS #5/7 padding strategy.\n */\nexport const Pkcs7 = {\n  /**\n   * Pads data using the algorithm defined in PKCS #5/7.\n   *\n   * @param {WordArray} data The data to pad.\n   * @param {number} blockSize The multiple that the data should be padded to.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     CryptoJS.pad.Pkcs7.pad(wordArray, 4);\n   */\n  pad(data, blockSize) {\n    // Shortcut\n    const blockSizeBytes = blockSize * 4;\n\n    // Count padding bytes\n    const nPaddingBytes = blockSizeBytes - (data.sigBytes % blockSizeBytes);\n\n    // Create padding word\n    const paddingWord = (nPaddingBytes << 24)\n      | (nPaddingBytes << 16)\n      | (nPaddingBytes << 8)\n      | nPaddingBytes;\n\n    // Create padding\n    const paddingWords = [];\n    for (let i = 0; i < nPaddingBytes; i += 4) {\n      paddingWords.push(paddingWord);\n    }\n    const padding = WordArray.create(paddingWords, nPaddingBytes);\n\n    // Add padding\n    data.concat(padding);\n  },\n\n  /**\n   * Unpads data that had been padded using the algorithm defined in PKCS #5/7.\n   *\n   * @param {WordArray} data The data to unpad.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     CryptoJS.pad.Pkcs7.unpad(wordArray);\n   */\n  unpad(data) {\n    const _data = data;\n\n    // Get number of padding bytes from last byte\n    const nPaddingBytes = _data.words[(_data.sigBytes - 1) >>> 2] & 0xff;\n\n    // Remove padding\n    _data.sigBytes -= nPaddingBytes;\n  },\n};\n\n/**\n * Abstract base block cipher template.\n *\n * @property {number} blockSize\n *\n *    The number of 32-bit words this cipher operates on. Default: 4 (128 bits)\n */\nexport class BlockCipher extends Cipher {\n  constructor(xformMode, key, cfg) {\n    /**\n     * Configuration options.\n     *\n     * @property {Mode} mode The block mode to use. Default: CBC\n     * @property {Padding} padding The padding strategy to use. Default: Pkcs7\n     */\n    super(xformMode, key, Object.assign(\n      {\n        mode: CBC,\n        padding: Pkcs7,\n      },\n      cfg,\n    ));\n\n    this.blockSize = 128 / 32;\n  }\n\n  reset() {\n    let modeCreator;\n\n    // Reset cipher\n    super.reset.call(this);\n\n    // Shortcuts\n    const { cfg } = this;\n    const { iv, mode } = cfg;\n\n    // Reset block mode\n    if (this._xformMode === this.constructor._ENC_XFORM_MODE) {\n      modeCreator = mode.createEncryptor;\n    } else /* if (this._xformMode == this._DEC_XFORM_MODE) */ {\n      modeCreator = mode.createDecryptor;\n      // Keep at least one block in the buffer for unpadding\n      this._minBufferSize = 1;\n    }\n\n    this._mode = modeCreator.call(mode, this, iv && iv.words);\n    this._mode.__creator = modeCreator;\n  }\n\n  _doProcessBlock(words, offset) {\n    this._mode.processBlock(words, offset);\n  }\n\n  _doFinalize() {\n    let finalProcessedBlocks;\n\n    // Shortcut\n    const { padding } = this.cfg;\n\n    // Finalize\n    if (this._xformMode === this.constructor._ENC_XFORM_MODE) {\n      // Pad data\n      padding.pad(this._data, this.blockSize);\n\n      // Process final blocks\n      finalProcessedBlocks = this._process(!!'flush');\n    } else /* if (this._xformMode == this._DEC_XFORM_MODE) */ {\n      // Process final blocks\n      finalProcessedBlocks = this._process(!!'flush');\n\n      // Unpad data\n      padding.unpad(finalProcessedBlocks);\n    }\n\n    return finalProcessedBlocks;\n  }\n}\n\n/**\n * A collection of cipher parameters.\n *\n * @property {WordArray} ciphertext The raw ciphertext.\n * @property {WordArray} key The key to this ciphertext.\n * @property {WordArray} iv The IV used in the ciphering operation.\n * @property {WordArray} salt The salt used with a key derivation function.\n * @property {Cipher} algorithm The cipher algorithm.\n * @property {Mode} mode The block mode used in the ciphering operation.\n * @property {Padding} padding The padding scheme used in the ciphering operation.\n * @property {number} blockSize The block size of the cipher.\n * @property {Format} formatter\n *    The default formatting strategy to convert this cipher params object to a string.\n */\nexport class CipherParams extends Base {\n  /**\n   * Initializes a newly created cipher params object.\n   *\n   * @param {Object} cipherParams An object with any of the possible cipher parameters.\n   *\n   * @example\n   *\n   *     var cipherParams = CryptoJS.lib.CipherParams.create({\n   *         ciphertext: ciphertextWordArray,\n   *         key: keyWordArray,\n   *         iv: ivWordArray,\n   *         salt: saltWordArray,\n   *         algorithm: CryptoJS.algo.AES,\n   *         mode: CryptoJS.mode.CBC,\n   *         padding: CryptoJS.pad.PKCS7,\n   *         blockSize: 4,\n   *         formatter: CryptoJS.format.OpenSSL\n   *     });\n   */\n  constructor(cipherParams) {\n    super();\n\n    this.mixIn(cipherParams);\n  }\n\n  /**\n   * Converts this cipher params object to a string.\n   *\n   * @param {Format} formatter (Optional) The formatting strategy to use.\n   *\n   * @return {string} The stringified cipher params.\n   *\n   * @throws Error If neither the formatter nor the default formatter is set.\n   *\n   * @example\n   *\n   *     var string = cipherParams + '';\n   *     var string = cipherParams.toString();\n   *     var string = cipherParams.toString(CryptoJS.format.OpenSSL);\n   */\n  toString(formatter) {\n    return (formatter || this.formatter).stringify(this);\n  }\n}\n\n/**\n * OpenSSL formatting strategy.\n */\nexport const OpenSSLFormatter = {\n  /**\n   * Converts a cipher params object to an OpenSSL-compatible string.\n   *\n   * @param {CipherParams} cipherParams The cipher params object.\n   *\n   * @return {string} The OpenSSL-compatible string.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var openSSLString = CryptoJS.format.OpenSSL.stringify(cipherParams);\n   */\n  stringify(cipherParams) {\n    let wordArray;\n\n    // Shortcuts\n    const { ciphertext, salt } = cipherParams;\n\n    // Format\n    if (salt) {\n      wordArray = WordArray.create([0x53616c74, 0x65645f5f]).concat(salt).concat(ciphertext);\n    } else {\n      wordArray = ciphertext;\n    }\n\n    return wordArray.toString(Base64);\n  },\n\n  /**\n   * Converts an OpenSSL-compatible string to a cipher params object.\n   *\n   * @param {string} openSSLStr The OpenSSL-compatible string.\n   *\n   * @return {CipherParams} The cipher params object.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var cipherParams = CryptoJS.format.OpenSSL.parse(openSSLString);\n   */\n  parse(openSSLStr) {\n    let salt;\n\n    // Parse base64\n    const ciphertext = Base64.parse(openSSLStr);\n\n    // Shortcut\n    const ciphertextWords = ciphertext.words;\n\n    // Test for salt\n    if (ciphertextWords[0] === 0x53616c74 && ciphertextWords[1] === 0x65645f5f) {\n      // Extract salt\n      salt = WordArray.create(ciphertextWords.slice(2, 4));\n\n      // Remove salt from ciphertext\n      ciphertextWords.splice(0, 4);\n      ciphertext.sigBytes -= 16;\n    }\n\n    return CipherParams.create({ ciphertext, salt });\n  },\n};\n\n/**\n * A cipher wrapper that returns ciphertext as a serializable cipher params object.\n */\nexport class SerializableCipher extends Base {\n  /**\n   * Encrypts a message.\n   *\n   * @param {Cipher} cipher The cipher algorithm to use.\n   * @param {WordArray|string} message The message to encrypt.\n   * @param {WordArray} key The key.\n   * @param {Object} cfg (Optional) The configuration options to use for this operation.\n   *\n   * @return {CipherParams} A cipher params object.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var ciphertextParams = CryptoJS.lib.SerializableCipher\n   *       .encrypt(CryptoJS.algo.AES, message, key);\n   *     var ciphertextParams = CryptoJS.lib.SerializableCipher\n   *       .encrypt(CryptoJS.algo.AES, message, key, { iv: iv });\n   *     var ciphertextParams = CryptoJS.lib.SerializableCipher\n   *       .encrypt(CryptoJS.algo.AES, message, key, { iv: iv, format: CryptoJS.format.OpenSSL });\n   */\n  static encrypt(cipher, message, key, cfg) {\n    // Apply config defaults\n    const _cfg = Object.assign(new Base(), this.cfg, cfg);\n\n    // Encrypt\n    const encryptor = cipher.createEncryptor(key, _cfg);\n    const ciphertext = encryptor.finalize(message);\n\n    // Shortcut\n    const cipherCfg = encryptor.cfg;\n\n    // Create and return serializable cipher params\n    return CipherParams.create({\n      ciphertext,\n      key,\n      iv: cipherCfg.iv,\n      algorithm: cipher,\n      mode: cipherCfg.mode,\n      padding: cipherCfg.padding,\n      blockSize: encryptor.blockSize,\n      formatter: _cfg.format,\n    });\n  }\n\n  /**\n   * Decrypts serialized ciphertext.\n   *\n   * @param {Cipher} cipher The cipher algorithm to use.\n   * @param {CipherParams|string} ciphertext The ciphertext to decrypt.\n   * @param {WordArray} key The key.\n   * @param {Object} cfg (Optional) The configuration options to use for this operation.\n   *\n   * @return {WordArray} The plaintext.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var plaintext = CryptoJS.lib.SerializableCipher\n   *       .decrypt(CryptoJS.algo.AES, formattedCiphertext, key,\n   *         { iv: iv, format: CryptoJS.format.OpenSSL });\n   *     var plaintext = CryptoJS.lib.SerializableCipher\n   *       .decrypt(CryptoJS.algo.AES, ciphertextParams, key,\n   *         { iv: iv, format: CryptoJS.format.OpenSSL });\n   */\n  static decrypt(cipher, ciphertext, key, cfg) {\n    let _ciphertext = ciphertext;\n\n    // Apply config defaults\n    const _cfg = Object.assign(new Base(), this.cfg, cfg);\n\n    // Convert string to CipherParams\n    _ciphertext = this._parse(_ciphertext, _cfg.format);\n\n    // Decrypt\n    const plaintext = cipher.createDecryptor(key, _cfg).finalize(_ciphertext.ciphertext);\n\n    return plaintext;\n  }\n\n  /**\n   * Converts serialized ciphertext to CipherParams,\n   * else assumed CipherParams already and returns ciphertext unchanged.\n   *\n   * @param {CipherParams|string} ciphertext The ciphertext.\n   * @param {Formatter} format The formatting strategy to use to parse serialized ciphertext.\n   *\n   * @return {CipherParams} The unserialized ciphertext.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var ciphertextParams = CryptoJS.lib.SerializableCipher\n   *       ._parse(ciphertextStringOrParams, format);\n   */\n  static _parse(ciphertext, format) {\n    if (typeof ciphertext === 'string') {\n      return format.parse(ciphertext, this);\n    }\n    return ciphertext;\n  }\n}\n/**\n * Configuration options.\n *\n * @property {Formatter} format\n *\n *    The formatting strategy to convert cipher param objects to and from a string.\n *    Default: OpenSSL\n */\nSerializableCipher.cfg = Object.assign(\n  new Base(),\n  { format: OpenSSLFormatter },\n);\n\n/**\n * OpenSSL key derivation function.\n */\nexport const OpenSSLKdf = {\n  /**\n   * Derives a key and IV from a password.\n   *\n   * @param {string} password The password to derive from.\n   * @param {number} keySize The size in words of the key to generate.\n   * @param {number} ivSize The size in words of the IV to generate.\n   * @param {WordArray|string} salt\n   *     (Optional) A 64-bit salt to use. If omitted, a salt will be generated randomly.\n   *\n   * @return {CipherParams} A cipher params object with the key, IV, and salt.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32);\n   *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32, 'saltsalt');\n   */\n  execute(password, keySize, ivSize, salt) {\n    let _salt = salt;\n\n    // Generate random salt\n    if (!_salt) {\n      _salt = WordArray.random(64 / 8);\n    }\n\n    // Derive key and IV\n    const key = EvpKDFAlgo.create({ keySize: keySize + ivSize }).compute(password, _salt);\n\n    // Separate key and IV\n    const iv = WordArray.create(key.words.slice(keySize), ivSize * 4);\n    key.sigBytes = keySize * 4;\n\n    // Return params\n    return CipherParams.create({ key, iv, salt: _salt });\n  },\n};\n\n/**\n * A serializable cipher wrapper that derives the key from a password,\n * and returns ciphertext as a serializable cipher params object.\n */\nexport class PasswordBasedCipher extends SerializableCipher {\n  /**\n   * Encrypts a message using a password.\n   *\n   * @param {Cipher} cipher The cipher algorithm to use.\n   * @param {WordArray|string} message The message to encrypt.\n   * @param {string} password The password.\n   * @param {Object} cfg (Optional) The configuration options to use for this operation.\n   *\n   * @return {CipherParams} A cipher params object.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher\n   *       .encrypt(CryptoJS.algo.AES, message, 'password');\n   *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher\n   *       .encrypt(CryptoJS.algo.AES, message, 'password', { format: CryptoJS.format.OpenSSL });\n   */\n  static encrypt(cipher, message, password, cfg) {\n    // Apply config defaults\n    const _cfg = Object.assign(new Base(), this.cfg, cfg);\n\n    // Derive key and other params\n    const derivedParams = _cfg.kdf.execute(password, cipher.keySize, cipher.ivSize);\n\n    // Add IV to config\n    _cfg.iv = derivedParams.iv;\n\n    // Encrypt\n    const ciphertext = SerializableCipher.encrypt\n      .call(this, cipher, message, derivedParams.key, _cfg);\n\n    // Mix in derived params\n    ciphertext.mixIn(derivedParams);\n\n    return ciphertext;\n  }\n\n  /**\n   * Decrypts serialized ciphertext using a password.\n   *\n   * @param {Cipher} cipher The cipher algorithm to use.\n   * @param {CipherParams|string} ciphertext The ciphertext to decrypt.\n   * @param {string} password The password.\n   * @param {Object} cfg (Optional) The configuration options to use for this operation.\n   *\n   * @return {WordArray} The plaintext.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var plaintext = CryptoJS.lib.PasswordBasedCipher\n   *       .decrypt(CryptoJS.algo.AES, formattedCiphertext, 'password',\n   *         { format: CryptoJS.format.OpenSSL });\n   *     var plaintext = CryptoJS.lib.PasswordBasedCipher\n   *       .decrypt(CryptoJS.algo.AES, ciphertextParams, 'password',\n   *         { format: CryptoJS.format.OpenSSL });\n   */\n  static decrypt(cipher, ciphertext, password, cfg) {\n    let _ciphertext = ciphertext;\n\n    // Apply config defaults\n    const _cfg = Object.assign(new Base(), this.cfg, cfg);\n\n    // Convert string to CipherParams\n    _ciphertext = this._parse(_ciphertext, _cfg.format);\n\n    // Derive key and other params\n    const derivedParams = _cfg.kdf\n      .execute(password, cipher.keySize, cipher.ivSize, _ciphertext.salt);\n\n    // Add IV to config\n    _cfg.iv = derivedParams.iv;\n\n    // Decrypt\n    const plaintext = SerializableCipher.decrypt\n      .call(this, cipher, _ciphertext, derivedParams.key, _cfg);\n\n    return plaintext;\n  }\n}\n/**\n * Configuration options.\n *\n * @property {KDF} kdf\n *     The key derivation function to use to generate a key and IV from a password.\n *     Default: OpenSSL\n */\nPasswordBasedCipher.cfg = Object.assign(SerializableCipher.cfg, { kdf: OpenSSLKdf });\n"]},"metadata":{},"sourceType":"module"}