{"ast":null,"code":"import { Base, WordArray } from './core.js';\nimport { MD5Algo } from './md5.js';\n/**\n * This key derivation function is meant to conform with EVP_BytesToKey.\n * www.openssl.org/docs/crypto/EVP_BytesToKey.html\n */\n\nexport class EvpKDFAlgo extends Base {\n  /**\n   * Initializes a newly created key derivation function.\n   *\n   * @param {Object} cfg (Optional) The configuration options to use for the derivation.\n   *\n   * @example\n   *\n   *     const kdf = CryptoJS.algo.EvpKDF.create();\n   *     const kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8 });\n   *     const kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8, iterations: 1000 });\n   */\n  constructor(cfg) {\n    super();\n    /**\n     * Configuration options.\n     *\n     * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)\n     * @property {Hasher} hasher The hash algorithm to use. Default: MD5\n     * @property {number} iterations The number of iterations to perform. Default: 1\n     */\n\n    this.cfg = Object.assign(new Base(), {\n      keySize: 128 / 32,\n      hasher: MD5Algo,\n      iterations: 1\n    }, cfg);\n  }\n  /**\n   * Derives a key from a password.\n   *\n   * @param {WordArray|string} password The password.\n   * @param {WordArray|string} salt A salt.\n   *\n   * @return {WordArray} The derived key.\n   *\n   * @example\n   *\n   *     const key = kdf.compute(password, salt);\n   */\n\n\n  compute(password, salt) {\n    let block; // Shortcut\n\n    const {\n      cfg\n    } = this; // Init hasher\n\n    const hasher = cfg.hasher.create(); // Initial values\n\n    const derivedKey = WordArray.create(); // Shortcuts\n\n    const derivedKeyWords = derivedKey.words;\n    const {\n      keySize,\n      iterations\n    } = cfg; // Generate key\n\n    while (derivedKeyWords.length < keySize) {\n      if (block) {\n        hasher.update(block);\n      }\n\n      block = hasher.update(password).finalize(salt);\n      hasher.reset(); // Iterations\n\n      for (let i = 1; i < iterations; i += 1) {\n        block = hasher.finalize(block);\n        hasher.reset();\n      }\n\n      derivedKey.concat(block);\n    }\n\n    derivedKey.sigBytes = keySize * 4;\n    return derivedKey;\n  }\n\n}\n/**\n * Derives a key from a password.\n *\n * @param {WordArray|string} password The password.\n * @param {WordArray|string} salt A salt.\n * @param {Object} cfg (Optional) The configuration options to use for this computation.\n *\n * @return {WordArray} The derived key.\n *\n * @static\n *\n * @example\n *\n *     var key = CryptoJS.EvpKDF(password, salt);\n *     var key = CryptoJS.EvpKDF(password, salt, { keySize: 8 });\n *     var key = CryptoJS.EvpKDF(password, salt, { keySize: 8, iterations: 1000 });\n */\n\nexport const EvpKDF = (password, salt, cfg) => EvpKDFAlgo.create(cfg).compute(password, salt);","map":{"version":3,"sources":["/Users/chrisbuonocore/personal/hackathons/hackfs21/node_modules/crypto-es/lib/evpkdf.js"],"names":["Base","WordArray","MD5Algo","EvpKDFAlgo","constructor","cfg","Object","assign","keySize","hasher","iterations","compute","password","salt","block","create","derivedKey","derivedKeyWords","words","length","update","finalize","reset","i","concat","sigBytes","EvpKDF"],"mappings":"AAAA,SACEA,IADF,EAEEC,SAFF,QAGO,WAHP;AAIA,SAASC,OAAT,QAAwB,UAAxB;AAEA;AACA;AACA;AACA;;AACA,OAAO,MAAMC,UAAN,SAAyBH,IAAzB,CAA8B;AACnC;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACEI,EAAAA,WAAW,CAACC,GAAD,EAAM;AACf;AAEA;AACJ;AACA;AACA;AACA;AACA;AACA;;AACI,SAAKA,GAAL,GAAWC,MAAM,CAACC,MAAP,CACT,IAAIP,IAAJ,EADS,EAET;AACEQ,MAAAA,OAAO,EAAE,MAAM,EADjB;AAEEC,MAAAA,MAAM,EAAEP,OAFV;AAGEQ,MAAAA,UAAU,EAAE;AAHd,KAFS,EAOTL,GAPS,CAAX;AASD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACEM,EAAAA,OAAO,CAACC,QAAD,EAAWC,IAAX,EAAiB;AACtB,QAAIC,KAAJ,CADsB,CAGtB;;AACA,UAAM;AAAET,MAAAA;AAAF,QAAU,IAAhB,CAJsB,CAMtB;;AACA,UAAMI,MAAM,GAAGJ,GAAG,CAACI,MAAJ,CAAWM,MAAX,EAAf,CAPsB,CAStB;;AACA,UAAMC,UAAU,GAAGf,SAAS,CAACc,MAAV,EAAnB,CAVsB,CAYtB;;AACA,UAAME,eAAe,GAAGD,UAAU,CAACE,KAAnC;AACA,UAAM;AAAEV,MAAAA,OAAF;AAAWE,MAAAA;AAAX,QAA0BL,GAAhC,CAdsB,CAgBtB;;AACA,WAAOY,eAAe,CAACE,MAAhB,GAAyBX,OAAhC,EAAyC;AACvC,UAAIM,KAAJ,EAAW;AACTL,QAAAA,MAAM,CAACW,MAAP,CAAcN,KAAd;AACD;;AACDA,MAAAA,KAAK,GAAGL,MAAM,CAACW,MAAP,CAAcR,QAAd,EAAwBS,QAAxB,CAAiCR,IAAjC,CAAR;AACAJ,MAAAA,MAAM,CAACa,KAAP,GALuC,CAOvC;;AACA,WAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGb,UAApB,EAAgCa,CAAC,IAAI,CAArC,EAAwC;AACtCT,QAAAA,KAAK,GAAGL,MAAM,CAACY,QAAP,CAAgBP,KAAhB,CAAR;AACAL,QAAAA,MAAM,CAACa,KAAP;AACD;;AAEDN,MAAAA,UAAU,CAACQ,MAAX,CAAkBV,KAAlB;AACD;;AACDE,IAAAA,UAAU,CAACS,QAAX,GAAsBjB,OAAO,GAAG,CAAhC;AAEA,WAAOQ,UAAP;AACD;;AAhFkC;AAmFrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,MAAMU,MAAM,GAAG,CAACd,QAAD,EAAWC,IAAX,EAAiBR,GAAjB,KAAyBF,UAAU,CAACY,MAAX,CAAkBV,GAAlB,EAAuBM,OAAvB,CAA+BC,QAA/B,EAAyCC,IAAzC,CAAxC","sourcesContent":["import {\n  Base,\n  WordArray,\n} from './core.js';\nimport { MD5Algo } from './md5.js';\n\n/**\n * This key derivation function is meant to conform with EVP_BytesToKey.\n * www.openssl.org/docs/crypto/EVP_BytesToKey.html\n */\nexport class EvpKDFAlgo extends Base {\n  /**\n   * Initializes a newly created key derivation function.\n   *\n   * @param {Object} cfg (Optional) The configuration options to use for the derivation.\n   *\n   * @example\n   *\n   *     const kdf = CryptoJS.algo.EvpKDF.create();\n   *     const kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8 });\n   *     const kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8, iterations: 1000 });\n   */\n  constructor(cfg) {\n    super();\n\n    /**\n     * Configuration options.\n     *\n     * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)\n     * @property {Hasher} hasher The hash algorithm to use. Default: MD5\n     * @property {number} iterations The number of iterations to perform. Default: 1\n     */\n    this.cfg = Object.assign(\n      new Base(),\n      {\n        keySize: 128 / 32,\n        hasher: MD5Algo,\n        iterations: 1,\n      },\n      cfg,\n    );\n  }\n\n  /**\n   * Derives a key from a password.\n   *\n   * @param {WordArray|string} password The password.\n   * @param {WordArray|string} salt A salt.\n   *\n   * @return {WordArray} The derived key.\n   *\n   * @example\n   *\n   *     const key = kdf.compute(password, salt);\n   */\n  compute(password, salt) {\n    let block;\n\n    // Shortcut\n    const { cfg } = this;\n\n    // Init hasher\n    const hasher = cfg.hasher.create();\n\n    // Initial values\n    const derivedKey = WordArray.create();\n\n    // Shortcuts\n    const derivedKeyWords = derivedKey.words;\n    const { keySize, iterations } = cfg;\n\n    // Generate key\n    while (derivedKeyWords.length < keySize) {\n      if (block) {\n        hasher.update(block);\n      }\n      block = hasher.update(password).finalize(salt);\n      hasher.reset();\n\n      // Iterations\n      for (let i = 1; i < iterations; i += 1) {\n        block = hasher.finalize(block);\n        hasher.reset();\n      }\n\n      derivedKey.concat(block);\n    }\n    derivedKey.sigBytes = keySize * 4;\n\n    return derivedKey;\n  }\n}\n\n/**\n * Derives a key from a password.\n *\n * @param {WordArray|string} password The password.\n * @param {WordArray|string} salt A salt.\n * @param {Object} cfg (Optional) The configuration options to use for this computation.\n *\n * @return {WordArray} The derived key.\n *\n * @static\n *\n * @example\n *\n *     var key = CryptoJS.EvpKDF(password, salt);\n *     var key = CryptoJS.EvpKDF(password, salt, { keySize: 8 });\n *     var key = CryptoJS.EvpKDF(password, salt, { keySize: 8, iterations: 1000 });\n */\nexport const EvpKDF = (password, salt, cfg) => EvpKDFAlgo.create(cfg).compute(password, salt);\n"]},"metadata":{},"sourceType":"module"}