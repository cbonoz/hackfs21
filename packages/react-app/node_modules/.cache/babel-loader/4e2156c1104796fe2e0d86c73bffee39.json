{"ast":null,"code":"var _s = $RefreshSig$();\n\nimport { useEffect, useState } from \"react\";\nimport useOnBlock from \"./OnBlock\";\nimport usePoller from \"./Poller\";\nconst DEBUG = false;\n/*\n  ~ What it does? ~\n\n  Enables you to read values from contracts and keep track of them in the local React states\n\n  ~ How can I use? ~\n\n  const purpose = useContractReader(readContracts,\"YourContract\", \"purpose\")\n\n  ~ Features ~\n\n  - Provide readContracts by loading contracts (see more on ContractLoader.js)\n  - Specify the name of the contract, in this case it is \"YourContract\"\n  - Specify the name of the variable in the contract, in this case we keep track of \"purpose\" variable\n  - Pass an args array if the function requires\n  - Pass pollTime - if no pollTime is specified, the function will update on every new block\n*/\n\nexport default function useContractReader(contracts, contractName, functionName, args, pollTime, formatter, onChange) {\n  _s();\n\n  let adjustPollTime = 0;\n\n  if (pollTime) {\n    adjustPollTime = pollTime;\n  } else if (!pollTime && typeof args === \"number\") {\n    // it's okay to pass poll time as last argument without args for the call\n    adjustPollTime = args;\n  }\n\n  const [value, setValue] = useState();\n  const [tried, setTried] = useState(false);\n  useEffect(() => {\n    if (typeof onChange === \"function\") {\n      setTimeout(onChange.bind(this, value), 1);\n    }\n  }, [value, onChange]);\n\n  const updateValue = async () => {\n    try {\n      let newValue;\n      if (DEBUG) console.log(\"CALLING \", contractName, functionName, \"with args\", args);\n\n      if (args && args.length > 0) {\n        newValue = await contracts[contractName][functionName](...args);\n        setTried(true);\n        if (DEBUG) console.log(\"contractName\", contractName, \"functionName\", functionName, \"args\", args, \"RESULT:\", newValue);\n      } else {\n        newValue = await contracts[contractName][functionName]();\n        setTried(true);\n      }\n\n      if (formatter && typeof formatter === \"function\") {\n        newValue = formatter(newValue);\n      } // console.log(\"GOT VALUE\",newValue)\n\n\n      if (newValue !== value) {\n        setValue(newValue);\n      }\n    } catch (e) {\n      console.log(e);\n    }\n  }; // Only pass a provider to watch on a block if we have a contract and no PollTime\n\n\n  useOnBlock(contracts && contracts[contractName] && adjustPollTime === 0 && contracts[contractName].provider, () => {\n    if (contracts && contracts[contractName] && adjustPollTime === 0) {\n      if (DEBUG) console.log(\"on-blocking!\", contractName, functionName);\n      updateValue();\n    }\n  }); // Use a poller if a pollTime is provided\n\n  usePoller(async () => {\n    if (contracts && contracts[contractName] && adjustPollTime > 0) {\n      if (DEBUG) console.log(\"polling!\", contractName, functionName);\n      updateValue();\n    }\n  }, adjustPollTime, contracts && contracts[contractName]);\n\n  if (tried === false && contracts && contracts[contractName]) {\n    updateValue();\n  }\n\n  return value;\n}\n\n_s(useContractReader, \"hZjxDiqC81HGRleCp+6VYurLeN4=\", false, function () {\n  return [useOnBlock, usePoller];\n});","map":{"version":3,"sources":["/Users/chrisbuonocore/personal/hackathons/hackfs21/packages/react-app/src/hooks/ContractReader.js"],"names":["useEffect","useState","useOnBlock","usePoller","DEBUG","useContractReader","contracts","contractName","functionName","args","pollTime","formatter","onChange","adjustPollTime","value","setValue","tried","setTried","setTimeout","bind","updateValue","newValue","console","log","length","e","provider"],"mappings":"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","sourcesContent":["import { useEffect, useState } from \"react\";\nimport useOnBlock from \"./OnBlock\";\nimport usePoller from \"./Poller\";\n\nconst DEBUG = false;\n\n/*\n  ~ What it does? ~\n\n  Enables you to read values from contracts and keep track of them in the local React states\n\n  ~ How can I use? ~\n\n  const purpose = useContractReader(readContracts,\"YourContract\", \"purpose\")\n\n  ~ Features ~\n\n  - Provide readContracts by loading contracts (see more on ContractLoader.js)\n  - Specify the name of the contract, in this case it is \"YourContract\"\n  - Specify the name of the variable in the contract, in this case we keep track of \"purpose\" variable\n  - Pass an args array if the function requires\n  - Pass pollTime - if no pollTime is specified, the function will update on every new block\n*/\n\nexport default function useContractReader(contracts, contractName, functionName, args, pollTime, formatter, onChange) {\n  let adjustPollTime = 0;\n  if (pollTime) {\n    adjustPollTime = pollTime;\n  } else if (!pollTime && typeof args === \"number\") {\n    // it's okay to pass poll time as last argument without args for the call\n    adjustPollTime = args;\n  }\n\n  const [value, setValue] = useState();\n  const [tried, setTried] = useState(false);\n\n  useEffect(() => {\n    if (typeof onChange === \"function\") {\n      setTimeout(onChange.bind(this, value), 1);\n    }\n  }, [value, onChange]);\n\n  const updateValue = async () => {\n    try {\n      let newValue;\n      if (DEBUG) console.log(\"CALLING \", contractName, functionName, \"with args\", args);\n      if (args && args.length > 0) {\n        newValue = await contracts[contractName][functionName](...args);\n        setTried(true);\n        if (DEBUG)\n          console.log(\"contractName\", contractName, \"functionName\", functionName, \"args\", args, \"RESULT:\", newValue);\n      } else {\n        newValue = await contracts[contractName][functionName]();\n        setTried(true);\n      }\n      if (formatter && typeof formatter === \"function\") {\n        newValue = formatter(newValue);\n      }\n      // console.log(\"GOT VALUE\",newValue)\n      if (newValue !== value) {\n        setValue(newValue);\n      }\n    } catch (e) {\n      console.log(e);\n    }\n  };\n\n  // Only pass a provider to watch on a block if we have a contract and no PollTime\n  useOnBlock(contracts && contracts[contractName] && adjustPollTime === 0 && contracts[contractName].provider, () => {\n    if (contracts && contracts[contractName] && adjustPollTime === 0) {\n      if (DEBUG) console.log(\"on-blocking!\", contractName, functionName);\n      updateValue();\n    }\n  });\n\n  // Use a poller if a pollTime is provided\n  usePoller(\n    async () => {\n      if (contracts && contracts[contractName] && adjustPollTime > 0) {\n        if (DEBUG) console.log(\"polling!\", contractName, functionName);\n        updateValue();\n      }\n    },\n    adjustPollTime,\n    contracts && contracts[contractName],\n  );\n\n  if (tried === false && contracts && contracts[contractName]) {\n    updateValue();\n  }\n\n  return value;\n}\n"]},"metadata":{},"sourceType":"module"}