{"ast":null,"code":"import { parse, visit } from 'graphql';\nimport nullthrows from 'nullthrows';\nexport const getFragmentDependencies = (operationString, fragmentDefinitions) => {\n  if (!fragmentDefinitions) {\n    return [];\n  }\n\n  let parsedOperation;\n\n  try {\n    parsedOperation = parse(operationString, {\n      allowLegacySDLImplementsInterfaces: true,\n      allowLegacySDLEmptyFields: true\n    });\n  } catch (error) {\n    return [];\n  }\n\n  return getFragmentDependenciesForAST(parsedOperation, fragmentDefinitions);\n};\nexport const getFragmentDependenciesForAST = (parsedOperation, fragmentDefinitions) => {\n  if (!fragmentDefinitions) {\n    return [];\n  }\n\n  const existingFrags = new Map();\n  const referencedFragNames = new Set();\n  visit(parsedOperation, {\n    FragmentDefinition(node) {\n      existingFrags.set(node.name.value, true);\n    },\n\n    FragmentSpread(node) {\n      if (!referencedFragNames.has(node.name.value)) {\n        referencedFragNames.add(node.name.value);\n      }\n    }\n\n  });\n  const asts = new Set();\n  referencedFragNames.forEach(name => {\n    if (!existingFrags.has(name) && fragmentDefinitions.has(name)) {\n      asts.add(nullthrows(fragmentDefinitions.get(name)));\n    }\n  });\n  const referencedFragments = [];\n  asts.forEach(ast => {\n    visit(ast, {\n      FragmentSpread(node) {\n        if (!referencedFragNames.has(node.name.value) && fragmentDefinitions.get(node.name.value)) {\n          asts.add(nullthrows(fragmentDefinitions.get(node.name.value)));\n          referencedFragNames.add(node.name.value);\n        }\n      }\n\n    });\n\n    if (!existingFrags.has(ast.name.value)) {\n      referencedFragments.push(ast);\n    }\n  });\n  return referencedFragments;\n};","map":{"version":3,"sources":["../src/fragmentDependencies.ts"],"names":[],"mappings":"AAAA,SAA+C,KAA/C,EAAsD,KAAtD,QAAmE,SAAnE;AACA,OAAO,UAAP,MAAuB,YAAvB;AAEA,OAAO,MAAM,uBAAuB,GAAG,CACrC,eADqC,EAErC,mBAFqC,KAGT;AAG5B,MAAI,CAAC,mBAAL,EAA0B;AACxB,WAAO,EAAP;AACD;;AAGD,MAAI,eAAJ;;AACA,MAAI;AACF,IAAA,eAAe,GAAG,KAAK,CAAC,eAAD,EAAkB;AACvC,MAAA,kCAAkC,EAAE,IADG;AAEvC,MAAA,yBAAyB,EAAE;AAFY,KAAlB,CAAvB;AAID,GALD,CAKE,OAAO,KAAP,EAAc;AACd,WAAO,EAAP;AACD;;AACD,SAAO,6BAA6B,CAAC,eAAD,EAAkB,mBAAlB,CAApC;AACD,CArBM;AAuBP,OAAO,MAAM,6BAA6B,GAAG,CAC3C,eAD2C,EAE3C,mBAF2C,KAGf;AAC5B,MAAI,CAAC,mBAAL,EAA0B;AACxB,WAAO,EAAP;AACD;;AAED,QAAM,aAAa,GAAG,IAAI,GAAJ,EAAtB;AACA,QAAM,mBAAmB,GAAG,IAAI,GAAJ,EAA5B;AAEA,EAAA,KAAK,CAAC,eAAD,EAAkB;AACrB,IAAA,kBAAkB,CAAC,IAAD,EAAK;AACrB,MAAA,aAAa,CAAC,GAAd,CAAkB,IAAI,CAAC,IAAL,CAAU,KAA5B,EAAmC,IAAnC;AACD,KAHoB;;AAIrB,IAAA,cAAc,CAAC,IAAD,EAAK;AACjB,UAAI,CAAC,mBAAmB,CAAC,GAApB,CAAwB,IAAI,CAAC,IAAL,CAAU,KAAlC,CAAL,EAA+C;AAC7C,QAAA,mBAAmB,CAAC,GAApB,CAAwB,IAAI,CAAC,IAAL,CAAU,KAAlC;AACD;AACF;;AARoB,GAAlB,CAAL;AAWA,QAAM,IAAI,GAAG,IAAI,GAAJ,EAAb;AACA,EAAA,mBAAmB,CAAC,OAApB,CAA4B,IAAI,IAAG;AACjC,QAAI,CAAC,aAAa,CAAC,GAAd,CAAkB,IAAlB,CAAD,IAA4B,mBAAmB,CAAC,GAApB,CAAwB,IAAxB,CAAhC,EAA+D;AAC7D,MAAA,IAAI,CAAC,GAAL,CAAS,UAAU,CAAC,mBAAmB,CAAC,GAApB,CAAwB,IAAxB,CAAD,CAAnB;AACD;AACF,GAJD;AAMA,QAAM,mBAAmB,GAA6B,EAAtD;AAEA,EAAA,IAAI,CAAC,OAAL,CAAa,GAAG,IAAG;AACjB,IAAA,KAAK,CAAC,GAAD,EAAM;AACT,MAAA,cAAc,CAAC,IAAD,EAAK;AACjB,YACE,CAAC,mBAAmB,CAAC,GAApB,CAAwB,IAAI,CAAC,IAAL,CAAU,KAAlC,CAAD,IACA,mBAAmB,CAAC,GAApB,CAAwB,IAAI,CAAC,IAAL,CAAU,KAAlC,CAFF,EAGE;AACA,UAAA,IAAI,CAAC,GAAL,CAAS,UAAU,CAAC,mBAAmB,CAAC,GAApB,CAAwB,IAAI,CAAC,IAAL,CAAU,KAAlC,CAAD,CAAnB;AACA,UAAA,mBAAmB,CAAC,GAApB,CAAwB,IAAI,CAAC,IAAL,CAAU,KAAlC;AACD;AACF;;AATQ,KAAN,CAAL;;AAWA,QAAI,CAAC,aAAa,CAAC,GAAd,CAAkB,GAAG,CAAC,IAAJ,CAAS,KAA3B,CAAL,EAAwC;AACtC,MAAA,mBAAmB,CAAC,IAApB,CAAyB,GAAzB;AACD;AACF,GAfD;AAiBA,SAAO,mBAAP;AACD,CAjDM","sourceRoot":"","sourcesContent":["import { parse, visit } from 'graphql';\nimport nullthrows from 'nullthrows';\nexport const getFragmentDependencies = (operationString, fragmentDefinitions) => {\n    if (!fragmentDefinitions) {\n        return [];\n    }\n    let parsedOperation;\n    try {\n        parsedOperation = parse(operationString, {\n            allowLegacySDLImplementsInterfaces: true,\n            allowLegacySDLEmptyFields: true,\n        });\n    }\n    catch (error) {\n        return [];\n    }\n    return getFragmentDependenciesForAST(parsedOperation, fragmentDefinitions);\n};\nexport const getFragmentDependenciesForAST = (parsedOperation, fragmentDefinitions) => {\n    if (!fragmentDefinitions) {\n        return [];\n    }\n    const existingFrags = new Map();\n    const referencedFragNames = new Set();\n    visit(parsedOperation, {\n        FragmentDefinition(node) {\n            existingFrags.set(node.name.value, true);\n        },\n        FragmentSpread(node) {\n            if (!referencedFragNames.has(node.name.value)) {\n                referencedFragNames.add(node.name.value);\n            }\n        },\n    });\n    const asts = new Set();\n    referencedFragNames.forEach(name => {\n        if (!existingFrags.has(name) && fragmentDefinitions.has(name)) {\n            asts.add(nullthrows(fragmentDefinitions.get(name)));\n        }\n    });\n    const referencedFragments = [];\n    asts.forEach(ast => {\n        visit(ast, {\n            FragmentSpread(node) {\n                if (!referencedFragNames.has(node.name.value) &&\n                    fragmentDefinitions.get(node.name.value)) {\n                    asts.add(nullthrows(fragmentDefinitions.get(node.name.value)));\n                    referencedFragNames.add(node.name.value);\n                }\n            },\n        });\n        if (!existingFrags.has(ast.name.value)) {\n            referencedFragments.push(ast);\n        }\n    });\n    return referencedFragments;\n};\n//# sourceMappingURL=fragmentDependencies.js.map"]},"metadata":{},"sourceType":"module"}