{"ast":null,"code":"export default class CharacterStream {\n  constructor(sourceText) {\n    this.getStartOfToken = () => this._start;\n\n    this.getCurrentPosition = () => this._pos;\n\n    this.eol = () => this._sourceText.length === this._pos;\n\n    this.sol = () => this._pos === 0;\n\n    this.peek = () => {\n      return this._sourceText.charAt(this._pos) ? this._sourceText.charAt(this._pos) : null;\n    };\n\n    this.next = () => {\n      const char = this._sourceText.charAt(this._pos);\n\n      this._pos++;\n      return char;\n    };\n\n    this.eat = pattern => {\n      const isMatched = this._testNextCharacter(pattern);\n\n      if (isMatched) {\n        this._start = this._pos;\n        this._pos++;\n        return this._sourceText.charAt(this._pos - 1);\n      }\n\n      return undefined;\n    };\n\n    this.eatWhile = match => {\n      let isMatched = this._testNextCharacter(match);\n\n      let didEat = false;\n\n      if (isMatched) {\n        didEat = isMatched;\n        this._start = this._pos;\n      }\n\n      while (isMatched) {\n        this._pos++;\n        isMatched = this._testNextCharacter(match);\n        didEat = true;\n      }\n\n      return didEat;\n    };\n\n    this.eatSpace = () => this.eatWhile(/[\\s\\u00a0]/);\n\n    this.skipToEnd = () => {\n      this._pos = this._sourceText.length;\n    };\n\n    this.skipTo = position => {\n      this._pos = position;\n    };\n\n    this.match = (pattern, consume = true, caseFold = false) => {\n      let token = null;\n      let match = null;\n\n      if (typeof pattern === 'string') {\n        const regex = new RegExp(pattern, caseFold ? 'i' : 'g');\n        match = regex.test(this._sourceText.substr(this._pos, pattern.length));\n        token = pattern;\n      } else if (pattern instanceof RegExp) {\n        match = this._sourceText.slice(this._pos).match(pattern);\n        token = match && match[0];\n      }\n\n      if (match != null) {\n        if (typeof pattern === 'string' || match instanceof Array && this._sourceText.startsWith(match[0], this._pos)) {\n          if (consume) {\n            this._start = this._pos;\n\n            if (token && token.length) {\n              this._pos += token.length;\n            }\n          }\n\n          return match;\n        }\n      }\n\n      return false;\n    };\n\n    this.backUp = num => {\n      this._pos -= num;\n    };\n\n    this.column = () => this._pos;\n\n    this.indentation = () => {\n      const match = this._sourceText.match(/\\s*/);\n\n      let indent = 0;\n\n      if (match && match.length !== 0) {\n        const whitespaces = match[0];\n        let pos = 0;\n\n        while (whitespaces.length > pos) {\n          if (whitespaces.charCodeAt(pos) === 9) {\n            indent += 2;\n          } else {\n            indent++;\n          }\n\n          pos++;\n        }\n      }\n\n      return indent;\n    };\n\n    this.current = () => this._sourceText.slice(this._start, this._pos);\n\n    this._start = 0;\n    this._pos = 0;\n    this._sourceText = sourceText;\n  }\n\n  _testNextCharacter(pattern) {\n    const character = this._sourceText.charAt(this._pos);\n\n    let isMatched = false;\n\n    if (typeof pattern === 'string') {\n      isMatched = character === pattern;\n    } else {\n      isMatched = pattern instanceof RegExp ? pattern.test(character) : pattern(character);\n    }\n\n    return isMatched;\n  }\n\n}","map":{"version":3,"sources":["../src/CharacterStream.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["export default class CharacterStream {\n    constructor(sourceText) {\n        this.getStartOfToken = () => this._start;\n        this.getCurrentPosition = () => this._pos;\n        this.eol = () => this._sourceText.length === this._pos;\n        this.sol = () => this._pos === 0;\n        this.peek = () => {\n            return this._sourceText.charAt(this._pos)\n                ? this._sourceText.charAt(this._pos)\n                : null;\n        };\n        this.next = () => {\n            const char = this._sourceText.charAt(this._pos);\n            this._pos++;\n            return char;\n        };\n        this.eat = (pattern) => {\n            const isMatched = this._testNextCharacter(pattern);\n            if (isMatched) {\n                this._start = this._pos;\n                this._pos++;\n                return this._sourceText.charAt(this._pos - 1);\n            }\n            return undefined;\n        };\n        this.eatWhile = (match) => {\n            let isMatched = this._testNextCharacter(match);\n            let didEat = false;\n            if (isMatched) {\n                didEat = isMatched;\n                this._start = this._pos;\n            }\n            while (isMatched) {\n                this._pos++;\n                isMatched = this._testNextCharacter(match);\n                didEat = true;\n            }\n            return didEat;\n        };\n        this.eatSpace = () => this.eatWhile(/[\\s\\u00a0]/);\n        this.skipToEnd = () => {\n            this._pos = this._sourceText.length;\n        };\n        this.skipTo = (position) => {\n            this._pos = position;\n        };\n        this.match = (pattern, consume = true, caseFold = false) => {\n            let token = null;\n            let match = null;\n            if (typeof pattern === 'string') {\n                const regex = new RegExp(pattern, caseFold ? 'i' : 'g');\n                match = regex.test(this._sourceText.substr(this._pos, pattern.length));\n                token = pattern;\n            }\n            else if (pattern instanceof RegExp) {\n                match = this._sourceText.slice(this._pos).match(pattern);\n                token = match && match[0];\n            }\n            if (match != null) {\n                if (typeof pattern === 'string' ||\n                    (match instanceof Array &&\n                        this._sourceText.startsWith(match[0], this._pos))) {\n                    if (consume) {\n                        this._start = this._pos;\n                        if (token && token.length) {\n                            this._pos += token.length;\n                        }\n                    }\n                    return match;\n                }\n            }\n            return false;\n        };\n        this.backUp = (num) => {\n            this._pos -= num;\n        };\n        this.column = () => this._pos;\n        this.indentation = () => {\n            const match = this._sourceText.match(/\\s*/);\n            let indent = 0;\n            if (match && match.length !== 0) {\n                const whitespaces = match[0];\n                let pos = 0;\n                while (whitespaces.length > pos) {\n                    if (whitespaces.charCodeAt(pos) === 9) {\n                        indent += 2;\n                    }\n                    else {\n                        indent++;\n                    }\n                    pos++;\n                }\n            }\n            return indent;\n        };\n        this.current = () => this._sourceText.slice(this._start, this._pos);\n        this._start = 0;\n        this._pos = 0;\n        this._sourceText = sourceText;\n    }\n    _testNextCharacter(pattern) {\n        const character = this._sourceText.charAt(this._pos);\n        let isMatched = false;\n        if (typeof pattern === 'string') {\n            isMatched = character === pattern;\n        }\n        else {\n            isMatched =\n                pattern instanceof RegExp\n                    ? pattern.test(character)\n                    : pattern(character);\n        }\n        return isMatched;\n    }\n}\n//# sourceMappingURL=CharacterStream.js.map"]},"metadata":{},"sourceType":"module"}