{"ast":null,"code":"const Backoff = require('backoff');\n\nconst EventEmitter = require('events');\n\nconst inherits = require('util').inherits;\n\nconst WebSocket = global.WebSocket || require('ws');\n\nconst Subprovider = require('./subprovider');\n\nconst createPayload = require('../util/create-payload');\n\nclass WebsocketSubprovider extends Subprovider {\n  constructor({\n    rpcUrl,\n    debug,\n    origin\n  }) {\n    super(); // inherit from EventEmitter\n\n    EventEmitter.call(this);\n    Object.defineProperties(this, {\n      _backoff: {\n        value: Backoff.exponential({\n          randomisationFactor: 0.2,\n          maxDelay: 5000\n        })\n      },\n      _connectTime: {\n        value: null,\n        writable: true\n      },\n      _log: {\n        value: debug ? (...args) => console.info.apply(console, ['[WSProvider]', ...args]) : () => {}\n      },\n      _origin: {\n        value: origin\n      },\n      _pendingRequests: {\n        value: new Map()\n      },\n      _socket: {\n        value: null,\n        writable: true\n      },\n      _unhandledRequests: {\n        value: []\n      },\n      _url: {\n        value: rpcUrl\n      }\n    });\n    this._handleSocketClose = this._handleSocketClose.bind(this);\n    this._handleSocketMessage = this._handleSocketMessage.bind(this);\n    this._handleSocketOpen = this._handleSocketOpen.bind(this); // Called when a backoff timeout has finished. Time to try reconnecting.\n\n    this._backoff.on('ready', () => {\n      this._openSocket();\n    });\n\n    this._openSocket();\n  }\n\n  handleRequest(payload, next, end) {\n    if (!this._socket || this._socket.readyState !== WebSocket.OPEN) {\n      this._unhandledRequests.push(Array.from(arguments));\n\n      this._log('Socket not open. Request queued.');\n\n      return;\n    }\n\n    this._pendingRequests.set(payload.id, [payload, end]);\n\n    const newPayload = createPayload(payload);\n    delete newPayload.origin;\n\n    this._socket.send(JSON.stringify(newPayload));\n\n    this._log(`Sent: ${newPayload.method} #${newPayload.id}`);\n  }\n\n  _handleSocketClose({\n    reason,\n    code\n  }) {\n    this._log(`Socket closed, code ${code} (${reason || 'no reason'})`); // If the socket has been open for longer than 5 seconds, reset the backoff\n\n\n    if (this._connectTime && Date.now() - this._connectTime > 5000) {\n      this._backoff.reset();\n    }\n\n    this._socket.removeEventListener('close', this._handleSocketClose);\n\n    this._socket.removeEventListener('message', this._handleSocketMessage);\n\n    this._socket.removeEventListener('open', this._handleSocketOpen);\n\n    this._socket = null;\n\n    this._backoff.backoff();\n  }\n\n  _handleSocketMessage(message) {\n    let payload;\n\n    try {\n      payload = JSON.parse(message.data);\n    } catch (e) {\n      this._log('Received a message that is not valid JSON:', payload);\n\n      return;\n    } // check if server-sent notification\n\n\n    if (payload.id === undefined) {\n      return this.engine.emit('data', null, payload);\n    } // ignore if missing\n\n\n    if (!this._pendingRequests.has(payload.id)) {\n      return;\n    } // retrieve payload + arguments\n\n\n    const [originalReq, end] = this._pendingRequests.get(payload.id);\n\n    this._pendingRequests.delete(payload.id);\n\n    this._log(`Received: ${originalReq.method} #${payload.id}`); // forward response\n\n\n    if (payload.error) {\n      return end(new Error(payload.error.message));\n    }\n\n    end(null, payload.result);\n  }\n\n  _handleSocketOpen() {\n    this._log('Socket open.');\n\n    this._connectTime = Date.now(); // Any pending requests need to be resent because our session was lost\n    // and will not get responses for them in our new session.\n\n    this._pendingRequests.forEach(([payload, end]) => {\n      this._unhandledRequests.push([payload, null, end]);\n    });\n\n    this._pendingRequests.clear();\n\n    const unhandledRequests = this._unhandledRequests.splice(0, this._unhandledRequests.length);\n\n    unhandledRequests.forEach(request => {\n      this.handleRequest.apply(this, request);\n    });\n  }\n\n  _openSocket() {\n    this._log('Opening socket...');\n\n    this._socket = new WebSocket(this._url, [], this._origin ? {\n      headers: {\n        origin: this._origin\n      }\n    } : {});\n\n    this._socket.addEventListener('close', this._handleSocketClose);\n\n    this._socket.addEventListener('message', this._handleSocketMessage);\n\n    this._socket.addEventListener('open', this._handleSocketOpen);\n  }\n\n} // multiple inheritance\n\n\nObject.assign(WebsocketSubprovider.prototype, EventEmitter.prototype);\nmodule.exports = WebsocketSubprovider;","map":{"version":3,"sources":["/Users/chrisbuonocore/personal/hackathons/hackfs21/node_modules/burner-provider/node_modules/web3-provider-engine/subproviders/websocket.js"],"names":["Backoff","require","EventEmitter","inherits","WebSocket","global","Subprovider","createPayload","WebsocketSubprovider","constructor","rpcUrl","debug","origin","call","Object","defineProperties","_backoff","value","exponential","randomisationFactor","maxDelay","_connectTime","writable","_log","args","console","info","apply","_origin","_pendingRequests","Map","_socket","_unhandledRequests","_url","_handleSocketClose","bind","_handleSocketMessage","_handleSocketOpen","on","_openSocket","handleRequest","payload","next","end","readyState","OPEN","push","Array","from","arguments","set","id","newPayload","send","JSON","stringify","method","reason","code","Date","now","reset","removeEventListener","backoff","message","parse","data","e","undefined","engine","emit","has","originalReq","get","delete","error","Error","result","forEach","clear","unhandledRequests","splice","length","request","headers","addEventListener","assign","prototype","module","exports"],"mappings":"AAAA,MAAMA,OAAO,GAAGC,OAAO,CAAC,SAAD,CAAvB;;AACA,MAAMC,YAAY,GAAGD,OAAO,CAAC,QAAD,CAA5B;;AACA,MAAME,QAAQ,GAAGF,OAAO,CAAC,MAAD,CAAP,CAAgBE,QAAjC;;AACA,MAAMC,SAAS,GAAGC,MAAM,CAACD,SAAP,IAAoBH,OAAO,CAAC,IAAD,CAA7C;;AACA,MAAMK,WAAW,GAAGL,OAAO,CAAC,eAAD,CAA3B;;AACA,MAAMM,aAAa,GAAGN,OAAO,CAAC,wBAAD,CAA7B;;AAEA,MAAMO,oBAAN,SACSF,WADT,CACqB;AACnBG,EAAAA,WAAW,CAAC;AAAEC,IAAAA,MAAF;AAAUC,IAAAA,KAAV;AAAiBC,IAAAA;AAAjB,GAAD,EAA4B;AACrC,YADqC,CAGrC;;AACAV,IAAAA,YAAY,CAACW,IAAb,CAAkB,IAAlB;AAEAC,IAAAA,MAAM,CAACC,gBAAP,CAAwB,IAAxB,EAA8B;AAC5BC,MAAAA,QAAQ,EAAE;AACRC,QAAAA,KAAK,EAAEjB,OAAO,CAACkB,WAAR,CAAoB;AACzBC,UAAAA,mBAAmB,EAAE,GADI;AAEzBC,UAAAA,QAAQ,EAAE;AAFe,SAApB;AADC,OADkB;AAO5BC,MAAAA,YAAY,EAAE;AACZJ,QAAAA,KAAK,EAAE,IADK;AAEZK,QAAAA,QAAQ,EAAE;AAFE,OAPc;AAW5BC,MAAAA,IAAI,EAAE;AACJN,QAAAA,KAAK,EAAEN,KAAK,GACR,CAAC,GAAGa,IAAJ,KAAaC,OAAO,CAACC,IAAR,CAAaC,KAAb,CAAmBF,OAAnB,EAA4B,CAAC,cAAD,EAAiB,GAAGD,IAApB,CAA5B,CADL,GAER,MAAM,CAAG;AAHT,OAXsB;AAgB5BI,MAAAA,OAAO,EAAE;AACPX,QAAAA,KAAK,EAAEL;AADA,OAhBmB;AAmB5BiB,MAAAA,gBAAgB,EAAE;AAChBZ,QAAAA,KAAK,EAAE,IAAIa,GAAJ;AADS,OAnBU;AAsB5BC,MAAAA,OAAO,EAAE;AACPd,QAAAA,KAAK,EAAE,IADA;AAEPK,QAAAA,QAAQ,EAAE;AAFH,OAtBmB;AA0B5BU,MAAAA,kBAAkB,EAAE;AAClBf,QAAAA,KAAK,EAAE;AADW,OA1BQ;AA6B5BgB,MAAAA,IAAI,EAAE;AACJhB,QAAAA,KAAK,EAAEP;AADH;AA7BsB,KAA9B;AAkCA,SAAKwB,kBAAL,GAA0B,KAAKA,kBAAL,CAAwBC,IAAxB,CAA6B,IAA7B,CAA1B;AACA,SAAKC,oBAAL,GAA4B,KAAKA,oBAAL,CAA0BD,IAA1B,CAA+B,IAA/B,CAA5B;AACA,SAAKE,iBAAL,GAAyB,KAAKA,iBAAL,CAAuBF,IAAvB,CAA4B,IAA5B,CAAzB,CA1CqC,CA4CrC;;AACA,SAAKnB,QAAL,CAAcsB,EAAd,CAAiB,OAAjB,EAA0B,MAAM;AAC9B,WAAKC,WAAL;AACD,KAFD;;AAIA,SAAKA,WAAL;AACD;;AAEDC,EAAAA,aAAa,CAACC,OAAD,EAAUC,IAAV,EAAgBC,GAAhB,EAAqB;AAChC,QAAI,CAAC,KAAKZ,OAAN,IAAiB,KAAKA,OAAL,CAAaa,UAAb,KAA4BxC,SAAS,CAACyC,IAA3D,EAAiE;AAC/D,WAAKb,kBAAL,CAAwBc,IAAxB,CAA6BC,KAAK,CAACC,IAAN,CAAWC,SAAX,CAA7B;;AACA,WAAK1B,IAAL,CAAU,kCAAV;;AACA;AACD;;AAED,SAAKM,gBAAL,CAAsBqB,GAAtB,CAA0BT,OAAO,CAACU,EAAlC,EAAsC,CAACV,OAAD,EAAUE,GAAV,CAAtC;;AAEA,UAAMS,UAAU,GAAG7C,aAAa,CAACkC,OAAD,CAAhC;AACA,WAAOW,UAAU,CAACxC,MAAlB;;AAEA,SAAKmB,OAAL,CAAasB,IAAb,CAAkBC,IAAI,CAACC,SAAL,CAAeH,UAAf,CAAlB;;AACA,SAAK7B,IAAL,CAAW,SAAQ6B,UAAU,CAACI,MAAO,KAAIJ,UAAU,CAACD,EAAG,EAAvD;AACD;;AAEDjB,EAAAA,kBAAkB,CAAC;AAAEuB,IAAAA,MAAF;AAAUC,IAAAA;AAAV,GAAD,EAAmB;AACnC,SAAKnC,IAAL,CAAW,uBAAsBmC,IAAK,KAAID,MAAM,IAAI,WAAY,GAAhE,EADmC,CAEnC;;;AACA,QAAI,KAAKpC,YAAL,IAAqBsC,IAAI,CAACC,GAAL,KAAa,KAAKvC,YAAlB,GAAiC,IAA1D,EAAgE;AAC9D,WAAKL,QAAL,CAAc6C,KAAd;AACD;;AAED,SAAK9B,OAAL,CAAa+B,mBAAb,CAAiC,OAAjC,EAA0C,KAAK5B,kBAA/C;;AACA,SAAKH,OAAL,CAAa+B,mBAAb,CAAiC,SAAjC,EAA4C,KAAK1B,oBAAjD;;AACA,SAAKL,OAAL,CAAa+B,mBAAb,CAAiC,MAAjC,EAAyC,KAAKzB,iBAA9C;;AAEA,SAAKN,OAAL,GAAe,IAAf;;AACA,SAAKf,QAAL,CAAc+C,OAAd;AACD;;AAED3B,EAAAA,oBAAoB,CAAC4B,OAAD,EAAU;AAC5B,QAAIvB,OAAJ;;AAEA,QAAI;AACFA,MAAAA,OAAO,GAAGa,IAAI,CAACW,KAAL,CAAWD,OAAO,CAACE,IAAnB,CAAV;AACD,KAFD,CAEE,OAAOC,CAAP,EAAU;AACV,WAAK5C,IAAL,CAAU,4CAAV,EAAwDkB,OAAxD;;AACA;AACD,KAR2B,CAU5B;;;AACA,QAAIA,OAAO,CAACU,EAAR,KAAeiB,SAAnB,EAA8B;AAC5B,aAAO,KAAKC,MAAL,CAAYC,IAAZ,CAAiB,MAAjB,EAAyB,IAAzB,EAA+B7B,OAA/B,CAAP;AACD,KAb2B,CAe5B;;;AACA,QAAI,CAAC,KAAKZ,gBAAL,CAAsB0C,GAAtB,CAA0B9B,OAAO,CAACU,EAAlC,CAAL,EAA4C;AAC1C;AACD,KAlB2B,CAoB5B;;;AACA,UAAM,CAACqB,WAAD,EAAc7B,GAAd,IAAqB,KAAKd,gBAAL,CAAsB4C,GAAtB,CAA0BhC,OAAO,CAACU,EAAlC,CAA3B;;AACA,SAAKtB,gBAAL,CAAsB6C,MAAtB,CAA6BjC,OAAO,CAACU,EAArC;;AAEA,SAAK5B,IAAL,CAAW,aAAYiD,WAAW,CAAChB,MAAO,KAAIf,OAAO,CAACU,EAAG,EAAzD,EAxB4B,CA0B5B;;;AACA,QAAIV,OAAO,CAACkC,KAAZ,EAAmB;AACjB,aAAOhC,GAAG,CAAC,IAAIiC,KAAJ,CAAUnC,OAAO,CAACkC,KAAR,CAAcX,OAAxB,CAAD,CAAV;AACD;;AACDrB,IAAAA,GAAG,CAAC,IAAD,EAAOF,OAAO,CAACoC,MAAf,CAAH;AACD;;AAEDxC,EAAAA,iBAAiB,GAAG;AAClB,SAAKd,IAAL,CAAU,cAAV;;AACA,SAAKF,YAAL,GAAoBsC,IAAI,CAACC,GAAL,EAApB,CAFkB,CAIlB;AACA;;AACA,SAAK/B,gBAAL,CAAsBiD,OAAtB,CAA8B,CAAC,CAACrC,OAAD,EAAUE,GAAV,CAAD,KAAoB;AAChD,WAAKX,kBAAL,CAAwBc,IAAxB,CAA6B,CAACL,OAAD,EAAU,IAAV,EAAgBE,GAAhB,CAA7B;AACD,KAFD;;AAGA,SAAKd,gBAAL,CAAsBkD,KAAtB;;AAEA,UAAMC,iBAAiB,GAAG,KAAKhD,kBAAL,CAAwBiD,MAAxB,CAA+B,CAA/B,EAAkC,KAAKjD,kBAAL,CAAwBkD,MAA1D,CAA1B;;AACAF,IAAAA,iBAAiB,CAACF,OAAlB,CAA0BK,OAAO,IAAI;AACnC,WAAK3C,aAAL,CAAmBb,KAAnB,CAAyB,IAAzB,EAA+BwD,OAA/B;AACD,KAFD;AAGD;;AAED5C,EAAAA,WAAW,GAAG;AACZ,SAAKhB,IAAL,CAAU,mBAAV;;AACA,SAAKQ,OAAL,GAAe,IAAI3B,SAAJ,CAAc,KAAK6B,IAAnB,EAAyB,EAAzB,EAA6B,KAAKL,OAAL,GAAe;AAACwD,MAAAA,OAAO,EAAC;AAACxE,QAAAA,MAAM,EAAE,KAAKgB;AAAd;AAAT,KAAf,GAAkD,EAA/E,CAAf;;AACA,SAAKG,OAAL,CAAasD,gBAAb,CAA8B,OAA9B,EAAuC,KAAKnD,kBAA5C;;AACA,SAAKH,OAAL,CAAasD,gBAAb,CAA8B,SAA9B,EAAyC,KAAKjD,oBAA9C;;AACA,SAAKL,OAAL,CAAasD,gBAAb,CAA8B,MAA9B,EAAsC,KAAKhD,iBAA3C;AACD;;AA5IkB,C,CA+IrB;;;AACAvB,MAAM,CAACwE,MAAP,CAAc9E,oBAAoB,CAAC+E,SAAnC,EAA8CrF,YAAY,CAACqF,SAA3D;AAEAC,MAAM,CAACC,OAAP,GAAiBjF,oBAAjB","sourcesContent":["const Backoff = require('backoff')\nconst EventEmitter = require('events')\nconst inherits = require('util').inherits\nconst WebSocket = global.WebSocket || require('ws')\nconst Subprovider = require('./subprovider')\nconst createPayload = require('../util/create-payload')\n\nclass WebsocketSubprovider\n extends Subprovider {\n  constructor({ rpcUrl, debug, origin }) {\n    super()\n\n    // inherit from EventEmitter\n    EventEmitter.call(this)\n\n    Object.defineProperties(this, {\n      _backoff: {\n        value: Backoff.exponential({\n          randomisationFactor: 0.2,\n          maxDelay: 5000\n        })\n      },\n      _connectTime: {\n        value: null,\n        writable: true\n      },\n      _log: {\n        value: debug\n          ? (...args) => console.info.apply(console, ['[WSProvider]', ...args])\n          : () => { }\n      },\n      _origin: {\n        value: origin\n      },\n      _pendingRequests: {\n        value: new Map()\n      },\n      _socket: {\n        value: null,\n        writable: true\n      },\n      _unhandledRequests: {\n        value: []\n      },\n      _url: {\n        value: rpcUrl\n      }\n    })\n\n    this._handleSocketClose = this._handleSocketClose.bind(this)\n    this._handleSocketMessage = this._handleSocketMessage.bind(this)\n    this._handleSocketOpen = this._handleSocketOpen.bind(this)\n\n    // Called when a backoff timeout has finished. Time to try reconnecting.\n    this._backoff.on('ready', () => {\n      this._openSocket()\n    })\n\n    this._openSocket()\n  }\n\n  handleRequest(payload, next, end) {\n    if (!this._socket || this._socket.readyState !== WebSocket.OPEN) {\n      this._unhandledRequests.push(Array.from(arguments))\n      this._log('Socket not open. Request queued.')\n      return\n    }\n\n    this._pendingRequests.set(payload.id, [payload, end])\n\n    const newPayload = createPayload(payload)\n    delete newPayload.origin\n\n    this._socket.send(JSON.stringify(newPayload))\n    this._log(`Sent: ${newPayload.method} #${newPayload.id}`)\n  }\n\n  _handleSocketClose({ reason, code }) {\n    this._log(`Socket closed, code ${code} (${reason || 'no reason'})`)\n    // If the socket has been open for longer than 5 seconds, reset the backoff\n    if (this._connectTime && Date.now() - this._connectTime > 5000) {\n      this._backoff.reset()\n    }\n\n    this._socket.removeEventListener('close', this._handleSocketClose)\n    this._socket.removeEventListener('message', this._handleSocketMessage)\n    this._socket.removeEventListener('open', this._handleSocketOpen)\n\n    this._socket = null\n    this._backoff.backoff()\n  }\n\n  _handleSocketMessage(message) {\n    let payload\n\n    try {\n      payload = JSON.parse(message.data)\n    } catch (e) {\n      this._log('Received a message that is not valid JSON:', payload)\n      return\n    }\n\n    // check if server-sent notification\n    if (payload.id === undefined) {\n      return this.engine.emit('data', null, payload)\n    }\n\n    // ignore if missing\n    if (!this._pendingRequests.has(payload.id)) {\n      return\n    }\n\n    // retrieve payload + arguments\n    const [originalReq, end] = this._pendingRequests.get(payload.id)\n    this._pendingRequests.delete(payload.id)\n\n    this._log(`Received: ${originalReq.method} #${payload.id}`)\n\n    // forward response\n    if (payload.error) {\n      return end(new Error(payload.error.message))\n    }\n    end(null, payload.result)\n  }\n\n  _handleSocketOpen() {\n    this._log('Socket open.')\n    this._connectTime = Date.now()\n\n    // Any pending requests need to be resent because our session was lost\n    // and will not get responses for them in our new session.\n    this._pendingRequests.forEach(([payload, end]) => {\n      this._unhandledRequests.push([payload, null, end])\n    })\n    this._pendingRequests.clear()\n\n    const unhandledRequests = this._unhandledRequests.splice(0, this._unhandledRequests.length)\n    unhandledRequests.forEach(request => {\n      this.handleRequest.apply(this, request)\n    })\n  }\n\n  _openSocket() {\n    this._log('Opening socket...')\n    this._socket = new WebSocket(this._url, [], this._origin ? {headers:{origin: this._origin}} : {})\n    this._socket.addEventListener('close', this._handleSocketClose)\n    this._socket.addEventListener('message', this._handleSocketMessage)\n    this._socket.addEventListener('open', this._handleSocketOpen)\n  }\n}\n\n// multiple inheritance\nObject.assign(WebsocketSubprovider.prototype, EventEmitter.prototype)\n\nmodule.exports = WebsocketSubprovider\n"]},"metadata":{},"sourceType":"script"}