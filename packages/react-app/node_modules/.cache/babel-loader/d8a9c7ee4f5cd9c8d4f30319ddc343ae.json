{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport { SymbolKind } from 'vscode-languageserver-types';\nimport { Kind, parse, print } from 'graphql';\nimport { getAutocompleteSuggestions } from './getAutocompleteSuggestions';\nimport { getHoverInformation } from './getHoverInformation';\nimport { validateQuery, getRange, DIAGNOSTIC_SEVERITY } from './getDiagnostics';\nimport { getDefinitionQueryResultForFragmentSpread, getDefinitionQueryResultForDefinitionNode, getDefinitionQueryResultForNamedType } from './getDefinition';\nimport { getOutline } from './getOutline';\nimport { getASTNodeAtPosition } from 'graphql-language-service-utils';\nconst {\n  FRAGMENT_DEFINITION,\n  OBJECT_TYPE_DEFINITION,\n  INTERFACE_TYPE_DEFINITION,\n  ENUM_TYPE_DEFINITION,\n  UNION_TYPE_DEFINITION,\n  SCALAR_TYPE_DEFINITION,\n  INPUT_OBJECT_TYPE_DEFINITION,\n  SCALAR_TYPE_EXTENSION,\n  OBJECT_TYPE_EXTENSION,\n  INTERFACE_TYPE_EXTENSION,\n  UNION_TYPE_EXTENSION,\n  ENUM_TYPE_EXTENSION,\n  INPUT_OBJECT_TYPE_EXTENSION,\n  DIRECTIVE_DEFINITION,\n  FRAGMENT_SPREAD,\n  OPERATION_DEFINITION,\n  NAMED_TYPE\n} = Kind;\nconst KIND_TO_SYMBOL_KIND = {\n  [Kind.FIELD]: SymbolKind.Field,\n  [Kind.OPERATION_DEFINITION]: SymbolKind.Class,\n  [Kind.FRAGMENT_DEFINITION]: SymbolKind.Class,\n  [Kind.FRAGMENT_SPREAD]: SymbolKind.Struct,\n  [Kind.OBJECT_TYPE_DEFINITION]: SymbolKind.Class,\n  [Kind.ENUM_TYPE_DEFINITION]: SymbolKind.Enum,\n  [Kind.ENUM_VALUE_DEFINITION]: SymbolKind.EnumMember,\n  [Kind.INPUT_OBJECT_TYPE_DEFINITION]: SymbolKind.Class,\n  [Kind.INPUT_VALUE_DEFINITION]: SymbolKind.Field,\n  [Kind.FIELD_DEFINITION]: SymbolKind.Field,\n  [Kind.INTERFACE_TYPE_DEFINITION]: SymbolKind.Interface,\n  [Kind.DOCUMENT]: SymbolKind.File,\n  FieldWithArguments: SymbolKind.Method\n};\n\nfunction getKind(tree) {\n  if (tree.kind === 'FieldDefinition' && tree.children && tree.children.length > 0) {\n    return KIND_TO_SYMBOL_KIND.FieldWithArguments;\n  }\n\n  return KIND_TO_SYMBOL_KIND[tree.kind];\n}\n\nexport class GraphQLLanguageService {\n  constructor(cache) {\n    this._graphQLCache = cache;\n    this._graphQLConfig = cache.getGraphQLConfig();\n  }\n\n  getConfigForURI(uri) {\n    const config = this._graphQLCache.getProjectForFile(uri);\n\n    if (config) {\n      return config;\n    }\n\n    throw Error(`No config found for uri: ${uri}`);\n  }\n\n  getDiagnostics(query, uri, isRelayCompatMode) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let queryHasExtensions = false;\n      const projectConfig = this.getConfigForURI(uri);\n\n      if (!projectConfig) {\n        return [];\n      }\n\n      const {\n        schema: schemaPath,\n        name: projectName,\n        extensions\n      } = projectConfig;\n\n      try {\n        const queryAST = parse(query);\n\n        if (!schemaPath || uri !== schemaPath) {\n          queryHasExtensions = queryAST.definitions.some(definition => {\n            switch (definition.kind) {\n              case OBJECT_TYPE_DEFINITION:\n              case INTERFACE_TYPE_DEFINITION:\n              case ENUM_TYPE_DEFINITION:\n              case UNION_TYPE_DEFINITION:\n              case SCALAR_TYPE_DEFINITION:\n              case INPUT_OBJECT_TYPE_DEFINITION:\n              case SCALAR_TYPE_EXTENSION:\n              case OBJECT_TYPE_EXTENSION:\n              case INTERFACE_TYPE_EXTENSION:\n              case UNION_TYPE_EXTENSION:\n              case ENUM_TYPE_EXTENSION:\n              case INPUT_OBJECT_TYPE_EXTENSION:\n              case DIRECTIVE_DEFINITION:\n                return true;\n            }\n\n            return false;\n          });\n        }\n      } catch (error) {\n        const range = getRange(error.locations[0], query);\n        return [{\n          severity: DIAGNOSTIC_SEVERITY.Error,\n          message: error.message,\n          source: 'GraphQL: Syntax',\n          range\n        }];\n      }\n\n      let source = query;\n      const fragmentDefinitions = yield this._graphQLCache.getFragmentDefinitions(projectConfig);\n      const fragmentDependencies = yield this._graphQLCache.getFragmentDependencies(query, fragmentDefinitions);\n      const dependenciesSource = fragmentDependencies.reduce((prev, cur) => `${prev} ${print(cur.definition)}`, '');\n      source = `${source} ${dependenciesSource}`;\n      let validationAst = null;\n\n      try {\n        validationAst = parse(source);\n      } catch (error) {\n        return [];\n      }\n\n      let customRules = null;\n\n      if ((extensions === null || extensions === void 0 ? void 0 : extensions.customValidationRules) && typeof extensions.customValidationRules === 'function') {\n        customRules = extensions.customValidationRules(this._graphQLConfig);\n      }\n\n      const schema = yield this._graphQLCache.getSchema(projectName, queryHasExtensions);\n\n      if (!schema) {\n        return [];\n      }\n\n      return validateQuery(validationAst, schema, customRules, isRelayCompatMode);\n    });\n  }\n\n  getAutocompleteSuggestions(query, position, filePath) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const projectConfig = this.getConfigForURI(filePath);\n      const schema = yield this._graphQLCache.getSchema(projectConfig.name);\n      const fragmentDefinitions = yield this._graphQLCache.getFragmentDefinitions(projectConfig);\n      const fragmentInfo = Array.from(fragmentDefinitions).map(([, info]) => info.definition);\n\n      if (schema) {\n        return getAutocompleteSuggestions(schema, query, position, undefined, fragmentInfo);\n      }\n\n      return [];\n    });\n  }\n\n  getHoverInformation(query, position, filePath) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const projectConfig = this.getConfigForURI(filePath);\n      const schema = yield this._graphQLCache.getSchema(projectConfig.name);\n\n      if (schema) {\n        return getHoverInformation(schema, query, position);\n      }\n\n      return '';\n    });\n  }\n\n  getDefinition(query, position, filePath) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const projectConfig = this.getConfigForURI(filePath);\n      let ast;\n\n      try {\n        ast = parse(query);\n      } catch (error) {\n        return null;\n      }\n\n      const node = getASTNodeAtPosition(query, ast, position);\n\n      if (node) {\n        switch (node.kind) {\n          case FRAGMENT_SPREAD:\n            return this._getDefinitionForFragmentSpread(query, ast, node, filePath, projectConfig);\n\n          case FRAGMENT_DEFINITION:\n          case OPERATION_DEFINITION:\n            return getDefinitionQueryResultForDefinitionNode(filePath, query, node);\n\n          case NAMED_TYPE:\n            return this._getDefinitionForNamedType(query, ast, node, filePath, projectConfig);\n        }\n      }\n\n      return null;\n    });\n  }\n\n  getDocumentSymbols(document, filePath) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const outline = yield this.getOutline(document);\n\n      if (!outline) {\n        return [];\n      }\n\n      const output = [];\n      const input = outline.outlineTrees.map(tree => [null, tree]);\n\n      while (input.length > 0) {\n        const res = input.pop();\n\n        if (!res) {\n          return [];\n        }\n\n        const [parent, tree] = res;\n\n        if (!tree) {\n          return [];\n        }\n\n        output.push({\n          name: tree.representativeName,\n          kind: getKind(tree),\n          location: {\n            uri: filePath,\n            range: {\n              start: tree.startPosition,\n              end: tree.endPosition\n            }\n          },\n          containerName: parent ? parent.representativeName : undefined\n        });\n        input.push(...tree.children.map(child => [tree, child]));\n      }\n\n      return output;\n    });\n  }\n\n  _getDefinitionForNamedType(query, ast, node, filePath, projectConfig) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const objectTypeDefinitions = yield this._graphQLCache.getObjectTypeDefinitions(projectConfig);\n      const dependencies = yield this._graphQLCache.getObjectTypeDependenciesForAST(ast, objectTypeDefinitions);\n      const localObjectTypeDefinitions = ast.definitions.filter(definition => definition.kind === OBJECT_TYPE_DEFINITION || definition.kind === INPUT_OBJECT_TYPE_DEFINITION || definition.kind === ENUM_TYPE_DEFINITION || definition.kind === SCALAR_TYPE_DEFINITION || definition.kind === INTERFACE_TYPE_DEFINITION);\n      const typeCastedDefs = localObjectTypeDefinitions;\n      const localOperationDefinationInfos = typeCastedDefs.map(definition => ({\n        filePath,\n        content: query,\n        definition\n      }));\n      const result = yield getDefinitionQueryResultForNamedType(query, node, dependencies.concat(localOperationDefinationInfos));\n      return result;\n    });\n  }\n\n  _getDefinitionForFragmentSpread(query, ast, node, filePath, projectConfig) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const fragmentDefinitions = yield this._graphQLCache.getFragmentDefinitions(projectConfig);\n      const dependencies = yield this._graphQLCache.getFragmentDependenciesForAST(ast, fragmentDefinitions);\n      const localFragDefinitions = ast.definitions.filter(definition => definition.kind === FRAGMENT_DEFINITION);\n      const typeCastedDefs = localFragDefinitions;\n      const localFragInfos = typeCastedDefs.map(definition => ({\n        filePath,\n        content: query,\n        definition\n      }));\n      const result = yield getDefinitionQueryResultForFragmentSpread(query, node, dependencies.concat(localFragInfos));\n      return result;\n    });\n  }\n\n  getOutline(documentText) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return getOutline(documentText);\n    });\n  }\n\n}","map":{"version":3,"sources":["../src/GraphQLLanguageService.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { SymbolKind, } from 'vscode-languageserver-types';\nimport { Kind, parse, print } from 'graphql';\nimport { getAutocompleteSuggestions } from './getAutocompleteSuggestions';\nimport { getHoverInformation } from './getHoverInformation';\nimport { validateQuery, getRange, DIAGNOSTIC_SEVERITY } from './getDiagnostics';\nimport { getDefinitionQueryResultForFragmentSpread, getDefinitionQueryResultForDefinitionNode, getDefinitionQueryResultForNamedType, } from './getDefinition';\nimport { getOutline } from './getOutline';\nimport { getASTNodeAtPosition } from 'graphql-language-service-utils';\nconst { FRAGMENT_DEFINITION, OBJECT_TYPE_DEFINITION, INTERFACE_TYPE_DEFINITION, ENUM_TYPE_DEFINITION, UNION_TYPE_DEFINITION, SCALAR_TYPE_DEFINITION, INPUT_OBJECT_TYPE_DEFINITION, SCALAR_TYPE_EXTENSION, OBJECT_TYPE_EXTENSION, INTERFACE_TYPE_EXTENSION, UNION_TYPE_EXTENSION, ENUM_TYPE_EXTENSION, INPUT_OBJECT_TYPE_EXTENSION, DIRECTIVE_DEFINITION, FRAGMENT_SPREAD, OPERATION_DEFINITION, NAMED_TYPE, } = Kind;\nconst KIND_TO_SYMBOL_KIND = {\n    [Kind.FIELD]: SymbolKind.Field,\n    [Kind.OPERATION_DEFINITION]: SymbolKind.Class,\n    [Kind.FRAGMENT_DEFINITION]: SymbolKind.Class,\n    [Kind.FRAGMENT_SPREAD]: SymbolKind.Struct,\n    [Kind.OBJECT_TYPE_DEFINITION]: SymbolKind.Class,\n    [Kind.ENUM_TYPE_DEFINITION]: SymbolKind.Enum,\n    [Kind.ENUM_VALUE_DEFINITION]: SymbolKind.EnumMember,\n    [Kind.INPUT_OBJECT_TYPE_DEFINITION]: SymbolKind.Class,\n    [Kind.INPUT_VALUE_DEFINITION]: SymbolKind.Field,\n    [Kind.FIELD_DEFINITION]: SymbolKind.Field,\n    [Kind.INTERFACE_TYPE_DEFINITION]: SymbolKind.Interface,\n    [Kind.DOCUMENT]: SymbolKind.File,\n    FieldWithArguments: SymbolKind.Method,\n};\nfunction getKind(tree) {\n    if (tree.kind === 'FieldDefinition' &&\n        tree.children &&\n        tree.children.length > 0) {\n        return KIND_TO_SYMBOL_KIND.FieldWithArguments;\n    }\n    return KIND_TO_SYMBOL_KIND[tree.kind];\n}\nexport class GraphQLLanguageService {\n    constructor(cache) {\n        this._graphQLCache = cache;\n        this._graphQLConfig = cache.getGraphQLConfig();\n    }\n    getConfigForURI(uri) {\n        const config = this._graphQLCache.getProjectForFile(uri);\n        if (config) {\n            return config;\n        }\n        throw Error(`No config found for uri: ${uri}`);\n    }\n    getDiagnostics(query, uri, isRelayCompatMode) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let queryHasExtensions = false;\n            const projectConfig = this.getConfigForURI(uri);\n            if (!projectConfig) {\n                return [];\n            }\n            const { schema: schemaPath, name: projectName, extensions } = projectConfig;\n            try {\n                const queryAST = parse(query);\n                if (!schemaPath || uri !== schemaPath) {\n                    queryHasExtensions = queryAST.definitions.some(definition => {\n                        switch (definition.kind) {\n                            case OBJECT_TYPE_DEFINITION:\n                            case INTERFACE_TYPE_DEFINITION:\n                            case ENUM_TYPE_DEFINITION:\n                            case UNION_TYPE_DEFINITION:\n                            case SCALAR_TYPE_DEFINITION:\n                            case INPUT_OBJECT_TYPE_DEFINITION:\n                            case SCALAR_TYPE_EXTENSION:\n                            case OBJECT_TYPE_EXTENSION:\n                            case INTERFACE_TYPE_EXTENSION:\n                            case UNION_TYPE_EXTENSION:\n                            case ENUM_TYPE_EXTENSION:\n                            case INPUT_OBJECT_TYPE_EXTENSION:\n                            case DIRECTIVE_DEFINITION:\n                                return true;\n                        }\n                        return false;\n                    });\n                }\n            }\n            catch (error) {\n                const range = getRange(error.locations[0], query);\n                return [\n                    {\n                        severity: DIAGNOSTIC_SEVERITY.Error,\n                        message: error.message,\n                        source: 'GraphQL: Syntax',\n                        range,\n                    },\n                ];\n            }\n            let source = query;\n            const fragmentDefinitions = yield this._graphQLCache.getFragmentDefinitions(projectConfig);\n            const fragmentDependencies = yield this._graphQLCache.getFragmentDependencies(query, fragmentDefinitions);\n            const dependenciesSource = fragmentDependencies.reduce((prev, cur) => `${prev} ${print(cur.definition)}`, '');\n            source = `${source} ${dependenciesSource}`;\n            let validationAst = null;\n            try {\n                validationAst = parse(source);\n            }\n            catch (error) {\n                return [];\n            }\n            let customRules = null;\n            if ((extensions === null || extensions === void 0 ? void 0 : extensions.customValidationRules) &&\n                typeof extensions.customValidationRules === 'function') {\n                customRules = extensions.customValidationRules(this._graphQLConfig);\n            }\n            const schema = yield this._graphQLCache.getSchema(projectName, queryHasExtensions);\n            if (!schema) {\n                return [];\n            }\n            return validateQuery(validationAst, schema, customRules, isRelayCompatMode);\n        });\n    }\n    getAutocompleteSuggestions(query, position, filePath) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const projectConfig = this.getConfigForURI(filePath);\n            const schema = yield this._graphQLCache.getSchema(projectConfig.name);\n            const fragmentDefinitions = yield this._graphQLCache.getFragmentDefinitions(projectConfig);\n            const fragmentInfo = Array.from(fragmentDefinitions).map(([, info]) => info.definition);\n            if (schema) {\n                return getAutocompleteSuggestions(schema, query, position, undefined, fragmentInfo);\n            }\n            return [];\n        });\n    }\n    getHoverInformation(query, position, filePath) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const projectConfig = this.getConfigForURI(filePath);\n            const schema = yield this._graphQLCache.getSchema(projectConfig.name);\n            if (schema) {\n                return getHoverInformation(schema, query, position);\n            }\n            return '';\n        });\n    }\n    getDefinition(query, position, filePath) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const projectConfig = this.getConfigForURI(filePath);\n            let ast;\n            try {\n                ast = parse(query);\n            }\n            catch (error) {\n                return null;\n            }\n            const node = getASTNodeAtPosition(query, ast, position);\n            if (node) {\n                switch (node.kind) {\n                    case FRAGMENT_SPREAD:\n                        return this._getDefinitionForFragmentSpread(query, ast, node, filePath, projectConfig);\n                    case FRAGMENT_DEFINITION:\n                    case OPERATION_DEFINITION:\n                        return getDefinitionQueryResultForDefinitionNode(filePath, query, node);\n                    case NAMED_TYPE:\n                        return this._getDefinitionForNamedType(query, ast, node, filePath, projectConfig);\n                }\n            }\n            return null;\n        });\n    }\n    getDocumentSymbols(document, filePath) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const outline = yield this.getOutline(document);\n            if (!outline) {\n                return [];\n            }\n            const output = [];\n            const input = outline.outlineTrees.map((tree) => [null, tree]);\n            while (input.length > 0) {\n                const res = input.pop();\n                if (!res) {\n                    return [];\n                }\n                const [parent, tree] = res;\n                if (!tree) {\n                    return [];\n                }\n                output.push({\n                    name: tree.representativeName,\n                    kind: getKind(tree),\n                    location: {\n                        uri: filePath,\n                        range: {\n                            start: tree.startPosition,\n                            end: tree.endPosition,\n                        },\n                    },\n                    containerName: parent ? parent.representativeName : undefined,\n                });\n                input.push(...tree.children.map(child => [tree, child]));\n            }\n            return output;\n        });\n    }\n    _getDefinitionForNamedType(query, ast, node, filePath, projectConfig) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const objectTypeDefinitions = yield this._graphQLCache.getObjectTypeDefinitions(projectConfig);\n            const dependencies = yield this._graphQLCache.getObjectTypeDependenciesForAST(ast, objectTypeDefinitions);\n            const localObjectTypeDefinitions = ast.definitions.filter(definition => definition.kind === OBJECT_TYPE_DEFINITION ||\n                definition.kind === INPUT_OBJECT_TYPE_DEFINITION ||\n                definition.kind === ENUM_TYPE_DEFINITION ||\n                definition.kind === SCALAR_TYPE_DEFINITION ||\n                definition.kind === INTERFACE_TYPE_DEFINITION);\n            const typeCastedDefs = localObjectTypeDefinitions;\n            const localOperationDefinationInfos = typeCastedDefs.map((definition) => ({\n                filePath,\n                content: query,\n                definition,\n            }));\n            const result = yield getDefinitionQueryResultForNamedType(query, node, dependencies.concat(localOperationDefinationInfos));\n            return result;\n        });\n    }\n    _getDefinitionForFragmentSpread(query, ast, node, filePath, projectConfig) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const fragmentDefinitions = yield this._graphQLCache.getFragmentDefinitions(projectConfig);\n            const dependencies = yield this._graphQLCache.getFragmentDependenciesForAST(ast, fragmentDefinitions);\n            const localFragDefinitions = ast.definitions.filter(definition => definition.kind === FRAGMENT_DEFINITION);\n            const typeCastedDefs = localFragDefinitions;\n            const localFragInfos = typeCastedDefs.map((definition) => ({\n                filePath,\n                content: query,\n                definition,\n            }));\n            const result = yield getDefinitionQueryResultForFragmentSpread(query, node, dependencies.concat(localFragInfos));\n            return result;\n        });\n    }\n    getOutline(documentText) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return getOutline(documentText);\n        });\n    }\n}\n//# sourceMappingURL=GraphQLLanguageService.js.map"]},"metadata":{},"sourceType":"module"}