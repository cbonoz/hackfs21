{"ast":null,"code":"export class Range {\n  constructor(start, end) {\n    this.containsPosition = position => {\n      if (this.start.line === position.line) {\n        return this.start.character <= position.character;\n      } else if (this.end.line === position.line) {\n        return this.end.character >= position.character;\n      } else {\n        return this.start.line <= position.line && this.end.line >= position.line;\n      }\n    };\n\n    this.start = start;\n    this.end = end;\n  }\n\n  setStart(line, character) {\n    this.start = new Position(line, character);\n  }\n\n  setEnd(line, character) {\n    this.end = new Position(line, character);\n  }\n\n}\nexport class Position {\n  constructor(line, character) {\n    this.lessThanOrEqualTo = position => this.line < position.line || this.line === position.line && this.character <= position.character;\n\n    this.line = line;\n    this.character = character;\n  }\n\n  setLine(line) {\n    this.line = line;\n  }\n\n  setCharacter(character) {\n    this.character = character;\n  }\n\n}\nexport function offsetToPosition(text, loc) {\n  const EOL = '\\n';\n  const buf = text.slice(0, loc);\n  const lines = buf.split(EOL).length - 1;\n  const lastLineIndex = buf.lastIndexOf(EOL);\n  return new Position(lines, loc - lastLineIndex - 1);\n}\nexport function locToRange(text, loc) {\n  const start = offsetToPosition(text, loc.start);\n  const end = offsetToPosition(text, loc.end);\n  return new Range(start, end);\n}","map":{"version":3,"sources":["../src/Range.ts"],"names":[],"mappings":"AAYA,OAAM,MAAO,KAAP,CAAY;AAGhB,EAAA,WAAA,CAAY,KAAZ,EAA8B,GAA9B,EAA4C;AAa5C,SAAA,gBAAA,GAAoB,QAAD,IAAiC;AAClD,UAAI,KAAK,KAAL,CAAW,IAAX,KAAoB,QAAQ,CAAC,IAAjC,EAAuC;AACrC,eAAO,KAAK,KAAL,CAAW,SAAX,IAAwB,QAAQ,CAAC,SAAxC;AACD,OAFD,MAEO,IAAI,KAAK,GAAL,CAAS,IAAT,KAAkB,QAAQ,CAAC,IAA/B,EAAqC;AAC1C,eAAO,KAAK,GAAL,CAAS,SAAT,IAAsB,QAAQ,CAAC,SAAtC;AACD,OAFM,MAEA;AACL,eAAO,KAAK,KAAL,CAAW,IAAX,IAAmB,QAAQ,CAAC,IAA5B,IAAoC,KAAK,GAAL,CAAS,IAAT,IAAiB,QAAQ,CAAC,IAArE;AACD;AACF,KARD;;AAZE,SAAK,KAAL,GAAa,KAAb;AACA,SAAK,GAAL,GAAW,GAAX;AACD;;AAED,EAAA,QAAQ,CAAC,IAAD,EAAe,SAAf,EAAgC;AACtC,SAAK,KAAL,GAAa,IAAI,QAAJ,CAAa,IAAb,EAAmB,SAAnB,CAAb;AACD;;AAED,EAAA,MAAM,CAAC,IAAD,EAAe,SAAf,EAAgC;AACpC,SAAK,GAAL,GAAW,IAAI,QAAJ,CAAa,IAAb,EAAmB,SAAnB,CAAX;AACD;;AAde;AA2BlB,OAAM,MAAO,QAAP,CAAe;AAGnB,EAAA,WAAA,CAAY,IAAZ,EAA0B,SAA1B,EAA2C;AAa3C,SAAA,iBAAA,GAAqB,QAAD,IAClB,KAAK,IAAL,GAAY,QAAQ,CAAC,IAArB,IACC,KAAK,IAAL,KAAc,QAAQ,CAAC,IAAvB,IAA+B,KAAK,SAAL,IAAkB,QAAQ,CAAC,SAF7D;;AAZE,SAAK,IAAL,GAAY,IAAZ;AACA,SAAK,SAAL,GAAiB,SAAjB;AACD;;AAED,EAAA,OAAO,CAAC,IAAD,EAAa;AAClB,SAAK,IAAL,GAAY,IAAZ;AACD;;AAED,EAAA,YAAY,CAAC,SAAD,EAAkB;AAC5B,SAAK,SAAL,GAAiB,SAAjB;AACD;;AAdkB;AAqBrB,OAAM,SAAU,gBAAV,CAA2B,IAA3B,EAAyC,GAAzC,EAAoD;AACxD,QAAM,GAAG,GAAG,IAAZ;AACA,QAAM,GAAG,GAAG,IAAI,CAAC,KAAL,CAAW,CAAX,EAAc,GAAd,CAAZ;AACA,QAAM,KAAK,GAAG,GAAG,CAAC,KAAJ,CAAU,GAAV,EAAe,MAAf,GAAwB,CAAtC;AACA,QAAM,aAAa,GAAG,GAAG,CAAC,WAAJ,CAAgB,GAAhB,CAAtB;AACA,SAAO,IAAI,QAAJ,CAAa,KAAb,EAAoB,GAAG,GAAG,aAAN,GAAsB,CAA1C,CAAP;AACD;AAED,OAAM,SAAU,UAAV,CAAqB,IAArB,EAAmC,GAAnC,EAAgD;AACpD,QAAM,KAAK,GAAG,gBAAgB,CAAC,IAAD,EAAO,GAAG,CAAC,KAAX,CAA9B;AACA,QAAM,GAAG,GAAG,gBAAgB,CAAC,IAAD,EAAO,GAAG,CAAC,GAAX,CAA5B;AACA,SAAO,IAAI,KAAJ,CAAU,KAAV,EAAiB,GAAjB,CAAP;AACD","sourceRoot":"","sourcesContent":["export class Range {\n    constructor(start, end) {\n        this.containsPosition = (position) => {\n            if (this.start.line === position.line) {\n                return this.start.character <= position.character;\n            }\n            else if (this.end.line === position.line) {\n                return this.end.character >= position.character;\n            }\n            else {\n                return this.start.line <= position.line && this.end.line >= position.line;\n            }\n        };\n        this.start = start;\n        this.end = end;\n    }\n    setStart(line, character) {\n        this.start = new Position(line, character);\n    }\n    setEnd(line, character) {\n        this.end = new Position(line, character);\n    }\n}\nexport class Position {\n    constructor(line, character) {\n        this.lessThanOrEqualTo = (position) => this.line < position.line ||\n            (this.line === position.line && this.character <= position.character);\n        this.line = line;\n        this.character = character;\n    }\n    setLine(line) {\n        this.line = line;\n    }\n    setCharacter(character) {\n        this.character = character;\n    }\n}\nexport function offsetToPosition(text, loc) {\n    const EOL = '\\n';\n    const buf = text.slice(0, loc);\n    const lines = buf.split(EOL).length - 1;\n    const lastLineIndex = buf.lastIndexOf(EOL);\n    return new Position(lines, loc - lastLineIndex - 1);\n}\nexport function locToRange(text, loc) {\n    const start = offsetToPosition(text, loc.start);\n    const end = offsetToPosition(text, loc.end);\n    return new Range(start, end);\n}\n//# sourceMappingURL=Range.js.map"]},"metadata":{},"sourceType":"module"}