{"ast":null,"code":"import * as crypto from \"@walletconnect/crypto\";\nimport * as encoding from \"@walletconnect/encoding\";\nimport { convertArrayBufferToBuffer, convertBufferToArrayBuffer } from \"@walletconnect/utils\";\nexport async function generateKey(length) {\n  const _length = (length || 256) / 8;\n\n  const bytes = crypto.randomBytes(_length);\n  const result = convertBufferToArrayBuffer(encoding.arrayToBuffer(bytes));\n  return result;\n}\nexport async function verifyHmac(payload, key) {\n  const cipherText = encoding.hexToArray(payload.data);\n  const iv = encoding.hexToArray(payload.iv);\n  const hmac = encoding.hexToArray(payload.hmac);\n  const hmacHex = encoding.arrayToHex(hmac, false);\n  const unsigned = encoding.concatArrays(cipherText, iv);\n  const chmac = await crypto.hmacSha256Sign(key, unsigned);\n  const chmacHex = encoding.arrayToHex(chmac, false);\n\n  if (encoding.removeHexPrefix(hmacHex) === encoding.removeHexPrefix(chmacHex)) {\n    return true;\n  }\n\n  return false;\n}\nexport async function encrypt(data, key, providedIv) {\n  const _key = encoding.bufferToArray(convertArrayBufferToBuffer(key));\n\n  const ivArrayBuffer = providedIv || (await generateKey(128));\n  const iv = encoding.bufferToArray(convertArrayBufferToBuffer(ivArrayBuffer));\n  const ivHex = encoding.arrayToHex(iv, false);\n  const contentString = JSON.stringify(data);\n  const content = encoding.utf8ToArray(contentString);\n  const cipherText = await crypto.aesCbcEncrypt(iv, _key, content);\n  const cipherTextHex = encoding.arrayToHex(cipherText, false);\n  const unsigned = encoding.concatArrays(cipherText, iv);\n  const hmac = await crypto.hmacSha256Sign(_key, unsigned);\n  const hmacHex = encoding.arrayToHex(hmac, false);\n  return {\n    data: cipherTextHex,\n    hmac: hmacHex,\n    iv: ivHex\n  };\n}\nexport async function decrypt(payload, key) {\n  const _key = encoding.bufferToArray(convertArrayBufferToBuffer(key));\n\n  if (!_key) {\n    throw new Error(\"Missing key: required for decryption\");\n  }\n\n  const verified = await verifyHmac(payload, _key);\n\n  if (!verified) {\n    return null;\n  }\n\n  const cipherText = encoding.hexToArray(payload.data);\n  const iv = encoding.hexToArray(payload.iv);\n  const buffer = await crypto.aesCbcDecrypt(iv, _key, cipherText);\n  const utf8 = encoding.arrayToUtf8(buffer);\n  let data;\n\n  try {\n    data = JSON.parse(utf8);\n  } catch (error) {\n    return null;\n  }\n\n  return data;\n}","map":{"version":3,"sources":["../../src/index.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import * as crypto from \"@walletconnect/crypto\";\nimport * as encoding from \"@walletconnect/encoding\";\nimport { convertArrayBufferToBuffer, convertBufferToArrayBuffer } from \"@walletconnect/utils\";\nexport async function generateKey(length) {\n    const _length = (length || 256) / 8;\n    const bytes = crypto.randomBytes(_length);\n    const result = convertBufferToArrayBuffer(encoding.arrayToBuffer(bytes));\n    return result;\n}\nexport async function verifyHmac(payload, key) {\n    const cipherText = encoding.hexToArray(payload.data);\n    const iv = encoding.hexToArray(payload.iv);\n    const hmac = encoding.hexToArray(payload.hmac);\n    const hmacHex = encoding.arrayToHex(hmac, false);\n    const unsigned = encoding.concatArrays(cipherText, iv);\n    const chmac = await crypto.hmacSha256Sign(key, unsigned);\n    const chmacHex = encoding.arrayToHex(chmac, false);\n    if (encoding.removeHexPrefix(hmacHex) === encoding.removeHexPrefix(chmacHex)) {\n        return true;\n    }\n    return false;\n}\nexport async function encrypt(data, key, providedIv) {\n    const _key = encoding.bufferToArray(convertArrayBufferToBuffer(key));\n    const ivArrayBuffer = providedIv || (await generateKey(128));\n    const iv = encoding.bufferToArray(convertArrayBufferToBuffer(ivArrayBuffer));\n    const ivHex = encoding.arrayToHex(iv, false);\n    const contentString = JSON.stringify(data);\n    const content = encoding.utf8ToArray(contentString);\n    const cipherText = await crypto.aesCbcEncrypt(iv, _key, content);\n    const cipherTextHex = encoding.arrayToHex(cipherText, false);\n    const unsigned = encoding.concatArrays(cipherText, iv);\n    const hmac = await crypto.hmacSha256Sign(_key, unsigned);\n    const hmacHex = encoding.arrayToHex(hmac, false);\n    return {\n        data: cipherTextHex,\n        hmac: hmacHex,\n        iv: ivHex,\n    };\n}\nexport async function decrypt(payload, key) {\n    const _key = encoding.bufferToArray(convertArrayBufferToBuffer(key));\n    if (!_key) {\n        throw new Error(\"Missing key: required for decryption\");\n    }\n    const verified = await verifyHmac(payload, _key);\n    if (!verified) {\n        return null;\n    }\n    const cipherText = encoding.hexToArray(payload.data);\n    const iv = encoding.hexToArray(payload.iv);\n    const buffer = await crypto.aesCbcDecrypt(iv, _key, cipherText);\n    const utf8 = encoding.arrayToUtf8(buffer);\n    let data;\n    try {\n        data = JSON.parse(utf8);\n    }\n    catch (error) {\n        return null;\n    }\n    return data;\n}\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"module"}