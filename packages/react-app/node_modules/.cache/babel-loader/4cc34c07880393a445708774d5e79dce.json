{"ast":null,"code":"/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n\n/* eslint-env node */\n'use strict';\n\nimport * as utils from '../utils.js';\nexport { shimGetUserMedia } from './getusermedia';\nexport { shimGetDisplayMedia } from './getdisplaymedia';\nexport function shimMediaStream(window) {\n  window.MediaStream = window.MediaStream || window.webkitMediaStream;\n}\nexport function shimOnTrack(window) {\n  if (typeof window === 'object' && window.RTCPeerConnection && !('ontrack' in window.RTCPeerConnection.prototype)) {\n    Object.defineProperty(window.RTCPeerConnection.prototype, 'ontrack', {\n      get() {\n        return this._ontrack;\n      },\n\n      set(f) {\n        if (this._ontrack) {\n          this.removeEventListener('track', this._ontrack);\n        }\n\n        this.addEventListener('track', this._ontrack = f);\n      },\n\n      enumerable: true,\n      configurable: true\n    });\n    const origSetRemoteDescription = window.RTCPeerConnection.prototype.setRemoteDescription;\n\n    window.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription() {\n      if (!this._ontrackpoly) {\n        this._ontrackpoly = e => {\n          // onaddstream does not fire when a track is added to an existing\n          // stream. But stream.onaddtrack is implemented so we use that.\n          e.stream.addEventListener('addtrack', te => {\n            let receiver;\n\n            if (window.RTCPeerConnection.prototype.getReceivers) {\n              receiver = this.getReceivers().find(r => r.track && r.track.id === te.track.id);\n            } else {\n              receiver = {\n                track: te.track\n              };\n            }\n\n            const event = new Event('track');\n            event.track = te.track;\n            event.receiver = receiver;\n            event.transceiver = {\n              receiver\n            };\n            event.streams = [e.stream];\n            this.dispatchEvent(event);\n          });\n          e.stream.getTracks().forEach(track => {\n            let receiver;\n\n            if (window.RTCPeerConnection.prototype.getReceivers) {\n              receiver = this.getReceivers().find(r => r.track && r.track.id === track.id);\n            } else {\n              receiver = {\n                track\n              };\n            }\n\n            const event = new Event('track');\n            event.track = track;\n            event.receiver = receiver;\n            event.transceiver = {\n              receiver\n            };\n            event.streams = [e.stream];\n            this.dispatchEvent(event);\n          });\n        };\n\n        this.addEventListener('addstream', this._ontrackpoly);\n      }\n\n      return origSetRemoteDescription.apply(this, arguments);\n    };\n  } else {\n    // even if RTCRtpTransceiver is in window, it is only used and\n    // emitted in unified-plan. Unfortunately this means we need\n    // to unconditionally wrap the event.\n    utils.wrapPeerConnectionEvent(window, 'track', e => {\n      if (!e.transceiver) {\n        Object.defineProperty(e, 'transceiver', {\n          value: {\n            receiver: e.receiver\n          }\n        });\n      }\n\n      return e;\n    });\n  }\n}\nexport function shimGetSendersWithDtmf(window) {\n  // Overrides addTrack/removeTrack, depends on shimAddTrackRemoveTrack.\n  if (typeof window === 'object' && window.RTCPeerConnection && !('getSenders' in window.RTCPeerConnection.prototype) && 'createDTMFSender' in window.RTCPeerConnection.prototype) {\n    const shimSenderWithDtmf = function (pc, track) {\n      return {\n        track,\n\n        get dtmf() {\n          if (this._dtmf === undefined) {\n            if (track.kind === 'audio') {\n              this._dtmf = pc.createDTMFSender(track);\n            } else {\n              this._dtmf = null;\n            }\n          }\n\n          return this._dtmf;\n        },\n\n        _pc: pc\n      };\n    }; // augment addTrack when getSenders is not available.\n\n\n    if (!window.RTCPeerConnection.prototype.getSenders) {\n      window.RTCPeerConnection.prototype.getSenders = function getSenders() {\n        this._senders = this._senders || [];\n        return this._senders.slice(); // return a copy of the internal state.\n      };\n\n      const origAddTrack = window.RTCPeerConnection.prototype.addTrack;\n\n      window.RTCPeerConnection.prototype.addTrack = function addTrack(track, stream) {\n        let sender = origAddTrack.apply(this, arguments);\n\n        if (!sender) {\n          sender = shimSenderWithDtmf(this, track);\n\n          this._senders.push(sender);\n        }\n\n        return sender;\n      };\n\n      const origRemoveTrack = window.RTCPeerConnection.prototype.removeTrack;\n\n      window.RTCPeerConnection.prototype.removeTrack = function removeTrack(sender) {\n        origRemoveTrack.apply(this, arguments);\n\n        const idx = this._senders.indexOf(sender);\n\n        if (idx !== -1) {\n          this._senders.splice(idx, 1);\n        }\n      };\n    }\n\n    const origAddStream = window.RTCPeerConnection.prototype.addStream;\n\n    window.RTCPeerConnection.prototype.addStream = function addStream(stream) {\n      this._senders = this._senders || [];\n      origAddStream.apply(this, [stream]);\n      stream.getTracks().forEach(track => {\n        this._senders.push(shimSenderWithDtmf(this, track));\n      });\n    };\n\n    const origRemoveStream = window.RTCPeerConnection.prototype.removeStream;\n\n    window.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {\n      this._senders = this._senders || [];\n      origRemoveStream.apply(this, [stream]);\n      stream.getTracks().forEach(track => {\n        const sender = this._senders.find(s => s.track === track);\n\n        if (sender) {\n          // remove sender\n          this._senders.splice(this._senders.indexOf(sender), 1);\n        }\n      });\n    };\n  } else if (typeof window === 'object' && window.RTCPeerConnection && 'getSenders' in window.RTCPeerConnection.prototype && 'createDTMFSender' in window.RTCPeerConnection.prototype && window.RTCRtpSender && !('dtmf' in window.RTCRtpSender.prototype)) {\n    const origGetSenders = window.RTCPeerConnection.prototype.getSenders;\n\n    window.RTCPeerConnection.prototype.getSenders = function getSenders() {\n      const senders = origGetSenders.apply(this, []);\n      senders.forEach(sender => sender._pc = this);\n      return senders;\n    };\n\n    Object.defineProperty(window.RTCRtpSender.prototype, 'dtmf', {\n      get() {\n        if (this._dtmf === undefined) {\n          if (this.track.kind === 'audio') {\n            this._dtmf = this._pc.createDTMFSender(this.track);\n          } else {\n            this._dtmf = null;\n          }\n        }\n\n        return this._dtmf;\n      }\n\n    });\n  }\n}\nexport function shimGetStats(window) {\n  if (!window.RTCPeerConnection) {\n    return;\n  }\n\n  const origGetStats = window.RTCPeerConnection.prototype.getStats;\n\n  window.RTCPeerConnection.prototype.getStats = function getStats() {\n    const [selector, onSucc, onErr] = arguments; // If selector is a function then we are in the old style stats so just\n    // pass back the original getStats format to avoid breaking old users.\n\n    if (arguments.length > 0 && typeof selector === 'function') {\n      return origGetStats.apply(this, arguments);\n    } // When spec-style getStats is supported, return those when called with\n    // either no arguments or the selector argument is null.\n\n\n    if (origGetStats.length === 0 && (arguments.length === 0 || typeof selector !== 'function')) {\n      return origGetStats.apply(this, []);\n    }\n\n    const fixChromeStats_ = function (response) {\n      const standardReport = {};\n      const reports = response.result();\n      reports.forEach(report => {\n        const standardStats = {\n          id: report.id,\n          timestamp: report.timestamp,\n          type: {\n            localcandidate: 'local-candidate',\n            remotecandidate: 'remote-candidate'\n          }[report.type] || report.type\n        };\n        report.names().forEach(name => {\n          standardStats[name] = report.stat(name);\n        });\n        standardReport[standardStats.id] = standardStats;\n      });\n      return standardReport;\n    }; // shim getStats with maplike support\n\n\n    const makeMapStats = function (stats) {\n      return new Map(Object.keys(stats).map(key => [key, stats[key]]));\n    };\n\n    if (arguments.length >= 2) {\n      const successCallbackWrapper_ = function (response) {\n        onSucc(makeMapStats(fixChromeStats_(response)));\n      };\n\n      return origGetStats.apply(this, [successCallbackWrapper_, selector]);\n    } // promise-support\n\n\n    return new Promise((resolve, reject) => {\n      origGetStats.apply(this, [function (response) {\n        resolve(makeMapStats(fixChromeStats_(response)));\n      }, reject]);\n    }).then(onSucc, onErr);\n  };\n}\nexport function shimSenderReceiverGetStats(window) {\n  if (!(typeof window === 'object' && window.RTCPeerConnection && window.RTCRtpSender && window.RTCRtpReceiver)) {\n    return;\n  } // shim sender stats.\n\n\n  if (!('getStats' in window.RTCRtpSender.prototype)) {\n    const origGetSenders = window.RTCPeerConnection.prototype.getSenders;\n\n    if (origGetSenders) {\n      window.RTCPeerConnection.prototype.getSenders = function getSenders() {\n        const senders = origGetSenders.apply(this, []);\n        senders.forEach(sender => sender._pc = this);\n        return senders;\n      };\n    }\n\n    const origAddTrack = window.RTCPeerConnection.prototype.addTrack;\n\n    if (origAddTrack) {\n      window.RTCPeerConnection.prototype.addTrack = function addTrack() {\n        const sender = origAddTrack.apply(this, arguments);\n        sender._pc = this;\n        return sender;\n      };\n    }\n\n    window.RTCRtpSender.prototype.getStats = function getStats() {\n      const sender = this;\n      return this._pc.getStats().then(result =>\n      /* Note: this will include stats of all senders that\n       *   send a track with the same id as sender.track as\n       *   it is not possible to identify the RTCRtpSender.\n       */\n      utils.filterStats(result, sender.track, true));\n    };\n  } // shim receiver stats.\n\n\n  if (!('getStats' in window.RTCRtpReceiver.prototype)) {\n    const origGetReceivers = window.RTCPeerConnection.prototype.getReceivers;\n\n    if (origGetReceivers) {\n      window.RTCPeerConnection.prototype.getReceivers = function getReceivers() {\n        const receivers = origGetReceivers.apply(this, []);\n        receivers.forEach(receiver => receiver._pc = this);\n        return receivers;\n      };\n    }\n\n    utils.wrapPeerConnectionEvent(window, 'track', e => {\n      e.receiver._pc = e.srcElement;\n      return e;\n    });\n\n    window.RTCRtpReceiver.prototype.getStats = function getStats() {\n      const receiver = this;\n      return this._pc.getStats().then(result => utils.filterStats(result, receiver.track, false));\n    };\n  }\n\n  if (!('getStats' in window.RTCRtpSender.prototype && 'getStats' in window.RTCRtpReceiver.prototype)) {\n    return;\n  } // shim RTCPeerConnection.getStats(track).\n\n\n  const origGetStats = window.RTCPeerConnection.prototype.getStats;\n\n  window.RTCPeerConnection.prototype.getStats = function getStats() {\n    if (arguments.length > 0 && arguments[0] instanceof window.MediaStreamTrack) {\n      const track = arguments[0];\n      let sender;\n      let receiver;\n      let err;\n      this.getSenders().forEach(s => {\n        if (s.track === track) {\n          if (sender) {\n            err = true;\n          } else {\n            sender = s;\n          }\n        }\n      });\n      this.getReceivers().forEach(r => {\n        if (r.track === track) {\n          if (receiver) {\n            err = true;\n          } else {\n            receiver = r;\n          }\n        }\n\n        return r.track === track;\n      });\n\n      if (err || sender && receiver) {\n        return Promise.reject(new DOMException('There are more than one sender or receiver for the track.', 'InvalidAccessError'));\n      } else if (sender) {\n        return sender.getStats();\n      } else if (receiver) {\n        return receiver.getStats();\n      }\n\n      return Promise.reject(new DOMException('There is no sender or receiver for the track.', 'InvalidAccessError'));\n    }\n\n    return origGetStats.apply(this, arguments);\n  };\n}\nexport function shimAddTrackRemoveTrackWithNative(window) {\n  // shim addTrack/removeTrack with native variants in order to make\n  // the interactions with legacy getLocalStreams behave as in other browsers.\n  // Keeps a mapping stream.id => [stream, rtpsenders...]\n  window.RTCPeerConnection.prototype.getLocalStreams = function getLocalStreams() {\n    this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n    return Object.keys(this._shimmedLocalStreams).map(streamId => this._shimmedLocalStreams[streamId][0]);\n  };\n\n  const origAddTrack = window.RTCPeerConnection.prototype.addTrack;\n\n  window.RTCPeerConnection.prototype.addTrack = function addTrack(track, stream) {\n    if (!stream) {\n      return origAddTrack.apply(this, arguments);\n    }\n\n    this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n    const sender = origAddTrack.apply(this, arguments);\n\n    if (!this._shimmedLocalStreams[stream.id]) {\n      this._shimmedLocalStreams[stream.id] = [stream, sender];\n    } else if (this._shimmedLocalStreams[stream.id].indexOf(sender) === -1) {\n      this._shimmedLocalStreams[stream.id].push(sender);\n    }\n\n    return sender;\n  };\n\n  const origAddStream = window.RTCPeerConnection.prototype.addStream;\n\n  window.RTCPeerConnection.prototype.addStream = function addStream(stream) {\n    this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n    stream.getTracks().forEach(track => {\n      const alreadyExists = this.getSenders().find(s => s.track === track);\n\n      if (alreadyExists) {\n        throw new DOMException('Track already exists.', 'InvalidAccessError');\n      }\n    });\n    const existingSenders = this.getSenders();\n    origAddStream.apply(this, arguments);\n    const newSenders = this.getSenders().filter(newSender => existingSenders.indexOf(newSender) === -1);\n    this._shimmedLocalStreams[stream.id] = [stream].concat(newSenders);\n  };\n\n  const origRemoveStream = window.RTCPeerConnection.prototype.removeStream;\n\n  window.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {\n    this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n    delete this._shimmedLocalStreams[stream.id];\n    return origRemoveStream.apply(this, arguments);\n  };\n\n  const origRemoveTrack = window.RTCPeerConnection.prototype.removeTrack;\n\n  window.RTCPeerConnection.prototype.removeTrack = function removeTrack(sender) {\n    this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n\n    if (sender) {\n      Object.keys(this._shimmedLocalStreams).forEach(streamId => {\n        const idx = this._shimmedLocalStreams[streamId].indexOf(sender);\n\n        if (idx !== -1) {\n          this._shimmedLocalStreams[streamId].splice(idx, 1);\n        }\n\n        if (this._shimmedLocalStreams[streamId].length === 1) {\n          delete this._shimmedLocalStreams[streamId];\n        }\n      });\n    }\n\n    return origRemoveTrack.apply(this, arguments);\n  };\n}\nexport function shimAddTrackRemoveTrack(window, browserDetails) {\n  if (!window.RTCPeerConnection) {\n    return;\n  } // shim addTrack and removeTrack.\n\n\n  if (window.RTCPeerConnection.prototype.addTrack && browserDetails.version >= 65) {\n    return shimAddTrackRemoveTrackWithNative(window);\n  } // also shim pc.getLocalStreams when addTrack is shimmed\n  // to return the original streams.\n\n\n  const origGetLocalStreams = window.RTCPeerConnection.prototype.getLocalStreams;\n\n  window.RTCPeerConnection.prototype.getLocalStreams = function getLocalStreams() {\n    const nativeStreams = origGetLocalStreams.apply(this);\n    this._reverseStreams = this._reverseStreams || {};\n    return nativeStreams.map(stream => this._reverseStreams[stream.id]);\n  };\n\n  const origAddStream = window.RTCPeerConnection.prototype.addStream;\n\n  window.RTCPeerConnection.prototype.addStream = function addStream(stream) {\n    this._streams = this._streams || {};\n    this._reverseStreams = this._reverseStreams || {};\n    stream.getTracks().forEach(track => {\n      const alreadyExists = this.getSenders().find(s => s.track === track);\n\n      if (alreadyExists) {\n        throw new DOMException('Track already exists.', 'InvalidAccessError');\n      }\n    }); // Add identity mapping for consistency with addTrack.\n    // Unless this is being used with a stream from addTrack.\n\n    if (!this._reverseStreams[stream.id]) {\n      const newStream = new window.MediaStream(stream.getTracks());\n      this._streams[stream.id] = newStream;\n      this._reverseStreams[newStream.id] = stream;\n      stream = newStream;\n    }\n\n    origAddStream.apply(this, [stream]);\n  };\n\n  const origRemoveStream = window.RTCPeerConnection.prototype.removeStream;\n\n  window.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {\n    this._streams = this._streams || {};\n    this._reverseStreams = this._reverseStreams || {};\n    origRemoveStream.apply(this, [this._streams[stream.id] || stream]);\n    delete this._reverseStreams[this._streams[stream.id] ? this._streams[stream.id].id : stream.id];\n    delete this._streams[stream.id];\n  };\n\n  window.RTCPeerConnection.prototype.addTrack = function addTrack(track, stream) {\n    if (this.signalingState === 'closed') {\n      throw new DOMException('The RTCPeerConnection\\'s signalingState is \\'closed\\'.', 'InvalidStateError');\n    }\n\n    const streams = [].slice.call(arguments, 1);\n\n    if (streams.length !== 1 || !streams[0].getTracks().find(t => t === track)) {\n      // this is not fully correct but all we can manage without\n      // [[associated MediaStreams]] internal slot.\n      throw new DOMException('The adapter.js addTrack polyfill only supports a single ' + ' stream which is associated with the specified track.', 'NotSupportedError');\n    }\n\n    const alreadyExists = this.getSenders().find(s => s.track === track);\n\n    if (alreadyExists) {\n      throw new DOMException('Track already exists.', 'InvalidAccessError');\n    }\n\n    this._streams = this._streams || {};\n    this._reverseStreams = this._reverseStreams || {};\n    const oldStream = this._streams[stream.id];\n\n    if (oldStream) {\n      // this is using odd Chrome behaviour, use with caution:\n      // https://bugs.chromium.org/p/webrtc/issues/detail?id=7815\n      // Note: we rely on the high-level addTrack/dtmf shim to\n      // create the sender with a dtmf sender.\n      oldStream.addTrack(track); // Trigger ONN async.\n\n      Promise.resolve().then(() => {\n        this.dispatchEvent(new Event('negotiationneeded'));\n      });\n    } else {\n      const newStream = new window.MediaStream([track]);\n      this._streams[stream.id] = newStream;\n      this._reverseStreams[newStream.id] = stream;\n      this.addStream(newStream);\n    }\n\n    return this.getSenders().find(s => s.track === track);\n  }; // replace the internal stream id with the external one and\n  // vice versa.\n\n\n  function replaceInternalStreamId(pc, description) {\n    let sdp = description.sdp;\n    Object.keys(pc._reverseStreams || []).forEach(internalId => {\n      const externalStream = pc._reverseStreams[internalId];\n      const internalStream = pc._streams[externalStream.id];\n      sdp = sdp.replace(new RegExp(internalStream.id, 'g'), externalStream.id);\n    });\n    return new RTCSessionDescription({\n      type: description.type,\n      sdp\n    });\n  }\n\n  function replaceExternalStreamId(pc, description) {\n    let sdp = description.sdp;\n    Object.keys(pc._reverseStreams || []).forEach(internalId => {\n      const externalStream = pc._reverseStreams[internalId];\n      const internalStream = pc._streams[externalStream.id];\n      sdp = sdp.replace(new RegExp(externalStream.id, 'g'), internalStream.id);\n    });\n    return new RTCSessionDescription({\n      type: description.type,\n      sdp\n    });\n  }\n\n  ['createOffer', 'createAnswer'].forEach(function (method) {\n    const nativeMethod = window.RTCPeerConnection.prototype[method];\n    const methodObj = {\n      [method]() {\n        const args = arguments;\n        const isLegacyCall = arguments.length && typeof arguments[0] === 'function';\n\n        if (isLegacyCall) {\n          return nativeMethod.apply(this, [description => {\n            const desc = replaceInternalStreamId(this, description);\n            args[0].apply(null, [desc]);\n          }, err => {\n            if (args[1]) {\n              args[1].apply(null, err);\n            }\n          }, arguments[2]]);\n        }\n\n        return nativeMethod.apply(this, arguments).then(description => replaceInternalStreamId(this, description));\n      }\n\n    };\n    window.RTCPeerConnection.prototype[method] = methodObj[method];\n  });\n  const origSetLocalDescription = window.RTCPeerConnection.prototype.setLocalDescription;\n\n  window.RTCPeerConnection.prototype.setLocalDescription = function setLocalDescription() {\n    if (!arguments.length || !arguments[0].type) {\n      return origSetLocalDescription.apply(this, arguments);\n    }\n\n    arguments[0] = replaceExternalStreamId(this, arguments[0]);\n    return origSetLocalDescription.apply(this, arguments);\n  }; // TODO: mangle getStats: https://w3c.github.io/webrtc-stats/#dom-rtcmediastreamstats-streamidentifier\n\n\n  const origLocalDescription = Object.getOwnPropertyDescriptor(window.RTCPeerConnection.prototype, 'localDescription');\n  Object.defineProperty(window.RTCPeerConnection.prototype, 'localDescription', {\n    get() {\n      const description = origLocalDescription.get.apply(this);\n\n      if (description.type === '') {\n        return description;\n      }\n\n      return replaceInternalStreamId(this, description);\n    }\n\n  });\n\n  window.RTCPeerConnection.prototype.removeTrack = function removeTrack(sender) {\n    if (this.signalingState === 'closed') {\n      throw new DOMException('The RTCPeerConnection\\'s signalingState is \\'closed\\'.', 'InvalidStateError');\n    } // We can not yet check for sender instanceof RTCRtpSender\n    // since we shim RTPSender. So we check if sender._pc is set.\n\n\n    if (!sender._pc) {\n      throw new DOMException('Argument 1 of RTCPeerConnection.removeTrack ' + 'does not implement interface RTCRtpSender.', 'TypeError');\n    }\n\n    const isLocal = sender._pc === this;\n\n    if (!isLocal) {\n      throw new DOMException('Sender was not created by this connection.', 'InvalidAccessError');\n    } // Search for the native stream the senders track belongs to.\n\n\n    this._streams = this._streams || {};\n    let stream;\n    Object.keys(this._streams).forEach(streamid => {\n      const hasTrack = this._streams[streamid].getTracks().find(track => sender.track === track);\n\n      if (hasTrack) {\n        stream = this._streams[streamid];\n      }\n    });\n\n    if (stream) {\n      if (stream.getTracks().length === 1) {\n        // if this is the last track of the stream, remove the stream. This\n        // takes care of any shimmed _senders.\n        this.removeStream(this._reverseStreams[stream.id]);\n      } else {\n        // relying on the same odd chrome behaviour as above.\n        stream.removeTrack(sender.track);\n      }\n\n      this.dispatchEvent(new Event('negotiationneeded'));\n    }\n  };\n}\nexport function shimPeerConnection(window, browserDetails) {\n  if (!window.RTCPeerConnection && window.webkitRTCPeerConnection) {\n    // very basic support for old versions.\n    window.RTCPeerConnection = window.webkitRTCPeerConnection;\n  }\n\n  if (!window.RTCPeerConnection) {\n    return;\n  } // shim implicit creation of RTCSessionDescription/RTCIceCandidate\n\n\n  if (browserDetails.version < 53) {\n    ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate'].forEach(function (method) {\n      const nativeMethod = window.RTCPeerConnection.prototype[method];\n      const methodObj = {\n        [method]() {\n          arguments[0] = new (method === 'addIceCandidate' ? window.RTCIceCandidate : window.RTCSessionDescription)(arguments[0]);\n          return nativeMethod.apply(this, arguments);\n        }\n\n      };\n      window.RTCPeerConnection.prototype[method] = methodObj[method];\n    });\n  }\n} // Attempt to fix ONN in plan-b mode.\n\nexport function fixNegotiationNeeded(window, browserDetails) {\n  utils.wrapPeerConnectionEvent(window, 'negotiationneeded', e => {\n    const pc = e.target;\n\n    if (browserDetails.version < 72 || pc.getConfiguration && pc.getConfiguration().sdpSemantics === 'plan-b') {\n      if (pc.signalingState !== 'stable') {\n        return;\n      }\n    }\n\n    return e;\n  });\n}","map":{"version":3,"sources":["/Users/chrisbuonocore/personal/hackathons/hackfs21/node_modules/webrtc-adapter/src/js/chrome/chrome_shim.js"],"names":["utils","shimGetUserMedia","shimGetDisplayMedia","shimMediaStream","window","MediaStream","webkitMediaStream","shimOnTrack","RTCPeerConnection","prototype","Object","defineProperty","get","_ontrack","set","f","removeEventListener","addEventListener","enumerable","configurable","origSetRemoteDescription","setRemoteDescription","_ontrackpoly","e","stream","te","receiver","getReceivers","find","r","track","id","event","Event","transceiver","streams","dispatchEvent","getTracks","forEach","apply","arguments","wrapPeerConnectionEvent","value","shimGetSendersWithDtmf","shimSenderWithDtmf","pc","dtmf","_dtmf","undefined","kind","createDTMFSender","_pc","getSenders","_senders","slice","origAddTrack","addTrack","sender","push","origRemoveTrack","removeTrack","idx","indexOf","splice","origAddStream","addStream","origRemoveStream","removeStream","s","RTCRtpSender","origGetSenders","senders","shimGetStats","origGetStats","getStats","selector","onSucc","onErr","length","fixChromeStats_","response","standardReport","reports","result","report","standardStats","timestamp","type","localcandidate","remotecandidate","names","name","stat","makeMapStats","stats","Map","keys","map","key","successCallbackWrapper_","Promise","resolve","reject","then","shimSenderReceiverGetStats","RTCRtpReceiver","filterStats","origGetReceivers","receivers","srcElement","MediaStreamTrack","err","DOMException","shimAddTrackRemoveTrackWithNative","getLocalStreams","_shimmedLocalStreams","streamId","alreadyExists","existingSenders","newSenders","filter","newSender","concat","shimAddTrackRemoveTrack","browserDetails","version","origGetLocalStreams","nativeStreams","_reverseStreams","_streams","newStream","signalingState","call","t","oldStream","replaceInternalStreamId","description","sdp","internalId","externalStream","internalStream","replace","RegExp","RTCSessionDescription","replaceExternalStreamId","method","nativeMethod","methodObj","args","isLegacyCall","desc","origSetLocalDescription","setLocalDescription","origLocalDescription","getOwnPropertyDescriptor","isLocal","streamid","hasTrack","shimPeerConnection","webkitRTCPeerConnection","RTCIceCandidate","fixNegotiationNeeded","target","getConfiguration","sdpSemantics"],"mappings":"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","sourcesContent":["/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n /* eslint-env node */\n'use strict';\nimport * as utils from '../utils.js';\n\nexport {shimGetUserMedia} from './getusermedia';\nexport {shimGetDisplayMedia} from './getdisplaymedia';\n\nexport function shimMediaStream(window) {\n  window.MediaStream = window.MediaStream || window.webkitMediaStream;\n}\n\nexport function shimOnTrack(window) {\n  if (typeof window === 'object' && window.RTCPeerConnection && !('ontrack' in\n      window.RTCPeerConnection.prototype)) {\n    Object.defineProperty(window.RTCPeerConnection.prototype, 'ontrack', {\n      get() {\n        return this._ontrack;\n      },\n      set(f) {\n        if (this._ontrack) {\n          this.removeEventListener('track', this._ontrack);\n        }\n        this.addEventListener('track', this._ontrack = f);\n      },\n      enumerable: true,\n      configurable: true\n    });\n    const origSetRemoteDescription =\n        window.RTCPeerConnection.prototype.setRemoteDescription;\n    window.RTCPeerConnection.prototype.setRemoteDescription =\n      function setRemoteDescription() {\n        if (!this._ontrackpoly) {\n          this._ontrackpoly = (e) => {\n            // onaddstream does not fire when a track is added to an existing\n            // stream. But stream.onaddtrack is implemented so we use that.\n            e.stream.addEventListener('addtrack', te => {\n              let receiver;\n              if (window.RTCPeerConnection.prototype.getReceivers) {\n                receiver = this.getReceivers()\n                  .find(r => r.track && r.track.id === te.track.id);\n              } else {\n                receiver = {track: te.track};\n              }\n\n              const event = new Event('track');\n              event.track = te.track;\n              event.receiver = receiver;\n              event.transceiver = {receiver};\n              event.streams = [e.stream];\n              this.dispatchEvent(event);\n            });\n            e.stream.getTracks().forEach(track => {\n              let receiver;\n              if (window.RTCPeerConnection.prototype.getReceivers) {\n                receiver = this.getReceivers()\n                  .find(r => r.track && r.track.id === track.id);\n              } else {\n                receiver = {track};\n              }\n              const event = new Event('track');\n              event.track = track;\n              event.receiver = receiver;\n              event.transceiver = {receiver};\n              event.streams = [e.stream];\n              this.dispatchEvent(event);\n            });\n          };\n          this.addEventListener('addstream', this._ontrackpoly);\n        }\n        return origSetRemoteDescription.apply(this, arguments);\n      };\n  } else {\n    // even if RTCRtpTransceiver is in window, it is only used and\n    // emitted in unified-plan. Unfortunately this means we need\n    // to unconditionally wrap the event.\n    utils.wrapPeerConnectionEvent(window, 'track', e => {\n      if (!e.transceiver) {\n        Object.defineProperty(e, 'transceiver',\n          {value: {receiver: e.receiver}});\n      }\n      return e;\n    });\n  }\n}\n\nexport function shimGetSendersWithDtmf(window) {\n  // Overrides addTrack/removeTrack, depends on shimAddTrackRemoveTrack.\n  if (typeof window === 'object' && window.RTCPeerConnection &&\n      !('getSenders' in window.RTCPeerConnection.prototype) &&\n      'createDTMFSender' in window.RTCPeerConnection.prototype) {\n    const shimSenderWithDtmf = function(pc, track) {\n      return {\n        track,\n        get dtmf() {\n          if (this._dtmf === undefined) {\n            if (track.kind === 'audio') {\n              this._dtmf = pc.createDTMFSender(track);\n            } else {\n              this._dtmf = null;\n            }\n          }\n          return this._dtmf;\n        },\n        _pc: pc\n      };\n    };\n\n    // augment addTrack when getSenders is not available.\n    if (!window.RTCPeerConnection.prototype.getSenders) {\n      window.RTCPeerConnection.prototype.getSenders = function getSenders() {\n        this._senders = this._senders || [];\n        return this._senders.slice(); // return a copy of the internal state.\n      };\n      const origAddTrack = window.RTCPeerConnection.prototype.addTrack;\n      window.RTCPeerConnection.prototype.addTrack =\n        function addTrack(track, stream) {\n          let sender = origAddTrack.apply(this, arguments);\n          if (!sender) {\n            sender = shimSenderWithDtmf(this, track);\n            this._senders.push(sender);\n          }\n          return sender;\n        };\n\n      const origRemoveTrack = window.RTCPeerConnection.prototype.removeTrack;\n      window.RTCPeerConnection.prototype.removeTrack =\n        function removeTrack(sender) {\n          origRemoveTrack.apply(this, arguments);\n          const idx = this._senders.indexOf(sender);\n          if (idx !== -1) {\n            this._senders.splice(idx, 1);\n          }\n        };\n    }\n    const origAddStream = window.RTCPeerConnection.prototype.addStream;\n    window.RTCPeerConnection.prototype.addStream = function addStream(stream) {\n      this._senders = this._senders || [];\n      origAddStream.apply(this, [stream]);\n      stream.getTracks().forEach(track => {\n        this._senders.push(shimSenderWithDtmf(this, track));\n      });\n    };\n\n    const origRemoveStream = window.RTCPeerConnection.prototype.removeStream;\n    window.RTCPeerConnection.prototype.removeStream =\n      function removeStream(stream) {\n        this._senders = this._senders || [];\n        origRemoveStream.apply(this, [stream]);\n\n        stream.getTracks().forEach(track => {\n          const sender = this._senders.find(s => s.track === track);\n          if (sender) { // remove sender\n            this._senders.splice(this._senders.indexOf(sender), 1);\n          }\n        });\n      };\n  } else if (typeof window === 'object' && window.RTCPeerConnection &&\n             'getSenders' in window.RTCPeerConnection.prototype &&\n             'createDTMFSender' in window.RTCPeerConnection.prototype &&\n             window.RTCRtpSender &&\n             !('dtmf' in window.RTCRtpSender.prototype)) {\n    const origGetSenders = window.RTCPeerConnection.prototype.getSenders;\n    window.RTCPeerConnection.prototype.getSenders = function getSenders() {\n      const senders = origGetSenders.apply(this, []);\n      senders.forEach(sender => sender._pc = this);\n      return senders;\n    };\n\n    Object.defineProperty(window.RTCRtpSender.prototype, 'dtmf', {\n      get() {\n        if (this._dtmf === undefined) {\n          if (this.track.kind === 'audio') {\n            this._dtmf = this._pc.createDTMFSender(this.track);\n          } else {\n            this._dtmf = null;\n          }\n        }\n        return this._dtmf;\n      }\n    });\n  }\n}\n\nexport function shimGetStats(window) {\n  if (!window.RTCPeerConnection) {\n    return;\n  }\n\n  const origGetStats = window.RTCPeerConnection.prototype.getStats;\n  window.RTCPeerConnection.prototype.getStats = function getStats() {\n    const [selector, onSucc, onErr] = arguments;\n\n    // If selector is a function then we are in the old style stats so just\n    // pass back the original getStats format to avoid breaking old users.\n    if (arguments.length > 0 && typeof selector === 'function') {\n      return origGetStats.apply(this, arguments);\n    }\n\n    // When spec-style getStats is supported, return those when called with\n    // either no arguments or the selector argument is null.\n    if (origGetStats.length === 0 && (arguments.length === 0 ||\n        typeof selector !== 'function')) {\n      return origGetStats.apply(this, []);\n    }\n\n    const fixChromeStats_ = function(response) {\n      const standardReport = {};\n      const reports = response.result();\n      reports.forEach(report => {\n        const standardStats = {\n          id: report.id,\n          timestamp: report.timestamp,\n          type: {\n            localcandidate: 'local-candidate',\n            remotecandidate: 'remote-candidate'\n          }[report.type] || report.type\n        };\n        report.names().forEach(name => {\n          standardStats[name] = report.stat(name);\n        });\n        standardReport[standardStats.id] = standardStats;\n      });\n\n      return standardReport;\n    };\n\n    // shim getStats with maplike support\n    const makeMapStats = function(stats) {\n      return new Map(Object.keys(stats).map(key => [key, stats[key]]));\n    };\n\n    if (arguments.length >= 2) {\n      const successCallbackWrapper_ = function(response) {\n        onSucc(makeMapStats(fixChromeStats_(response)));\n      };\n\n      return origGetStats.apply(this, [successCallbackWrapper_,\n        selector]);\n    }\n\n    // promise-support\n    return new Promise((resolve, reject) => {\n      origGetStats.apply(this, [\n        function(response) {\n          resolve(makeMapStats(fixChromeStats_(response)));\n        }, reject]);\n    }).then(onSucc, onErr);\n  };\n}\n\nexport function shimSenderReceiverGetStats(window) {\n  if (!(typeof window === 'object' && window.RTCPeerConnection &&\n      window.RTCRtpSender && window.RTCRtpReceiver)) {\n    return;\n  }\n\n  // shim sender stats.\n  if (!('getStats' in window.RTCRtpSender.prototype)) {\n    const origGetSenders = window.RTCPeerConnection.prototype.getSenders;\n    if (origGetSenders) {\n      window.RTCPeerConnection.prototype.getSenders = function getSenders() {\n        const senders = origGetSenders.apply(this, []);\n        senders.forEach(sender => sender._pc = this);\n        return senders;\n      };\n    }\n\n    const origAddTrack = window.RTCPeerConnection.prototype.addTrack;\n    if (origAddTrack) {\n      window.RTCPeerConnection.prototype.addTrack = function addTrack() {\n        const sender = origAddTrack.apply(this, arguments);\n        sender._pc = this;\n        return sender;\n      };\n    }\n    window.RTCRtpSender.prototype.getStats = function getStats() {\n      const sender = this;\n      return this._pc.getStats().then(result =>\n        /* Note: this will include stats of all senders that\n         *   send a track with the same id as sender.track as\n         *   it is not possible to identify the RTCRtpSender.\n         */\n        utils.filterStats(result, sender.track, true));\n    };\n  }\n\n  // shim receiver stats.\n  if (!('getStats' in window.RTCRtpReceiver.prototype)) {\n    const origGetReceivers = window.RTCPeerConnection.prototype.getReceivers;\n    if (origGetReceivers) {\n      window.RTCPeerConnection.prototype.getReceivers =\n        function getReceivers() {\n          const receivers = origGetReceivers.apply(this, []);\n          receivers.forEach(receiver => receiver._pc = this);\n          return receivers;\n        };\n    }\n    utils.wrapPeerConnectionEvent(window, 'track', e => {\n      e.receiver._pc = e.srcElement;\n      return e;\n    });\n    window.RTCRtpReceiver.prototype.getStats = function getStats() {\n      const receiver = this;\n      return this._pc.getStats().then(result =>\n        utils.filterStats(result, receiver.track, false));\n    };\n  }\n\n  if (!('getStats' in window.RTCRtpSender.prototype &&\n      'getStats' in window.RTCRtpReceiver.prototype)) {\n    return;\n  }\n\n  // shim RTCPeerConnection.getStats(track).\n  const origGetStats = window.RTCPeerConnection.prototype.getStats;\n  window.RTCPeerConnection.prototype.getStats = function getStats() {\n    if (arguments.length > 0 &&\n        arguments[0] instanceof window.MediaStreamTrack) {\n      const track = arguments[0];\n      let sender;\n      let receiver;\n      let err;\n      this.getSenders().forEach(s => {\n        if (s.track === track) {\n          if (sender) {\n            err = true;\n          } else {\n            sender = s;\n          }\n        }\n      });\n      this.getReceivers().forEach(r => {\n        if (r.track === track) {\n          if (receiver) {\n            err = true;\n          } else {\n            receiver = r;\n          }\n        }\n        return r.track === track;\n      });\n      if (err || (sender && receiver)) {\n        return Promise.reject(new DOMException(\n          'There are more than one sender or receiver for the track.',\n          'InvalidAccessError'));\n      } else if (sender) {\n        return sender.getStats();\n      } else if (receiver) {\n        return receiver.getStats();\n      }\n      return Promise.reject(new DOMException(\n        'There is no sender or receiver for the track.',\n        'InvalidAccessError'));\n    }\n    return origGetStats.apply(this, arguments);\n  };\n}\n\nexport function shimAddTrackRemoveTrackWithNative(window) {\n  // shim addTrack/removeTrack with native variants in order to make\n  // the interactions with legacy getLocalStreams behave as in other browsers.\n  // Keeps a mapping stream.id => [stream, rtpsenders...]\n  window.RTCPeerConnection.prototype.getLocalStreams =\n    function getLocalStreams() {\n      this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n      return Object.keys(this._shimmedLocalStreams)\n        .map(streamId => this._shimmedLocalStreams[streamId][0]);\n    };\n\n  const origAddTrack = window.RTCPeerConnection.prototype.addTrack;\n  window.RTCPeerConnection.prototype.addTrack =\n    function addTrack(track, stream) {\n      if (!stream) {\n        return origAddTrack.apply(this, arguments);\n      }\n      this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n\n      const sender = origAddTrack.apply(this, arguments);\n      if (!this._shimmedLocalStreams[stream.id]) {\n        this._shimmedLocalStreams[stream.id] = [stream, sender];\n      } else if (this._shimmedLocalStreams[stream.id].indexOf(sender) === -1) {\n        this._shimmedLocalStreams[stream.id].push(sender);\n      }\n      return sender;\n    };\n\n  const origAddStream = window.RTCPeerConnection.prototype.addStream;\n  window.RTCPeerConnection.prototype.addStream = function addStream(stream) {\n    this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n\n    stream.getTracks().forEach(track => {\n      const alreadyExists = this.getSenders().find(s => s.track === track);\n      if (alreadyExists) {\n        throw new DOMException('Track already exists.',\n            'InvalidAccessError');\n      }\n    });\n    const existingSenders = this.getSenders();\n    origAddStream.apply(this, arguments);\n    const newSenders = this.getSenders()\n      .filter(newSender => existingSenders.indexOf(newSender) === -1);\n    this._shimmedLocalStreams[stream.id] = [stream].concat(newSenders);\n  };\n\n  const origRemoveStream = window.RTCPeerConnection.prototype.removeStream;\n  window.RTCPeerConnection.prototype.removeStream =\n    function removeStream(stream) {\n      this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n      delete this._shimmedLocalStreams[stream.id];\n      return origRemoveStream.apply(this, arguments);\n    };\n\n  const origRemoveTrack = window.RTCPeerConnection.prototype.removeTrack;\n  window.RTCPeerConnection.prototype.removeTrack =\n    function removeTrack(sender) {\n      this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n      if (sender) {\n        Object.keys(this._shimmedLocalStreams).forEach(streamId => {\n          const idx = this._shimmedLocalStreams[streamId].indexOf(sender);\n          if (idx !== -1) {\n            this._shimmedLocalStreams[streamId].splice(idx, 1);\n          }\n          if (this._shimmedLocalStreams[streamId].length === 1) {\n            delete this._shimmedLocalStreams[streamId];\n          }\n        });\n      }\n      return origRemoveTrack.apply(this, arguments);\n    };\n}\n\nexport function shimAddTrackRemoveTrack(window, browserDetails) {\n  if (!window.RTCPeerConnection) {\n    return;\n  }\n  // shim addTrack and removeTrack.\n  if (window.RTCPeerConnection.prototype.addTrack &&\n      browserDetails.version >= 65) {\n    return shimAddTrackRemoveTrackWithNative(window);\n  }\n\n  // also shim pc.getLocalStreams when addTrack is shimmed\n  // to return the original streams.\n  const origGetLocalStreams = window.RTCPeerConnection.prototype\n      .getLocalStreams;\n  window.RTCPeerConnection.prototype.getLocalStreams =\n    function getLocalStreams() {\n      const nativeStreams = origGetLocalStreams.apply(this);\n      this._reverseStreams = this._reverseStreams || {};\n      return nativeStreams.map(stream => this._reverseStreams[stream.id]);\n    };\n\n  const origAddStream = window.RTCPeerConnection.prototype.addStream;\n  window.RTCPeerConnection.prototype.addStream = function addStream(stream) {\n    this._streams = this._streams || {};\n    this._reverseStreams = this._reverseStreams || {};\n\n    stream.getTracks().forEach(track => {\n      const alreadyExists = this.getSenders().find(s => s.track === track);\n      if (alreadyExists) {\n        throw new DOMException('Track already exists.',\n            'InvalidAccessError');\n      }\n    });\n    // Add identity mapping for consistency with addTrack.\n    // Unless this is being used with a stream from addTrack.\n    if (!this._reverseStreams[stream.id]) {\n      const newStream = new window.MediaStream(stream.getTracks());\n      this._streams[stream.id] = newStream;\n      this._reverseStreams[newStream.id] = stream;\n      stream = newStream;\n    }\n    origAddStream.apply(this, [stream]);\n  };\n\n  const origRemoveStream = window.RTCPeerConnection.prototype.removeStream;\n  window.RTCPeerConnection.prototype.removeStream =\n    function removeStream(stream) {\n      this._streams = this._streams || {};\n      this._reverseStreams = this._reverseStreams || {};\n\n      origRemoveStream.apply(this, [(this._streams[stream.id] || stream)]);\n      delete this._reverseStreams[(this._streams[stream.id] ?\n          this._streams[stream.id].id : stream.id)];\n      delete this._streams[stream.id];\n    };\n\n  window.RTCPeerConnection.prototype.addTrack =\n    function addTrack(track, stream) {\n      if (this.signalingState === 'closed') {\n        throw new DOMException(\n          'The RTCPeerConnection\\'s signalingState is \\'closed\\'.',\n          'InvalidStateError');\n      }\n      const streams = [].slice.call(arguments, 1);\n      if (streams.length !== 1 ||\n          !streams[0].getTracks().find(t => t === track)) {\n        // this is not fully correct but all we can manage without\n        // [[associated MediaStreams]] internal slot.\n        throw new DOMException(\n          'The adapter.js addTrack polyfill only supports a single ' +\n          ' stream which is associated with the specified track.',\n          'NotSupportedError');\n      }\n\n      const alreadyExists = this.getSenders().find(s => s.track === track);\n      if (alreadyExists) {\n        throw new DOMException('Track already exists.',\n            'InvalidAccessError');\n      }\n\n      this._streams = this._streams || {};\n      this._reverseStreams = this._reverseStreams || {};\n      const oldStream = this._streams[stream.id];\n      if (oldStream) {\n        // this is using odd Chrome behaviour, use with caution:\n        // https://bugs.chromium.org/p/webrtc/issues/detail?id=7815\n        // Note: we rely on the high-level addTrack/dtmf shim to\n        // create the sender with a dtmf sender.\n        oldStream.addTrack(track);\n\n        // Trigger ONN async.\n        Promise.resolve().then(() => {\n          this.dispatchEvent(new Event('negotiationneeded'));\n        });\n      } else {\n        const newStream = new window.MediaStream([track]);\n        this._streams[stream.id] = newStream;\n        this._reverseStreams[newStream.id] = stream;\n        this.addStream(newStream);\n      }\n      return this.getSenders().find(s => s.track === track);\n    };\n\n  // replace the internal stream id with the external one and\n  // vice versa.\n  function replaceInternalStreamId(pc, description) {\n    let sdp = description.sdp;\n    Object.keys(pc._reverseStreams || []).forEach(internalId => {\n      const externalStream = pc._reverseStreams[internalId];\n      const internalStream = pc._streams[externalStream.id];\n      sdp = sdp.replace(new RegExp(internalStream.id, 'g'),\n          externalStream.id);\n    });\n    return new RTCSessionDescription({\n      type: description.type,\n      sdp\n    });\n  }\n  function replaceExternalStreamId(pc, description) {\n    let sdp = description.sdp;\n    Object.keys(pc._reverseStreams || []).forEach(internalId => {\n      const externalStream = pc._reverseStreams[internalId];\n      const internalStream = pc._streams[externalStream.id];\n      sdp = sdp.replace(new RegExp(externalStream.id, 'g'),\n          internalStream.id);\n    });\n    return new RTCSessionDescription({\n      type: description.type,\n      sdp\n    });\n  }\n  ['createOffer', 'createAnswer'].forEach(function(method) {\n    const nativeMethod = window.RTCPeerConnection.prototype[method];\n    const methodObj = {[method]() {\n      const args = arguments;\n      const isLegacyCall = arguments.length &&\n          typeof arguments[0] === 'function';\n      if (isLegacyCall) {\n        return nativeMethod.apply(this, [\n          (description) => {\n            const desc = replaceInternalStreamId(this, description);\n            args[0].apply(null, [desc]);\n          },\n          (err) => {\n            if (args[1]) {\n              args[1].apply(null, err);\n            }\n          }, arguments[2]\n        ]);\n      }\n      return nativeMethod.apply(this, arguments)\n      .then(description => replaceInternalStreamId(this, description));\n    }};\n    window.RTCPeerConnection.prototype[method] = methodObj[method];\n  });\n\n  const origSetLocalDescription =\n      window.RTCPeerConnection.prototype.setLocalDescription;\n  window.RTCPeerConnection.prototype.setLocalDescription =\n    function setLocalDescription() {\n      if (!arguments.length || !arguments[0].type) {\n        return origSetLocalDescription.apply(this, arguments);\n      }\n      arguments[0] = replaceExternalStreamId(this, arguments[0]);\n      return origSetLocalDescription.apply(this, arguments);\n    };\n\n  // TODO: mangle getStats: https://w3c.github.io/webrtc-stats/#dom-rtcmediastreamstats-streamidentifier\n\n  const origLocalDescription = Object.getOwnPropertyDescriptor(\n      window.RTCPeerConnection.prototype, 'localDescription');\n  Object.defineProperty(window.RTCPeerConnection.prototype,\n      'localDescription', {\n        get() {\n          const description = origLocalDescription.get.apply(this);\n          if (description.type === '') {\n            return description;\n          }\n          return replaceInternalStreamId(this, description);\n        }\n      });\n\n  window.RTCPeerConnection.prototype.removeTrack =\n    function removeTrack(sender) {\n      if (this.signalingState === 'closed') {\n        throw new DOMException(\n          'The RTCPeerConnection\\'s signalingState is \\'closed\\'.',\n          'InvalidStateError');\n      }\n      // We can not yet check for sender instanceof RTCRtpSender\n      // since we shim RTPSender. So we check if sender._pc is set.\n      if (!sender._pc) {\n        throw new DOMException('Argument 1 of RTCPeerConnection.removeTrack ' +\n            'does not implement interface RTCRtpSender.', 'TypeError');\n      }\n      const isLocal = sender._pc === this;\n      if (!isLocal) {\n        throw new DOMException('Sender was not created by this connection.',\n            'InvalidAccessError');\n      }\n\n      // Search for the native stream the senders track belongs to.\n      this._streams = this._streams || {};\n      let stream;\n      Object.keys(this._streams).forEach(streamid => {\n        const hasTrack = this._streams[streamid].getTracks()\n          .find(track => sender.track === track);\n        if (hasTrack) {\n          stream = this._streams[streamid];\n        }\n      });\n\n      if (stream) {\n        if (stream.getTracks().length === 1) {\n          // if this is the last track of the stream, remove the stream. This\n          // takes care of any shimmed _senders.\n          this.removeStream(this._reverseStreams[stream.id]);\n        } else {\n          // relying on the same odd chrome behaviour as above.\n          stream.removeTrack(sender.track);\n        }\n        this.dispatchEvent(new Event('negotiationneeded'));\n      }\n    };\n}\n\nexport function shimPeerConnection(window, browserDetails) {\n  if (!window.RTCPeerConnection && window.webkitRTCPeerConnection) {\n    // very basic support for old versions.\n    window.RTCPeerConnection = window.webkitRTCPeerConnection;\n  }\n  if (!window.RTCPeerConnection) {\n    return;\n  }\n\n  // shim implicit creation of RTCSessionDescription/RTCIceCandidate\n  if (browserDetails.version < 53) {\n    ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate']\n        .forEach(function(method) {\n          const nativeMethod = window.RTCPeerConnection.prototype[method];\n          const methodObj = {[method]() {\n            arguments[0] = new ((method === 'addIceCandidate') ?\n                window.RTCIceCandidate :\n                window.RTCSessionDescription)(arguments[0]);\n            return nativeMethod.apply(this, arguments);\n          }};\n          window.RTCPeerConnection.prototype[method] = methodObj[method];\n        });\n  }\n}\n\n// Attempt to fix ONN in plan-b mode.\nexport function fixNegotiationNeeded(window, browserDetails) {\n  utils.wrapPeerConnectionEvent(window, 'negotiationneeded', e => {\n    const pc = e.target;\n    if (browserDetails.version < 72 || (pc.getConfiguration &&\n        pc.getConfiguration().sdpSemantics === 'plan-b')) {\n      if (pc.signalingState !== 'stable') {\n        return;\n      }\n    }\n    return e;\n  });\n}\n"]},"metadata":{},"sourceType":"module"}