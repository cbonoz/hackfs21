{"ast":null,"code":"import { CompletionItemKind } from 'vscode-languageserver-types';\nimport { isInterfaceType, GraphQLInterfaceType, GraphQLObjectType } from 'graphql';\nimport { GraphQLBoolean, GraphQLEnumType, GraphQLInputObjectType, GraphQLList, SchemaMetaFieldDef, TypeMetaFieldDef, TypeNameMetaFieldDef, assertAbstractType, doTypesOverlap, getNamedType, getNullableType, isAbstractType, isCompositeType, isInputType, visit, parse } from 'graphql';\nimport { CharacterStream, onlineParser, RuleKinds } from 'graphql-language-service-parser';\nimport { forEachState, getDefinitionState, getFieldDef, hintList, objectValues } from './autocompleteUtils';\n\nconst collectFragmentDefs = op => {\n  const externalFragments = [];\n\n  if (op) {\n    visit(parse(op, {\n      experimentalFragmentVariables: true\n    }), {\n      FragmentDefinition(def) {\n        externalFragments.push(def);\n      }\n\n    });\n  }\n\n  return externalFragments;\n};\n\nexport function getAutocompleteSuggestions(schema, queryText, cursor, contextToken, fragmentDefs) {\n  var _a;\n\n  const token = contextToken || getTokenAtPosition(queryText, cursor);\n  const state = token.state.kind === 'Invalid' ? token.state.prevState : token.state;\n\n  if (!state) {\n    return [];\n  }\n\n  const kind = state.kind;\n  const step = state.step;\n  const typeInfo = getTypeInfo(schema, token.state);\n\n  if (kind === RuleKinds.DOCUMENT) {\n    return hintList(token, [{\n      label: 'query',\n      kind: CompletionItemKind.Function\n    }, {\n      label: 'mutation',\n      kind: CompletionItemKind.Function\n    }, {\n      label: 'subscription',\n      kind: CompletionItemKind.Function\n    }, {\n      label: 'fragment',\n      kind: CompletionItemKind.Function\n    }, {\n      label: '{',\n      kind: CompletionItemKind.Constructor\n    }]);\n  }\n\n  if (kind === RuleKinds.IMPLEMENTS || kind === RuleKinds.NAMED_TYPE && ((_a = state.prevState) === null || _a === void 0 ? void 0 : _a.kind) === RuleKinds.IMPLEMENTS) {\n    return getSuggestionsForImplements(token, state, schema, queryText, typeInfo);\n  }\n\n  if (kind === RuleKinds.SELECTION_SET || kind === RuleKinds.FIELD || kind === RuleKinds.ALIASED_FIELD) {\n    return getSuggestionsForFieldNames(token, typeInfo, schema);\n  }\n\n  if (kind === RuleKinds.ARGUMENTS || kind === RuleKinds.ARGUMENT && step === 0) {\n    const argDefs = typeInfo.argDefs;\n\n    if (argDefs) {\n      return hintList(token, argDefs.map(argDef => {\n        var _a;\n\n        return {\n          label: argDef.name,\n          detail: String(argDef.type),\n          documentation: (_a = argDef.description) !== null && _a !== void 0 ? _a : undefined,\n          kind: CompletionItemKind.Variable,\n          type: argDef.type\n        };\n      }));\n    }\n  }\n\n  if (kind === RuleKinds.OBJECT_VALUE || kind === RuleKinds.OBJECT_FIELD && step === 0) {\n    if (typeInfo.objectFieldDefs) {\n      const objectFields = objectValues(typeInfo.objectFieldDefs);\n      const completionKind = kind === RuleKinds.OBJECT_VALUE ? CompletionItemKind.Value : CompletionItemKind.Field;\n      return hintList(token, objectFields.map(field => {\n        var _a;\n\n        return {\n          label: field.name,\n          detail: String(field.type),\n          documentation: (_a = field.description) !== null && _a !== void 0 ? _a : undefined,\n          kind: completionKind,\n          type: field.type\n        };\n      }));\n    }\n  }\n\n  if (kind === RuleKinds.ENUM_VALUE || kind === RuleKinds.LIST_VALUE && step === 1 || kind === RuleKinds.OBJECT_FIELD && step === 2 || kind === RuleKinds.ARGUMENT && step === 2) {\n    return getSuggestionsForInputValues(token, typeInfo, queryText, schema);\n  }\n\n  if (kind === RuleKinds.VARIABLE && step === 1) {\n    const namedInputType = getNamedType(typeInfo.inputType);\n    const variableDefinitions = getVariableCompletions(queryText, schema);\n    return hintList(token, variableDefinitions.filter(v => v.detail === (namedInputType === null || namedInputType === void 0 ? void 0 : namedInputType.name)));\n  }\n\n  if (kind === RuleKinds.TYPE_CONDITION && step === 1 || kind === RuleKinds.NAMED_TYPE && state.prevState != null && state.prevState.kind === RuleKinds.TYPE_CONDITION) {\n    return getSuggestionsForFragmentTypeConditions(token, typeInfo, schema, kind);\n  }\n\n  if (kind === RuleKinds.FRAGMENT_SPREAD && step === 1) {\n    return getSuggestionsForFragmentSpread(token, typeInfo, schema, queryText, Array.isArray(fragmentDefs) ? fragmentDefs : collectFragmentDefs(fragmentDefs));\n  }\n\n  if (kind === RuleKinds.VARIABLE_DEFINITION && step === 2 || kind === RuleKinds.LIST_TYPE && step === 1 || kind === RuleKinds.NAMED_TYPE && state.prevState && (state.prevState.kind === RuleKinds.VARIABLE_DEFINITION || state.prevState.kind === RuleKinds.LIST_TYPE || state.prevState.kind === RuleKinds.NON_NULL_TYPE)) {\n    return getSuggestionsForVariableDefinition(token, schema, kind);\n  }\n\n  if (kind === RuleKinds.DIRECTIVE) {\n    return getSuggestionsForDirective(token, state, schema, kind);\n  }\n\n  return [];\n}\n\nfunction getSuggestionsForFieldNames(token, typeInfo, schema) {\n  if (typeInfo.parentType) {\n    const parentType = typeInfo.parentType;\n    let fields = [];\n\n    if ('getFields' in parentType) {\n      fields = objectValues(parentType.getFields());\n    }\n\n    if (isCompositeType(parentType)) {\n      fields.push(TypeNameMetaFieldDef);\n    }\n\n    if (parentType === schema.getQueryType()) {\n      fields.push(SchemaMetaFieldDef, TypeMetaFieldDef);\n    }\n\n    return hintList(token, fields.map((field, index) => {\n      var _a;\n\n      return {\n        sortText: String(index) + field.name,\n        label: field.name,\n        detail: String(field.type),\n        documentation: (_a = field.description) !== null && _a !== void 0 ? _a : undefined,\n        deprecated: field.isDeprecated,\n        isDeprecated: field.isDeprecated,\n        deprecationReason: field.deprecationReason,\n        kind: CompletionItemKind.Field,\n        type: field.type\n      };\n    }));\n  }\n\n  return [];\n}\n\nfunction getSuggestionsForInputValues(token, typeInfo, queryText, schema) {\n  const namedInputType = getNamedType(typeInfo.inputType);\n  const queryVariables = getVariableCompletions(queryText, schema, true).filter(v => v.detail === namedInputType.name);\n\n  if (namedInputType instanceof GraphQLEnumType) {\n    const values = namedInputType.getValues();\n    return hintList(token, values.map(value => {\n      var _a;\n\n      return {\n        label: value.name,\n        detail: String(namedInputType),\n        documentation: (_a = value.description) !== null && _a !== void 0 ? _a : undefined,\n        deprecated: value.isDeprecated,\n        isDeprecated: value.isDeprecated,\n        deprecationReason: value.deprecationReason,\n        kind: CompletionItemKind.EnumMember,\n        type: namedInputType\n      };\n    }).concat(queryVariables));\n  } else if (namedInputType === GraphQLBoolean) {\n    return hintList(token, queryVariables.concat([{\n      label: 'true',\n      detail: String(GraphQLBoolean),\n      documentation: 'Not false.',\n      kind: CompletionItemKind.Variable,\n      type: GraphQLBoolean\n    }, {\n      label: 'false',\n      detail: String(GraphQLBoolean),\n      documentation: 'Not true.',\n      kind: CompletionItemKind.Variable,\n      type: GraphQLBoolean\n    }]));\n  }\n\n  return queryVariables;\n}\n\nfunction getSuggestionsForImplements(token, tokenState, schema, documentText, typeInfo) {\n  if (tokenState.needsSeperator) {\n    return [];\n  }\n\n  const typeMap = schema.getTypeMap();\n  const schemaInterfaces = objectValues(typeMap).filter(isInterfaceType);\n  const schemaInterfaceNames = schemaInterfaces.map(({\n    name\n  }) => name);\n  const inlineInterfaces = new Set();\n  runOnlineParser(documentText, (_, state) => {\n    var _a, _b, _c, _d, _e;\n\n    if (state.name) {\n      if (state.kind === RuleKinds.INTERFACE_DEF && !schemaInterfaceNames.includes(state.name)) {\n        inlineInterfaces.add(state.name);\n      }\n\n      if (state.kind === RuleKinds.NAMED_TYPE && ((_a = state.prevState) === null || _a === void 0 ? void 0 : _a.kind) === RuleKinds.IMPLEMENTS) {\n        if (typeInfo.interfaceDef) {\n          const existingType = (_b = typeInfo.interfaceDef) === null || _b === void 0 ? void 0 : _b.getInterfaces().find(({\n            name\n          }) => name === state.name);\n\n          if (existingType) {\n            return;\n          }\n\n          const type = schema.getType(state.name);\n          const interfaceConfig = (_c = typeInfo.interfaceDef) === null || _c === void 0 ? void 0 : _c.toConfig();\n          typeInfo.interfaceDef = new GraphQLInterfaceType(Object.assign(Object.assign({}, interfaceConfig), {\n            interfaces: [...interfaceConfig.interfaces, type || new GraphQLInterfaceType({\n              name: state.name,\n              fields: {}\n            })]\n          }));\n        } else if (typeInfo.objectTypeDef) {\n          const existingType = (_d = typeInfo.objectTypeDef) === null || _d === void 0 ? void 0 : _d.getInterfaces().find(({\n            name\n          }) => name === state.name);\n\n          if (existingType) {\n            return;\n          }\n\n          const type = schema.getType(state.name);\n          const objectTypeConfig = (_e = typeInfo.objectTypeDef) === null || _e === void 0 ? void 0 : _e.toConfig();\n          typeInfo.objectTypeDef = new GraphQLObjectType(Object.assign(Object.assign({}, objectTypeConfig), {\n            interfaces: [...objectTypeConfig.interfaces, type || new GraphQLInterfaceType({\n              name: state.name,\n              fields: {}\n            })]\n          }));\n        }\n      }\n    }\n  });\n  const currentTypeToExtend = typeInfo.interfaceDef || typeInfo.objectTypeDef;\n  const siblingInterfaces = (currentTypeToExtend === null || currentTypeToExtend === void 0 ? void 0 : currentTypeToExtend.getInterfaces()) || [];\n  const siblingInterfaceNames = siblingInterfaces.map(({\n    name\n  }) => name);\n  const possibleInterfaces = schemaInterfaces.concat([...inlineInterfaces].map(name => ({\n    name\n  }))).filter(({\n    name\n  }) => name !== (currentTypeToExtend === null || currentTypeToExtend === void 0 ? void 0 : currentTypeToExtend.name) && !siblingInterfaceNames.includes(name));\n  return hintList(token, possibleInterfaces.map(type => {\n    const result = {\n      label: type.name,\n      kind: CompletionItemKind.Interface,\n      type\n    };\n\n    if (type === null || type === void 0 ? void 0 : type.description) {\n      result.documentation = type.description;\n    }\n\n    return result;\n  }));\n}\n\nfunction getSuggestionsForFragmentTypeConditions(token, typeInfo, schema, _kind) {\n  let possibleTypes;\n\n  if (typeInfo.parentType) {\n    if (isAbstractType(typeInfo.parentType)) {\n      const abstractType = assertAbstractType(typeInfo.parentType);\n      const possibleObjTypes = schema.getPossibleTypes(abstractType);\n      const possibleIfaceMap = Object.create(null);\n      possibleObjTypes.forEach(type => {\n        type.getInterfaces().forEach(iface => {\n          possibleIfaceMap[iface.name] = iface;\n        });\n      });\n      possibleTypes = possibleObjTypes.concat(objectValues(possibleIfaceMap));\n    } else {\n      possibleTypes = [typeInfo.parentType];\n    }\n  } else {\n    const typeMap = schema.getTypeMap();\n    possibleTypes = objectValues(typeMap).filter(isCompositeType);\n  }\n\n  return hintList(token, possibleTypes.map(type => {\n    const namedType = getNamedType(type);\n    return {\n      label: String(type),\n      documentation: namedType && namedType.description || '',\n      kind: CompletionItemKind.Field\n    };\n  }));\n}\n\nfunction getSuggestionsForFragmentSpread(token, typeInfo, schema, queryText, fragmentDefs) {\n  if (!queryText) {\n    return [];\n  }\n\n  const typeMap = schema.getTypeMap();\n  const defState = getDefinitionState(token.state);\n  const fragments = getFragmentDefinitions(queryText);\n\n  if (fragmentDefs && fragmentDefs.length > 0) {\n    fragments.push(...fragmentDefs);\n  }\n\n  const relevantFrags = fragments.filter(frag => typeMap[frag.typeCondition.name.value] && !(defState && defState.kind === RuleKinds.FRAGMENT_DEFINITION && defState.name === frag.name.value) && isCompositeType(typeInfo.parentType) && isCompositeType(typeMap[frag.typeCondition.name.value]) && doTypesOverlap(schema, typeInfo.parentType, typeMap[frag.typeCondition.name.value]));\n  return hintList(token, relevantFrags.map(frag => ({\n    label: frag.name.value,\n    detail: String(typeMap[frag.typeCondition.name.value]),\n    documentation: `fragment ${frag.name.value} on ${frag.typeCondition.name.value}`,\n    kind: CompletionItemKind.Field,\n    type: typeMap[frag.typeCondition.name.value]\n  })));\n}\n\nconst getParentDefinition = (state, kind) => {\n  var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;\n\n  if (((_a = state.prevState) === null || _a === void 0 ? void 0 : _a.kind) === kind) {\n    return state.prevState;\n  }\n\n  if (((_c = (_b = state.prevState) === null || _b === void 0 ? void 0 : _b.prevState) === null || _c === void 0 ? void 0 : _c.kind) === kind) {\n    return state.prevState.prevState;\n  }\n\n  if (((_f = (_e = (_d = state.prevState) === null || _d === void 0 ? void 0 : _d.prevState) === null || _e === void 0 ? void 0 : _e.prevState) === null || _f === void 0 ? void 0 : _f.kind) === kind) {\n    return state.prevState.prevState.prevState;\n  }\n\n  if (((_k = (_j = (_h = (_g = state.prevState) === null || _g === void 0 ? void 0 : _g.prevState) === null || _h === void 0 ? void 0 : _h.prevState) === null || _j === void 0 ? void 0 : _j.prevState) === null || _k === void 0 ? void 0 : _k.kind) === kind) {\n    return state.prevState.prevState.prevState.prevState;\n  }\n};\n\nexport function getVariableCompletions(queryText, schema, forcePrefix = false) {\n  let variableName;\n  let variableType;\n  const definitions = Object.create({});\n  runOnlineParser(queryText, (_, state) => {\n    if (state.kind === RuleKinds.VARIABLE && state.name) {\n      variableName = state.name;\n    }\n\n    if (state.kind === RuleKinds.NAMED_TYPE && variableName) {\n      const parentDefinition = getParentDefinition(state, RuleKinds.TYPE);\n\n      if (parentDefinition === null || parentDefinition === void 0 ? void 0 : parentDefinition.type) {\n        variableType = schema.getType(parentDefinition === null || parentDefinition === void 0 ? void 0 : parentDefinition.type);\n      }\n    }\n\n    if (variableName && variableType) {\n      if (!definitions[variableName]) {\n        definitions[variableName] = {\n          detail: variableType.toString(),\n          label: `$${variableName}`,\n          type: variableType,\n          kind: CompletionItemKind.Variable\n        };\n\n        if (forcePrefix) {\n          definitions[variableName].insertText = `$${variableName}`;\n        }\n\n        variableName = null;\n        variableType = null;\n      }\n    }\n  });\n  return objectValues(definitions);\n}\nexport function getFragmentDefinitions(queryText) {\n  const fragmentDefs = [];\n  runOnlineParser(queryText, (_, state) => {\n    if (state.kind === RuleKinds.FRAGMENT_DEFINITION && state.name && state.type) {\n      fragmentDefs.push({\n        kind: RuleKinds.FRAGMENT_DEFINITION,\n        name: {\n          kind: 'Name',\n          value: state.name\n        },\n        selectionSet: {\n          kind: RuleKinds.SELECTION_SET,\n          selections: []\n        },\n        typeCondition: {\n          kind: RuleKinds.NAMED_TYPE,\n          name: {\n            kind: 'Name',\n            value: state.type\n          }\n        }\n      });\n    }\n  });\n  return fragmentDefs;\n}\n\nfunction getSuggestionsForVariableDefinition(token, schema, _kind) {\n  const inputTypeMap = schema.getTypeMap();\n  const inputTypes = objectValues(inputTypeMap).filter(isInputType);\n  return hintList(token, inputTypes.map(type => ({\n    label: type.name,\n    documentation: type.description,\n    kind: CompletionItemKind.Variable\n  })));\n}\n\nfunction getSuggestionsForDirective(token, state, schema, _kind) {\n  if (state.prevState && state.prevState.kind) {\n    const directives = schema.getDirectives().filter(directive => canUseDirective(state.prevState, directive));\n    return hintList(token, directives.map(directive => ({\n      label: directive.name,\n      documentation: directive.description || '',\n      kind: CompletionItemKind.Function\n    })));\n  }\n\n  return [];\n}\n\nexport function getTokenAtPosition(queryText, cursor) {\n  let styleAtCursor = null;\n  let stateAtCursor = null;\n  let stringAtCursor = null;\n  const token = runOnlineParser(queryText, (stream, state, style, index) => {\n    if (index === cursor.line) {\n      if (stream.getCurrentPosition() >= cursor.character) {\n        styleAtCursor = style;\n        stateAtCursor = Object.assign({}, state);\n        stringAtCursor = stream.current();\n        return 'BREAK';\n      }\n    }\n  });\n  return {\n    start: token.start,\n    end: token.end,\n    string: stringAtCursor || token.string,\n    state: stateAtCursor || token.state,\n    style: styleAtCursor || token.style\n  };\n}\nexport function runOnlineParser(queryText, callback) {\n  const lines = queryText.split('\\n');\n  const parser = onlineParser();\n  let state = parser.startState();\n  let style = '';\n  let stream = new CharacterStream('');\n\n  for (let i = 0; i < lines.length; i++) {\n    stream = new CharacterStream(lines[i]);\n\n    while (!stream.eol()) {\n      style = parser.token(stream, state);\n      const code = callback(stream, state, style, i);\n\n      if (code === 'BREAK') {\n        break;\n      }\n    }\n\n    callback(stream, state, style, i);\n\n    if (!state.kind) {\n      state = parser.startState();\n    }\n  }\n\n  return {\n    start: stream.getStartOfToken(),\n    end: stream.getCurrentPosition(),\n    string: stream.current(),\n    state,\n    style\n  };\n}\nexport function canUseDirective(state, directive) {\n  if (!state || !state.kind) {\n    return false;\n  }\n\n  const kind = state.kind;\n  const locations = directive.locations;\n\n  switch (kind) {\n    case RuleKinds.QUERY:\n      return locations.indexOf('QUERY') !== -1;\n\n    case RuleKinds.MUTATION:\n      return locations.indexOf('MUTATION') !== -1;\n\n    case RuleKinds.SUBSCRIPTION:\n      return locations.indexOf('SUBSCRIPTION') !== -1;\n\n    case RuleKinds.FIELD:\n    case RuleKinds.ALIASED_FIELD:\n      return locations.indexOf('FIELD') !== -1;\n\n    case RuleKinds.FRAGMENT_DEFINITION:\n      return locations.indexOf('FRAGMENT_DEFINITION') !== -1;\n\n    case RuleKinds.FRAGMENT_SPREAD:\n      return locations.indexOf('FRAGMENT_SPREAD') !== -1;\n\n    case RuleKinds.INLINE_FRAGMENT:\n      return locations.indexOf('INLINE_FRAGMENT') !== -1;\n\n    case RuleKinds.SCHEMA_DEF:\n      return locations.indexOf('SCHEMA') !== -1;\n\n    case RuleKinds.SCALAR_DEF:\n      return locations.indexOf('SCALAR') !== -1;\n\n    case RuleKinds.OBJECT_TYPE_DEF:\n      return locations.indexOf('OBJECT') !== -1;\n\n    case RuleKinds.FIELD_DEF:\n      return locations.indexOf('FIELD_DEFINITION') !== -1;\n\n    case RuleKinds.INTERFACE_DEF:\n      return locations.indexOf('INTERFACE') !== -1;\n\n    case RuleKinds.UNION_DEF:\n      return locations.indexOf('UNION') !== -1;\n\n    case RuleKinds.ENUM_DEF:\n      return locations.indexOf('ENUM') !== -1;\n\n    case RuleKinds.ENUM_VALUE:\n      return locations.indexOf('ENUM_VALUE') !== -1;\n\n    case RuleKinds.INPUT_DEF:\n      return locations.indexOf('INPUT_OBJECT') !== -1;\n\n    case RuleKinds.INPUT_VALUE_DEF:\n      const prevStateKind = state.prevState && state.prevState.kind;\n\n      switch (prevStateKind) {\n        case RuleKinds.ARGUMENTS_DEF:\n          return locations.indexOf('ARGUMENT_DEFINITION') !== -1;\n\n        case RuleKinds.INPUT_DEF:\n          return locations.indexOf('INPUT_FIELD_DEFINITION') !== -1;\n      }\n\n  }\n\n  return false;\n}\nexport function getTypeInfo(schema, tokenState) {\n  let argDef;\n  let argDefs;\n  let directiveDef;\n  let enumValue;\n  let fieldDef;\n  let inputType;\n  let objectTypeDef;\n  let objectFieldDefs;\n  let parentType;\n  let type;\n  let interfaceDef;\n  forEachState(tokenState, state => {\n    switch (state.kind) {\n      case RuleKinds.QUERY:\n      case 'ShortQuery':\n        type = schema.getQueryType();\n        break;\n\n      case RuleKinds.MUTATION:\n        type = schema.getMutationType();\n        break;\n\n      case RuleKinds.SUBSCRIPTION:\n        type = schema.getSubscriptionType();\n        break;\n\n      case RuleKinds.INLINE_FRAGMENT:\n      case RuleKinds.FRAGMENT_DEFINITION:\n        if (state.type) {\n          type = schema.getType(state.type);\n        }\n\n        break;\n\n      case RuleKinds.FIELD:\n      case RuleKinds.ALIASED_FIELD:\n        {\n          if (!type || !state.name) {\n            fieldDef = null;\n          } else {\n            fieldDef = parentType ? getFieldDef(schema, parentType, state.name) : null;\n            type = fieldDef ? fieldDef.type : null;\n          }\n\n          break;\n        }\n\n      case RuleKinds.SELECTION_SET:\n        parentType = getNamedType(type);\n        break;\n\n      case RuleKinds.DIRECTIVE:\n        directiveDef = state.name ? schema.getDirective(state.name) : null;\n        break;\n\n      case RuleKinds.INTERFACE_DEF:\n        if (state.name) {\n          objectTypeDef = null;\n          interfaceDef = new GraphQLInterfaceType({\n            name: state.name,\n            interfaces: [],\n            fields: {}\n          });\n        }\n\n        break;\n\n      case RuleKinds.OBJECT_TYPE_DEF:\n        if (state.name) {\n          interfaceDef = null;\n          objectTypeDef = new GraphQLObjectType({\n            name: state.name,\n            interfaces: [],\n            fields: {}\n          });\n        }\n\n        break;\n\n      case RuleKinds.ARGUMENTS:\n        {\n          if (!state.prevState) {\n            argDefs = null;\n          } else {\n            switch (state.prevState.kind) {\n              case RuleKinds.FIELD:\n                argDefs = fieldDef && fieldDef.args;\n                break;\n\n              case RuleKinds.DIRECTIVE:\n                argDefs = directiveDef && directiveDef.args;\n                break;\n\n              case RuleKinds.ALIASED_FIELD:\n                {\n                  const name = state.prevState && state.prevState.name;\n\n                  if (!name) {\n                    argDefs = null;\n                    break;\n                  }\n\n                  const field = parentType ? getFieldDef(schema, parentType, name) : null;\n\n                  if (!field) {\n                    argDefs = null;\n                    break;\n                  }\n\n                  argDefs = field.args;\n                  break;\n                }\n\n              default:\n                argDefs = null;\n                break;\n            }\n          }\n\n          break;\n        }\n\n      case RuleKinds.ARGUMENT:\n        if (argDefs) {\n          for (let i = 0; i < argDefs.length; i++) {\n            if (argDefs[i].name === state.name) {\n              argDef = argDefs[i];\n              break;\n            }\n          }\n        }\n\n        inputType = argDef && argDef.type;\n        break;\n\n      case RuleKinds.ENUM_VALUE:\n        const enumType = getNamedType(inputType);\n        enumValue = enumType instanceof GraphQLEnumType ? find(enumType.getValues(), val => val.value === state.name) : null;\n        break;\n\n      case RuleKinds.LIST_VALUE:\n        const nullableType = getNullableType(inputType);\n        inputType = nullableType instanceof GraphQLList ? nullableType.ofType : null;\n        break;\n\n      case RuleKinds.OBJECT_VALUE:\n        const objectType = getNamedType(inputType);\n        objectFieldDefs = objectType instanceof GraphQLInputObjectType ? objectType.getFields() : null;\n        break;\n\n      case RuleKinds.OBJECT_FIELD:\n        const objectField = state.name && objectFieldDefs ? objectFieldDefs[state.name] : null;\n        inputType = objectField && objectField.type;\n        break;\n\n      case RuleKinds.NAMED_TYPE:\n        if (state.name) {\n          type = schema.getType(state.name);\n        }\n\n        break;\n    }\n  });\n  return {\n    argDef,\n    argDefs,\n    directiveDef,\n    enumValue,\n    fieldDef,\n    inputType,\n    objectFieldDefs,\n    parentType,\n    type,\n    interfaceDef,\n    objectTypeDef\n  };\n}\n\nfunction find(array, predicate) {\n  for (let i = 0; i < array.length; i++) {\n    if (predicate(array[i])) {\n      return array[i];\n    }\n  }\n\n  return null;\n}","map":{"version":3,"sources":["../src/getAutocompleteSuggestions.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { CompletionItemKind } from 'vscode-languageserver-types';\nimport { isInterfaceType, GraphQLInterfaceType, GraphQLObjectType, } from 'graphql';\nimport { GraphQLBoolean, GraphQLEnumType, GraphQLInputObjectType, GraphQLList, SchemaMetaFieldDef, TypeMetaFieldDef, TypeNameMetaFieldDef, assertAbstractType, doTypesOverlap, getNamedType, getNullableType, isAbstractType, isCompositeType, isInputType, visit, parse, } from 'graphql';\nimport { CharacterStream, onlineParser, RuleKinds, } from 'graphql-language-service-parser';\nimport { forEachState, getDefinitionState, getFieldDef, hintList, objectValues, } from './autocompleteUtils';\nconst collectFragmentDefs = (op) => {\n    const externalFragments = [];\n    if (op) {\n        visit(parse(op, {\n            experimentalFragmentVariables: true,\n        }), {\n            FragmentDefinition(def) {\n                externalFragments.push(def);\n            },\n        });\n    }\n    return externalFragments;\n};\nexport function getAutocompleteSuggestions(schema, queryText, cursor, contextToken, fragmentDefs) {\n    var _a;\n    const token = contextToken || getTokenAtPosition(queryText, cursor);\n    const state = token.state.kind === 'Invalid' ? token.state.prevState : token.state;\n    if (!state) {\n        return [];\n    }\n    const kind = state.kind;\n    const step = state.step;\n    const typeInfo = getTypeInfo(schema, token.state);\n    if (kind === RuleKinds.DOCUMENT) {\n        return hintList(token, [\n            { label: 'query', kind: CompletionItemKind.Function },\n            { label: 'mutation', kind: CompletionItemKind.Function },\n            { label: 'subscription', kind: CompletionItemKind.Function },\n            { label: 'fragment', kind: CompletionItemKind.Function },\n            { label: '{', kind: CompletionItemKind.Constructor },\n        ]);\n    }\n    if (kind === RuleKinds.IMPLEMENTS ||\n        (kind === RuleKinds.NAMED_TYPE &&\n            ((_a = state.prevState) === null || _a === void 0 ? void 0 : _a.kind) === RuleKinds.IMPLEMENTS)) {\n        return getSuggestionsForImplements(token, state, schema, queryText, typeInfo);\n    }\n    if (kind === RuleKinds.SELECTION_SET ||\n        kind === RuleKinds.FIELD ||\n        kind === RuleKinds.ALIASED_FIELD) {\n        return getSuggestionsForFieldNames(token, typeInfo, schema);\n    }\n    if (kind === RuleKinds.ARGUMENTS ||\n        (kind === RuleKinds.ARGUMENT && step === 0)) {\n        const argDefs = typeInfo.argDefs;\n        if (argDefs) {\n            return hintList(token, argDefs.map(argDef => {\n                var _a;\n                return ({\n                    label: argDef.name,\n                    detail: String(argDef.type),\n                    documentation: (_a = argDef.description) !== null && _a !== void 0 ? _a : undefined,\n                    kind: CompletionItemKind.Variable,\n                    type: argDef.type,\n                });\n            }));\n        }\n    }\n    if (kind === RuleKinds.OBJECT_VALUE ||\n        (kind === RuleKinds.OBJECT_FIELD && step === 0)) {\n        if (typeInfo.objectFieldDefs) {\n            const objectFields = objectValues(typeInfo.objectFieldDefs);\n            const completionKind = kind === RuleKinds.OBJECT_VALUE\n                ? CompletionItemKind.Value\n                : CompletionItemKind.Field;\n            return hintList(token, objectFields.map(field => {\n                var _a;\n                return ({\n                    label: field.name,\n                    detail: String(field.type),\n                    documentation: (_a = field.description) !== null && _a !== void 0 ? _a : undefined,\n                    kind: completionKind,\n                    type: field.type,\n                });\n            }));\n        }\n    }\n    if (kind === RuleKinds.ENUM_VALUE ||\n        (kind === RuleKinds.LIST_VALUE && step === 1) ||\n        (kind === RuleKinds.OBJECT_FIELD && step === 2) ||\n        (kind === RuleKinds.ARGUMENT && step === 2)) {\n        return getSuggestionsForInputValues(token, typeInfo, queryText, schema);\n    }\n    if (kind === RuleKinds.VARIABLE && step === 1) {\n        const namedInputType = getNamedType(typeInfo.inputType);\n        const variableDefinitions = getVariableCompletions(queryText, schema);\n        return hintList(token, variableDefinitions.filter(v => v.detail === (namedInputType === null || namedInputType === void 0 ? void 0 : namedInputType.name)));\n    }\n    if ((kind === RuleKinds.TYPE_CONDITION && step === 1) ||\n        (kind === RuleKinds.NAMED_TYPE &&\n            state.prevState != null &&\n            state.prevState.kind === RuleKinds.TYPE_CONDITION)) {\n        return getSuggestionsForFragmentTypeConditions(token, typeInfo, schema, kind);\n    }\n    if (kind === RuleKinds.FRAGMENT_SPREAD && step === 1) {\n        return getSuggestionsForFragmentSpread(token, typeInfo, schema, queryText, Array.isArray(fragmentDefs)\n            ? fragmentDefs\n            : collectFragmentDefs(fragmentDefs));\n    }\n    if ((kind === RuleKinds.VARIABLE_DEFINITION && step === 2) ||\n        (kind === RuleKinds.LIST_TYPE && step === 1) ||\n        (kind === RuleKinds.NAMED_TYPE &&\n            state.prevState &&\n            (state.prevState.kind === RuleKinds.VARIABLE_DEFINITION ||\n                state.prevState.kind === RuleKinds.LIST_TYPE ||\n                state.prevState.kind === RuleKinds.NON_NULL_TYPE))) {\n        return getSuggestionsForVariableDefinition(token, schema, kind);\n    }\n    if (kind === RuleKinds.DIRECTIVE) {\n        return getSuggestionsForDirective(token, state, schema, kind);\n    }\n    return [];\n}\nfunction getSuggestionsForFieldNames(token, typeInfo, schema) {\n    if (typeInfo.parentType) {\n        const parentType = typeInfo.parentType;\n        let fields = [];\n        if ('getFields' in parentType) {\n            fields = objectValues(parentType.getFields());\n        }\n        if (isCompositeType(parentType)) {\n            fields.push(TypeNameMetaFieldDef);\n        }\n        if (parentType === schema.getQueryType()) {\n            fields.push(SchemaMetaFieldDef, TypeMetaFieldDef);\n        }\n        return hintList(token, fields.map((field, index) => {\n            var _a;\n            return ({\n                sortText: String(index) + field.name,\n                label: field.name,\n                detail: String(field.type),\n                documentation: (_a = field.description) !== null && _a !== void 0 ? _a : undefined,\n                deprecated: field.isDeprecated,\n                isDeprecated: field.isDeprecated,\n                deprecationReason: field.deprecationReason,\n                kind: CompletionItemKind.Field,\n                type: field.type,\n            });\n        }));\n    }\n    return [];\n}\nfunction getSuggestionsForInputValues(token, typeInfo, queryText, schema) {\n    const namedInputType = getNamedType(typeInfo.inputType);\n    const queryVariables = getVariableCompletions(queryText, schema, true).filter(v => v.detail === namedInputType.name);\n    if (namedInputType instanceof GraphQLEnumType) {\n        const values = namedInputType.getValues();\n        return hintList(token, values\n            .map((value) => {\n            var _a;\n            return ({\n                label: value.name,\n                detail: String(namedInputType),\n                documentation: (_a = value.description) !== null && _a !== void 0 ? _a : undefined,\n                deprecated: value.isDeprecated,\n                isDeprecated: value.isDeprecated,\n                deprecationReason: value.deprecationReason,\n                kind: CompletionItemKind.EnumMember,\n                type: namedInputType,\n            });\n        })\n            .concat(queryVariables));\n    }\n    else if (namedInputType === GraphQLBoolean) {\n        return hintList(token, queryVariables.concat([\n            {\n                label: 'true',\n                detail: String(GraphQLBoolean),\n                documentation: 'Not false.',\n                kind: CompletionItemKind.Variable,\n                type: GraphQLBoolean,\n            },\n            {\n                label: 'false',\n                detail: String(GraphQLBoolean),\n                documentation: 'Not true.',\n                kind: CompletionItemKind.Variable,\n                type: GraphQLBoolean,\n            },\n        ]));\n    }\n    return queryVariables;\n}\nfunction getSuggestionsForImplements(token, tokenState, schema, documentText, typeInfo) {\n    if (tokenState.needsSeperator) {\n        return [];\n    }\n    const typeMap = schema.getTypeMap();\n    const schemaInterfaces = objectValues(typeMap).filter(isInterfaceType);\n    const schemaInterfaceNames = schemaInterfaces.map(({ name }) => name);\n    const inlineInterfaces = new Set();\n    runOnlineParser(documentText, (_, state) => {\n        var _a, _b, _c, _d, _e;\n        if (state.name) {\n            if (state.kind === RuleKinds.INTERFACE_DEF &&\n                !schemaInterfaceNames.includes(state.name)) {\n                inlineInterfaces.add(state.name);\n            }\n            if (state.kind === RuleKinds.NAMED_TYPE &&\n                ((_a = state.prevState) === null || _a === void 0 ? void 0 : _a.kind) === RuleKinds.IMPLEMENTS) {\n                if (typeInfo.interfaceDef) {\n                    const existingType = (_b = typeInfo.interfaceDef) === null || _b === void 0 ? void 0 : _b.getInterfaces().find(({ name }) => name === state.name);\n                    if (existingType) {\n                        return;\n                    }\n                    const type = schema.getType(state.name);\n                    const interfaceConfig = (_c = typeInfo.interfaceDef) === null || _c === void 0 ? void 0 : _c.toConfig();\n                    typeInfo.interfaceDef = new GraphQLInterfaceType(Object.assign(Object.assign({}, interfaceConfig), { interfaces: [\n                            ...interfaceConfig.interfaces,\n                            type ||\n                                new GraphQLInterfaceType({ name: state.name, fields: {} }),\n                        ] }));\n                }\n                else if (typeInfo.objectTypeDef) {\n                    const existingType = (_d = typeInfo.objectTypeDef) === null || _d === void 0 ? void 0 : _d.getInterfaces().find(({ name }) => name === state.name);\n                    if (existingType) {\n                        return;\n                    }\n                    const type = schema.getType(state.name);\n                    const objectTypeConfig = (_e = typeInfo.objectTypeDef) === null || _e === void 0 ? void 0 : _e.toConfig();\n                    typeInfo.objectTypeDef = new GraphQLObjectType(Object.assign(Object.assign({}, objectTypeConfig), { interfaces: [\n                            ...objectTypeConfig.interfaces,\n                            type ||\n                                new GraphQLInterfaceType({ name: state.name, fields: {} }),\n                        ] }));\n                }\n            }\n        }\n    });\n    const currentTypeToExtend = typeInfo.interfaceDef || typeInfo.objectTypeDef;\n    const siblingInterfaces = (currentTypeToExtend === null || currentTypeToExtend === void 0 ? void 0 : currentTypeToExtend.getInterfaces()) || [];\n    const siblingInterfaceNames = siblingInterfaces.map(({ name }) => name);\n    const possibleInterfaces = schemaInterfaces\n        .concat([...inlineInterfaces].map(name => ({ name })))\n        .filter(({ name }) => name !== (currentTypeToExtend === null || currentTypeToExtend === void 0 ? void 0 : currentTypeToExtend.name) &&\n        !siblingInterfaceNames.includes(name));\n    return hintList(token, possibleInterfaces.map(type => {\n        const result = {\n            label: type.name,\n            kind: CompletionItemKind.Interface,\n            type,\n        };\n        if (type === null || type === void 0 ? void 0 : type.description) {\n            result.documentation = type.description;\n        }\n        return result;\n    }));\n}\nfunction getSuggestionsForFragmentTypeConditions(token, typeInfo, schema, _kind) {\n    let possibleTypes;\n    if (typeInfo.parentType) {\n        if (isAbstractType(typeInfo.parentType)) {\n            const abstractType = assertAbstractType(typeInfo.parentType);\n            const possibleObjTypes = schema.getPossibleTypes(abstractType);\n            const possibleIfaceMap = Object.create(null);\n            possibleObjTypes.forEach(type => {\n                type.getInterfaces().forEach(iface => {\n                    possibleIfaceMap[iface.name] = iface;\n                });\n            });\n            possibleTypes = possibleObjTypes.concat(objectValues(possibleIfaceMap));\n        }\n        else {\n            possibleTypes = [typeInfo.parentType];\n        }\n    }\n    else {\n        const typeMap = schema.getTypeMap();\n        possibleTypes = objectValues(typeMap).filter(isCompositeType);\n    }\n    return hintList(token, possibleTypes.map(type => {\n        const namedType = getNamedType(type);\n        return {\n            label: String(type),\n            documentation: (namedType && namedType.description) || '',\n            kind: CompletionItemKind.Field,\n        };\n    }));\n}\nfunction getSuggestionsForFragmentSpread(token, typeInfo, schema, queryText, fragmentDefs) {\n    if (!queryText) {\n        return [];\n    }\n    const typeMap = schema.getTypeMap();\n    const defState = getDefinitionState(token.state);\n    const fragments = getFragmentDefinitions(queryText);\n    if (fragmentDefs && fragmentDefs.length > 0) {\n        fragments.push(...fragmentDefs);\n    }\n    const relevantFrags = fragments.filter(frag => typeMap[frag.typeCondition.name.value] &&\n        !(defState &&\n            defState.kind === RuleKinds.FRAGMENT_DEFINITION &&\n            defState.name === frag.name.value) &&\n        isCompositeType(typeInfo.parentType) &&\n        isCompositeType(typeMap[frag.typeCondition.name.value]) &&\n        doTypesOverlap(schema, typeInfo.parentType, typeMap[frag.typeCondition.name.value]));\n    return hintList(token, relevantFrags.map(frag => ({\n        label: frag.name.value,\n        detail: String(typeMap[frag.typeCondition.name.value]),\n        documentation: `fragment ${frag.name.value} on ${frag.typeCondition.name.value}`,\n        kind: CompletionItemKind.Field,\n        type: typeMap[frag.typeCondition.name.value],\n    })));\n}\nconst getParentDefinition = (state, kind) => {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;\n    if (((_a = state.prevState) === null || _a === void 0 ? void 0 : _a.kind) === kind) {\n        return state.prevState;\n    }\n    if (((_c = (_b = state.prevState) === null || _b === void 0 ? void 0 : _b.prevState) === null || _c === void 0 ? void 0 : _c.kind) === kind) {\n        return state.prevState.prevState;\n    }\n    if (((_f = (_e = (_d = state.prevState) === null || _d === void 0 ? void 0 : _d.prevState) === null || _e === void 0 ? void 0 : _e.prevState) === null || _f === void 0 ? void 0 : _f.kind) === kind) {\n        return state.prevState.prevState.prevState;\n    }\n    if (((_k = (_j = (_h = (_g = state.prevState) === null || _g === void 0 ? void 0 : _g.prevState) === null || _h === void 0 ? void 0 : _h.prevState) === null || _j === void 0 ? void 0 : _j.prevState) === null || _k === void 0 ? void 0 : _k.kind) === kind) {\n        return state.prevState.prevState.prevState.prevState;\n    }\n};\nexport function getVariableCompletions(queryText, schema, forcePrefix = false) {\n    let variableName;\n    let variableType;\n    const definitions = Object.create({});\n    runOnlineParser(queryText, (_, state) => {\n        if (state.kind === RuleKinds.VARIABLE && state.name) {\n            variableName = state.name;\n        }\n        if (state.kind === RuleKinds.NAMED_TYPE && variableName) {\n            const parentDefinition = getParentDefinition(state, RuleKinds.TYPE);\n            if (parentDefinition === null || parentDefinition === void 0 ? void 0 : parentDefinition.type) {\n                variableType = schema.getType(parentDefinition === null || parentDefinition === void 0 ? void 0 : parentDefinition.type);\n            }\n        }\n        if (variableName && variableType) {\n            if (!definitions[variableName]) {\n                definitions[variableName] = {\n                    detail: variableType.toString(),\n                    label: `$${variableName}`,\n                    type: variableType,\n                    kind: CompletionItemKind.Variable,\n                };\n                if (forcePrefix) {\n                    definitions[variableName].insertText = `$${variableName}`;\n                }\n                variableName = null;\n                variableType = null;\n            }\n        }\n    });\n    return objectValues(definitions);\n}\nexport function getFragmentDefinitions(queryText) {\n    const fragmentDefs = [];\n    runOnlineParser(queryText, (_, state) => {\n        if (state.kind === RuleKinds.FRAGMENT_DEFINITION &&\n            state.name &&\n            state.type) {\n            fragmentDefs.push({\n                kind: RuleKinds.FRAGMENT_DEFINITION,\n                name: {\n                    kind: 'Name',\n                    value: state.name,\n                },\n                selectionSet: {\n                    kind: RuleKinds.SELECTION_SET,\n                    selections: [],\n                },\n                typeCondition: {\n                    kind: RuleKinds.NAMED_TYPE,\n                    name: {\n                        kind: 'Name',\n                        value: state.type,\n                    },\n                },\n            });\n        }\n    });\n    return fragmentDefs;\n}\nfunction getSuggestionsForVariableDefinition(token, schema, _kind) {\n    const inputTypeMap = schema.getTypeMap();\n    const inputTypes = objectValues(inputTypeMap).filter(isInputType);\n    return hintList(token, inputTypes.map((type) => ({\n        label: type.name,\n        documentation: type.description,\n        kind: CompletionItemKind.Variable,\n    })));\n}\nfunction getSuggestionsForDirective(token, state, schema, _kind) {\n    if (state.prevState && state.prevState.kind) {\n        const directives = schema\n            .getDirectives()\n            .filter(directive => canUseDirective(state.prevState, directive));\n        return hintList(token, directives.map(directive => ({\n            label: directive.name,\n            documentation: directive.description || '',\n            kind: CompletionItemKind.Function,\n        })));\n    }\n    return [];\n}\nexport function getTokenAtPosition(queryText, cursor) {\n    let styleAtCursor = null;\n    let stateAtCursor = null;\n    let stringAtCursor = null;\n    const token = runOnlineParser(queryText, (stream, state, style, index) => {\n        if (index === cursor.line) {\n            if (stream.getCurrentPosition() >= cursor.character) {\n                styleAtCursor = style;\n                stateAtCursor = Object.assign({}, state);\n                stringAtCursor = stream.current();\n                return 'BREAK';\n            }\n        }\n    });\n    return {\n        start: token.start,\n        end: token.end,\n        string: stringAtCursor || token.string,\n        state: stateAtCursor || token.state,\n        style: styleAtCursor || token.style,\n    };\n}\nexport function runOnlineParser(queryText, callback) {\n    const lines = queryText.split('\\n');\n    const parser = onlineParser();\n    let state = parser.startState();\n    let style = '';\n    let stream = new CharacterStream('');\n    for (let i = 0; i < lines.length; i++) {\n        stream = new CharacterStream(lines[i]);\n        while (!stream.eol()) {\n            style = parser.token(stream, state);\n            const code = callback(stream, state, style, i);\n            if (code === 'BREAK') {\n                break;\n            }\n        }\n        callback(stream, state, style, i);\n        if (!state.kind) {\n            state = parser.startState();\n        }\n    }\n    return {\n        start: stream.getStartOfToken(),\n        end: stream.getCurrentPosition(),\n        string: stream.current(),\n        state,\n        style,\n    };\n}\nexport function canUseDirective(state, directive) {\n    if (!state || !state.kind) {\n        return false;\n    }\n    const kind = state.kind;\n    const locations = directive.locations;\n    switch (kind) {\n        case RuleKinds.QUERY:\n            return locations.indexOf('QUERY') !== -1;\n        case RuleKinds.MUTATION:\n            return locations.indexOf('MUTATION') !== -1;\n        case RuleKinds.SUBSCRIPTION:\n            return locations.indexOf('SUBSCRIPTION') !== -1;\n        case RuleKinds.FIELD:\n        case RuleKinds.ALIASED_FIELD:\n            return locations.indexOf('FIELD') !== -1;\n        case RuleKinds.FRAGMENT_DEFINITION:\n            return locations.indexOf('FRAGMENT_DEFINITION') !== -1;\n        case RuleKinds.FRAGMENT_SPREAD:\n            return locations.indexOf('FRAGMENT_SPREAD') !== -1;\n        case RuleKinds.INLINE_FRAGMENT:\n            return locations.indexOf('INLINE_FRAGMENT') !== -1;\n        case RuleKinds.SCHEMA_DEF:\n            return locations.indexOf('SCHEMA') !== -1;\n        case RuleKinds.SCALAR_DEF:\n            return locations.indexOf('SCALAR') !== -1;\n        case RuleKinds.OBJECT_TYPE_DEF:\n            return locations.indexOf('OBJECT') !== -1;\n        case RuleKinds.FIELD_DEF:\n            return locations.indexOf('FIELD_DEFINITION') !== -1;\n        case RuleKinds.INTERFACE_DEF:\n            return locations.indexOf('INTERFACE') !== -1;\n        case RuleKinds.UNION_DEF:\n            return locations.indexOf('UNION') !== -1;\n        case RuleKinds.ENUM_DEF:\n            return locations.indexOf('ENUM') !== -1;\n        case RuleKinds.ENUM_VALUE:\n            return locations.indexOf('ENUM_VALUE') !== -1;\n        case RuleKinds.INPUT_DEF:\n            return locations.indexOf('INPUT_OBJECT') !== -1;\n        case RuleKinds.INPUT_VALUE_DEF:\n            const prevStateKind = state.prevState && state.prevState.kind;\n            switch (prevStateKind) {\n                case RuleKinds.ARGUMENTS_DEF:\n                    return locations.indexOf('ARGUMENT_DEFINITION') !== -1;\n                case RuleKinds.INPUT_DEF:\n                    return locations.indexOf('INPUT_FIELD_DEFINITION') !== -1;\n            }\n    }\n    return false;\n}\nexport function getTypeInfo(schema, tokenState) {\n    let argDef;\n    let argDefs;\n    let directiveDef;\n    let enumValue;\n    let fieldDef;\n    let inputType;\n    let objectTypeDef;\n    let objectFieldDefs;\n    let parentType;\n    let type;\n    let interfaceDef;\n    forEachState(tokenState, state => {\n        switch (state.kind) {\n            case RuleKinds.QUERY:\n            case 'ShortQuery':\n                type = schema.getQueryType();\n                break;\n            case RuleKinds.MUTATION:\n                type = schema.getMutationType();\n                break;\n            case RuleKinds.SUBSCRIPTION:\n                type = schema.getSubscriptionType();\n                break;\n            case RuleKinds.INLINE_FRAGMENT:\n            case RuleKinds.FRAGMENT_DEFINITION:\n                if (state.type) {\n                    type = schema.getType(state.type);\n                }\n                break;\n            case RuleKinds.FIELD:\n            case RuleKinds.ALIASED_FIELD: {\n                if (!type || !state.name) {\n                    fieldDef = null;\n                }\n                else {\n                    fieldDef = parentType\n                        ? getFieldDef(schema, parentType, state.name)\n                        : null;\n                    type = fieldDef ? fieldDef.type : null;\n                }\n                break;\n            }\n            case RuleKinds.SELECTION_SET:\n                parentType = getNamedType(type);\n                break;\n            case RuleKinds.DIRECTIVE:\n                directiveDef = state.name ? schema.getDirective(state.name) : null;\n                break;\n            case RuleKinds.INTERFACE_DEF:\n                if (state.name) {\n                    objectTypeDef = null;\n                    interfaceDef = new GraphQLInterfaceType({\n                        name: state.name,\n                        interfaces: [],\n                        fields: {},\n                    });\n                }\n                break;\n            case RuleKinds.OBJECT_TYPE_DEF:\n                if (state.name) {\n                    interfaceDef = null;\n                    objectTypeDef = new GraphQLObjectType({\n                        name: state.name,\n                        interfaces: [],\n                        fields: {},\n                    });\n                }\n                break;\n            case RuleKinds.ARGUMENTS: {\n                if (!state.prevState) {\n                    argDefs = null;\n                }\n                else {\n                    switch (state.prevState.kind) {\n                        case RuleKinds.FIELD:\n                            argDefs = fieldDef && fieldDef.args;\n                            break;\n                        case RuleKinds.DIRECTIVE:\n                            argDefs = directiveDef && directiveDef.args;\n                            break;\n                        case RuleKinds.ALIASED_FIELD: {\n                            const name = state.prevState && state.prevState.name;\n                            if (!name) {\n                                argDefs = null;\n                                break;\n                            }\n                            const field = parentType\n                                ? getFieldDef(schema, parentType, name)\n                                : null;\n                            if (!field) {\n                                argDefs = null;\n                                break;\n                            }\n                            argDefs = field.args;\n                            break;\n                        }\n                        default:\n                            argDefs = null;\n                            break;\n                    }\n                }\n                break;\n            }\n            case RuleKinds.ARGUMENT:\n                if (argDefs) {\n                    for (let i = 0; i < argDefs.length; i++) {\n                        if (argDefs[i].name === state.name) {\n                            argDef = argDefs[i];\n                            break;\n                        }\n                    }\n                }\n                inputType = argDef && argDef.type;\n                break;\n            case RuleKinds.ENUM_VALUE:\n                const enumType = getNamedType(inputType);\n                enumValue =\n                    enumType instanceof GraphQLEnumType\n                        ? find(enumType.getValues(), (val) => val.value === state.name)\n                        : null;\n                break;\n            case RuleKinds.LIST_VALUE:\n                const nullableType = getNullableType(inputType);\n                inputType =\n                    nullableType instanceof GraphQLList ? nullableType.ofType : null;\n                break;\n            case RuleKinds.OBJECT_VALUE:\n                const objectType = getNamedType(inputType);\n                objectFieldDefs =\n                    objectType instanceof GraphQLInputObjectType\n                        ? objectType.getFields()\n                        : null;\n                break;\n            case RuleKinds.OBJECT_FIELD:\n                const objectField = state.name && objectFieldDefs ? objectFieldDefs[state.name] : null;\n                inputType = objectField && objectField.type;\n                break;\n            case RuleKinds.NAMED_TYPE:\n                if (state.name) {\n                    type = schema.getType(state.name);\n                }\n                break;\n        }\n    });\n    return {\n        argDef,\n        argDefs,\n        directiveDef,\n        enumValue,\n        fieldDef,\n        inputType,\n        objectFieldDefs,\n        parentType,\n        type,\n        interfaceDef,\n        objectTypeDef,\n    };\n}\nfunction find(array, predicate) {\n    for (let i = 0; i < array.length; i++) {\n        if (predicate(array[i])) {\n            return array[i];\n        }\n    }\n    return null;\n}\n//# sourceMappingURL=getAutocompleteSuggestions.js.map"]},"metadata":{},"sourceType":"module"}