{"ast":null,"code":"//      Copyright (c) 2012 Mathieu Turcotte\n//      Licensed under the MIT license.\nvar events = require('events');\n\nvar precond = require('precond');\n\nvar util = require('util'); // A class to hold the state of a backoff operation. Accepts a backoff strategy\n// to generate the backoff delays.\n\n\nfunction Backoff(backoffStrategy) {\n  events.EventEmitter.call(this);\n  this.backoffStrategy_ = backoffStrategy;\n  this.maxNumberOfRetry_ = -1;\n  this.backoffNumber_ = 0;\n  this.backoffDelay_ = 0;\n  this.timeoutID_ = -1;\n  this.handlers = {\n    backoff: this.onBackoff_.bind(this)\n  };\n}\n\nutil.inherits(Backoff, events.EventEmitter); // Sets a limit, greater than 0, on the maximum number of backoffs. A 'fail'\n// event will be emitted when the limit is reached.\n\nBackoff.prototype.failAfter = function (maxNumberOfRetry) {\n  precond.checkArgument(maxNumberOfRetry > 0, 'Expected a maximum number of retry greater than 0 but got %s.', maxNumberOfRetry);\n  this.maxNumberOfRetry_ = maxNumberOfRetry;\n}; // Starts a backoff operation. Accepts an optional parameter to let the\n// listeners know why the backoff operation was started.\n\n\nBackoff.prototype.backoff = function (err) {\n  precond.checkState(this.timeoutID_ === -1, 'Backoff in progress.');\n\n  if (this.backoffNumber_ === this.maxNumberOfRetry_) {\n    this.emit('fail', err);\n    this.reset();\n  } else {\n    this.backoffDelay_ = this.backoffStrategy_.next();\n    this.timeoutID_ = setTimeout(this.handlers.backoff, this.backoffDelay_);\n    this.emit('backoff', this.backoffNumber_, this.backoffDelay_, err);\n  }\n}; // Handles the backoff timeout completion.\n\n\nBackoff.prototype.onBackoff_ = function () {\n  this.timeoutID_ = -1;\n  this.emit('ready', this.backoffNumber_, this.backoffDelay_);\n  this.backoffNumber_++;\n}; // Stops any backoff operation and resets the backoff delay to its inital value.\n\n\nBackoff.prototype.reset = function () {\n  this.backoffNumber_ = 0;\n  this.backoffStrategy_.reset();\n  clearTimeout(this.timeoutID_);\n  this.timeoutID_ = -1;\n};\n\nmodule.exports = Backoff;","map":{"version":3,"sources":["/Users/chrisbuonocore/personal/hackathons/hackfs21/node_modules/backoff/lib/backoff.js"],"names":["events","require","precond","util","Backoff","backoffStrategy","EventEmitter","call","backoffStrategy_","maxNumberOfRetry_","backoffNumber_","backoffDelay_","timeoutID_","handlers","backoff","onBackoff_","bind","inherits","prototype","failAfter","maxNumberOfRetry","checkArgument","err","checkState","emit","reset","next","setTimeout","clearTimeout","module","exports"],"mappings":"AAAA;AACA;AAEA,IAAIA,MAAM,GAAGC,OAAO,CAAC,QAAD,CAApB;;AACA,IAAIC,OAAO,GAAGD,OAAO,CAAC,SAAD,CAArB;;AACA,IAAIE,IAAI,GAAGF,OAAO,CAAC,MAAD,CAAlB,C,CAEA;AACA;;;AACA,SAASG,OAAT,CAAiBC,eAAjB,EAAkC;AAC9BL,EAAAA,MAAM,CAACM,YAAP,CAAoBC,IAApB,CAAyB,IAAzB;AAEA,OAAKC,gBAAL,GAAwBH,eAAxB;AACA,OAAKI,iBAAL,GAAyB,CAAC,CAA1B;AACA,OAAKC,cAAL,GAAsB,CAAtB;AACA,OAAKC,aAAL,GAAqB,CAArB;AACA,OAAKC,UAAL,GAAkB,CAAC,CAAnB;AAEA,OAAKC,QAAL,GAAgB;AACZC,IAAAA,OAAO,EAAE,KAAKC,UAAL,CAAgBC,IAAhB,CAAqB,IAArB;AADG,GAAhB;AAGH;;AACDb,IAAI,CAACc,QAAL,CAAcb,OAAd,EAAuBJ,MAAM,CAACM,YAA9B,E,CAEA;AACA;;AACAF,OAAO,CAACc,SAAR,CAAkBC,SAAlB,GAA8B,UAASC,gBAAT,EAA2B;AACrDlB,EAAAA,OAAO,CAACmB,aAAR,CAAsBD,gBAAgB,GAAG,CAAzC,EACI,+DADJ,EAEIA,gBAFJ;AAIA,OAAKX,iBAAL,GAAyBW,gBAAzB;AACH,CAND,C,CAQA;AACA;;;AACAhB,OAAO,CAACc,SAAR,CAAkBJ,OAAlB,GAA4B,UAASQ,GAAT,EAAc;AACtCpB,EAAAA,OAAO,CAACqB,UAAR,CAAmB,KAAKX,UAAL,KAAoB,CAAC,CAAxC,EAA2C,sBAA3C;;AAEA,MAAI,KAAKF,cAAL,KAAwB,KAAKD,iBAAjC,EAAoD;AAChD,SAAKe,IAAL,CAAU,MAAV,EAAkBF,GAAlB;AACA,SAAKG,KAAL;AACH,GAHD,MAGO;AACH,SAAKd,aAAL,GAAqB,KAAKH,gBAAL,CAAsBkB,IAAtB,EAArB;AACA,SAAKd,UAAL,GAAkBe,UAAU,CAAC,KAAKd,QAAL,CAAcC,OAAf,EAAwB,KAAKH,aAA7B,CAA5B;AACA,SAAKa,IAAL,CAAU,SAAV,EAAqB,KAAKd,cAA1B,EAA0C,KAAKC,aAA/C,EAA8DW,GAA9D;AACH;AACJ,CAXD,C,CAaA;;;AACAlB,OAAO,CAACc,SAAR,CAAkBH,UAAlB,GAA+B,YAAW;AACtC,OAAKH,UAAL,GAAkB,CAAC,CAAnB;AACA,OAAKY,IAAL,CAAU,OAAV,EAAmB,KAAKd,cAAxB,EAAwC,KAAKC,aAA7C;AACA,OAAKD,cAAL;AACH,CAJD,C,CAMA;;;AACAN,OAAO,CAACc,SAAR,CAAkBO,KAAlB,GAA0B,YAAW;AACjC,OAAKf,cAAL,GAAsB,CAAtB;AACA,OAAKF,gBAAL,CAAsBiB,KAAtB;AACAG,EAAAA,YAAY,CAAC,KAAKhB,UAAN,CAAZ;AACA,OAAKA,UAAL,GAAkB,CAAC,CAAnB;AACH,CALD;;AAOAiB,MAAM,CAACC,OAAP,GAAiB1B,OAAjB","sourcesContent":["//      Copyright (c) 2012 Mathieu Turcotte\n//      Licensed under the MIT license.\n\nvar events = require('events');\nvar precond = require('precond');\nvar util = require('util');\n\n// A class to hold the state of a backoff operation. Accepts a backoff strategy\n// to generate the backoff delays.\nfunction Backoff(backoffStrategy) {\n    events.EventEmitter.call(this);\n\n    this.backoffStrategy_ = backoffStrategy;\n    this.maxNumberOfRetry_ = -1;\n    this.backoffNumber_ = 0;\n    this.backoffDelay_ = 0;\n    this.timeoutID_ = -1;\n\n    this.handlers = {\n        backoff: this.onBackoff_.bind(this)\n    };\n}\nutil.inherits(Backoff, events.EventEmitter);\n\n// Sets a limit, greater than 0, on the maximum number of backoffs. A 'fail'\n// event will be emitted when the limit is reached.\nBackoff.prototype.failAfter = function(maxNumberOfRetry) {\n    precond.checkArgument(maxNumberOfRetry > 0,\n        'Expected a maximum number of retry greater than 0 but got %s.',\n        maxNumberOfRetry);\n\n    this.maxNumberOfRetry_ = maxNumberOfRetry;\n};\n\n// Starts a backoff operation. Accepts an optional parameter to let the\n// listeners know why the backoff operation was started.\nBackoff.prototype.backoff = function(err) {\n    precond.checkState(this.timeoutID_ === -1, 'Backoff in progress.');\n\n    if (this.backoffNumber_ === this.maxNumberOfRetry_) {\n        this.emit('fail', err);\n        this.reset();\n    } else {\n        this.backoffDelay_ = this.backoffStrategy_.next();\n        this.timeoutID_ = setTimeout(this.handlers.backoff, this.backoffDelay_);\n        this.emit('backoff', this.backoffNumber_, this.backoffDelay_, err);\n    }\n};\n\n// Handles the backoff timeout completion.\nBackoff.prototype.onBackoff_ = function() {\n    this.timeoutID_ = -1;\n    this.emit('ready', this.backoffNumber_, this.backoffDelay_);\n    this.backoffNumber_++;\n};\n\n// Stops any backoff operation and resets the backoff delay to its inital value.\nBackoff.prototype.reset = function() {\n    this.backoffNumber_ = 0;\n    this.backoffStrategy_.reset();\n    clearTimeout(this.timeoutID_);\n    this.timeoutID_ = -1;\n};\n\nmodule.exports = Backoff;\n"]},"metadata":{},"sourceType":"script"}