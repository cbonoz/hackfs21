{"ast":null,"code":"import { BlockCipherMode } from './cipher-core.js';\n\nfunction generateKeystreamAndEncrypt(words, offset, blockSize, cipher) {\n  const _words = words;\n  let keystream; // Shortcut\n\n  const iv = this._iv; // Generate keystream\n\n  if (iv) {\n    keystream = iv.slice(0); // Remove IV for subsequent blocks\n\n    this._iv = undefined;\n  } else {\n    keystream = this._prevBlock;\n  }\n\n  cipher.encryptBlock(keystream, 0); // Encrypt\n\n  for (let i = 0; i < blockSize; i += 1) {\n    _words[offset + i] ^= keystream[i];\n  }\n}\n/**\n * Cipher Feedback block mode.\n */\n\n\nexport class CFB extends BlockCipherMode {}\nCFB.Encryptor = class extends CFB {\n  processBlock(words, offset) {\n    // Shortcuts\n    const cipher = this._cipher;\n    const {\n      blockSize\n    } = cipher;\n    generateKeystreamAndEncrypt.call(this, words, offset, blockSize, cipher); // Remember this block to use with next block\n\n    this._prevBlock = words.slice(offset, offset + blockSize);\n  }\n\n};\nCFB.Decryptor = class extends CFB {\n  processBlock(words, offset) {\n    // Shortcuts\n    const cipher = this._cipher;\n    const {\n      blockSize\n    } = cipher; // Remember this block to use with next block\n\n    const thisBlock = words.slice(offset, offset + blockSize);\n    generateKeystreamAndEncrypt.call(this, words, offset, blockSize, cipher); // This block becomes the previous block\n\n    this._prevBlock = thisBlock;\n  }\n\n};","map":{"version":3,"sources":["/Users/chrisbuonocore/personal/hackathons/hackfs21/node_modules/crypto-es/lib/mode-cfb.js"],"names":["BlockCipherMode","generateKeystreamAndEncrypt","words","offset","blockSize","cipher","_words","keystream","iv","_iv","slice","undefined","_prevBlock","encryptBlock","i","CFB","Encryptor","processBlock","_cipher","call","Decryptor","thisBlock"],"mappings":"AAAA,SACEA,eADF,QAEO,kBAFP;;AAIA,SAASC,2BAAT,CAAqCC,KAArC,EAA4CC,MAA5C,EAAoDC,SAApD,EAA+DC,MAA/D,EAAuE;AACrE,QAAMC,MAAM,GAAGJ,KAAf;AACA,MAAIK,SAAJ,CAFqE,CAIrE;;AACA,QAAMC,EAAE,GAAG,KAAKC,GAAhB,CALqE,CAOrE;;AACA,MAAID,EAAJ,EAAQ;AACND,IAAAA,SAAS,GAAGC,EAAE,CAACE,KAAH,CAAS,CAAT,CAAZ,CADM,CAGN;;AACA,SAAKD,GAAL,GAAWE,SAAX;AACD,GALD,MAKO;AACLJ,IAAAA,SAAS,GAAG,KAAKK,UAAjB;AACD;;AACDP,EAAAA,MAAM,CAACQ,YAAP,CAAoBN,SAApB,EAA+B,CAA/B,EAhBqE,CAkBrE;;AACA,OAAK,IAAIO,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGV,SAApB,EAA+BU,CAAC,IAAI,CAApC,EAAuC;AACrCR,IAAAA,MAAM,CAACH,MAAM,GAAGW,CAAV,CAAN,IAAsBP,SAAS,CAACO,CAAD,CAA/B;AACD;AACF;AAED;AACA;AACA;;;AACA,OAAO,MAAMC,GAAN,SAAkBf,eAAlB,CAAkC;AAEzCe,GAAG,CAACC,SAAJ,GAAgB,cAAcD,GAAd,CAAkB;AAChCE,EAAAA,YAAY,CAACf,KAAD,EAAQC,MAAR,EAAgB;AAC1B;AACA,UAAME,MAAM,GAAG,KAAKa,OAApB;AACA,UAAM;AAAEd,MAAAA;AAAF,QAAgBC,MAAtB;AAEAJ,IAAAA,2BAA2B,CAACkB,IAA5B,CAAiC,IAAjC,EAAuCjB,KAAvC,EAA8CC,MAA9C,EAAsDC,SAAtD,EAAiEC,MAAjE,EAL0B,CAO1B;;AACA,SAAKO,UAAL,GAAkBV,KAAK,CAACQ,KAAN,CAAYP,MAAZ,EAAoBA,MAAM,GAAGC,SAA7B,CAAlB;AACD;;AAV+B,CAAlC;AAYAW,GAAG,CAACK,SAAJ,GAAgB,cAAcL,GAAd,CAAkB;AAChCE,EAAAA,YAAY,CAACf,KAAD,EAAQC,MAAR,EAAgB;AAC1B;AACA,UAAME,MAAM,GAAG,KAAKa,OAApB;AACA,UAAM;AAAEd,MAAAA;AAAF,QAAgBC,MAAtB,CAH0B,CAK1B;;AACA,UAAMgB,SAAS,GAAGnB,KAAK,CAACQ,KAAN,CAAYP,MAAZ,EAAoBA,MAAM,GAAGC,SAA7B,CAAlB;AAEAH,IAAAA,2BAA2B,CAACkB,IAA5B,CAAiC,IAAjC,EAAuCjB,KAAvC,EAA8CC,MAA9C,EAAsDC,SAAtD,EAAiEC,MAAjE,EAR0B,CAU1B;;AACA,SAAKO,UAAL,GAAkBS,SAAlB;AACD;;AAb+B,CAAlC","sourcesContent":["import {\n  BlockCipherMode,\n} from './cipher-core.js';\n\nfunction generateKeystreamAndEncrypt(words, offset, blockSize, cipher) {\n  const _words = words;\n  let keystream;\n\n  // Shortcut\n  const iv = this._iv;\n\n  // Generate keystream\n  if (iv) {\n    keystream = iv.slice(0);\n\n    // Remove IV for subsequent blocks\n    this._iv = undefined;\n  } else {\n    keystream = this._prevBlock;\n  }\n  cipher.encryptBlock(keystream, 0);\n\n  // Encrypt\n  for (let i = 0; i < blockSize; i += 1) {\n    _words[offset + i] ^= keystream[i];\n  }\n}\n\n/**\n * Cipher Feedback block mode.\n */\nexport class CFB extends BlockCipherMode {\n}\nCFB.Encryptor = class extends CFB {\n  processBlock(words, offset) {\n    // Shortcuts\n    const cipher = this._cipher;\n    const { blockSize } = cipher;\n\n    generateKeystreamAndEncrypt.call(this, words, offset, blockSize, cipher);\n\n    // Remember this block to use with next block\n    this._prevBlock = words.slice(offset, offset + blockSize);\n  }\n};\nCFB.Decryptor = class extends CFB {\n  processBlock(words, offset) {\n    // Shortcuts\n    const cipher = this._cipher;\n    const { blockSize } = cipher;\n\n    // Remember this block to use with next block\n    const thisBlock = words.slice(offset, offset + blockSize);\n\n    generateKeystreamAndEncrypt.call(this, words, offset, blockSize, cipher);\n\n    // This block becomes the previous block\n    this._prevBlock = thisBlock;\n  }\n};\n"]},"metadata":{},"sourceType":"module"}