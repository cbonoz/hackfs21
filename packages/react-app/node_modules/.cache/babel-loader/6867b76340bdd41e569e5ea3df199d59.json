{"ast":null,"code":"import { Kind, parse, visit } from 'graphql';\nimport { offsetToPosition } from 'graphql-language-service-utils';\nconst {\n  INLINE_FRAGMENT\n} = Kind;\nconst OUTLINEABLE_KINDS = {\n  Field: true,\n  OperationDefinition: true,\n  Document: true,\n  SelectionSet: true,\n  Name: true,\n  FragmentDefinition: true,\n  FragmentSpread: true,\n  InlineFragment: true,\n  ObjectTypeDefinition: true,\n  InputObjectTypeDefinition: true,\n  InterfaceTypeDefinition: true,\n  EnumTypeDefinition: true,\n  EnumValueDefinition: true,\n  InputValueDefinition: true,\n  FieldDefinition: true\n};\nexport function getOutline(documentText) {\n  let ast;\n\n  try {\n    ast = parse(documentText);\n  } catch (error) {\n    return null;\n  }\n\n  const visitorFns = outlineTreeConverter(documentText);\n  const outlineTrees = visit(ast, {\n    leave(node) {\n      if (visitorFns !== undefined && node.kind in visitorFns) {\n        return visitorFns[node.kind](node);\n      }\n\n      return null;\n    }\n\n  });\n  return {\n    outlineTrees\n  };\n}\n\nfunction outlineTreeConverter(docText) {\n  const meta = node => {\n    return {\n      representativeName: node.name,\n      startPosition: offsetToPosition(docText, node.loc.start),\n      endPosition: offsetToPosition(docText, node.loc.end),\n      kind: node.kind,\n      children: node.selectionSet || node.fields || node.values || node.arguments || []\n    };\n  };\n\n  return {\n    Field: node => {\n      const tokenizedText = node.alias ? [buildToken('plain', node.alias), buildToken('plain', ': ')] : [];\n      tokenizedText.push(buildToken('plain', node.name));\n      return Object.assign({\n        tokenizedText\n      }, meta(node));\n    },\n    OperationDefinition: node => Object.assign({\n      tokenizedText: [buildToken('keyword', node.operation), buildToken('whitespace', ' '), buildToken('class-name', node.name)]\n    }, meta(node)),\n    Document: node => node.definitions,\n    SelectionSet: node => concatMap(node.selections, child => {\n      return child.kind === INLINE_FRAGMENT ? child.selectionSet : child;\n    }),\n    Name: node => node.value,\n    FragmentDefinition: node => Object.assign({\n      tokenizedText: [buildToken('keyword', 'fragment'), buildToken('whitespace', ' '), buildToken('class-name', node.name)]\n    }, meta(node)),\n    InterfaceTypeDefinition: node => Object.assign({\n      tokenizedText: [buildToken('keyword', 'interface'), buildToken('whitespace', ' '), buildToken('class-name', node.name)]\n    }, meta(node)),\n    EnumTypeDefinition: node => Object.assign({\n      tokenizedText: [buildToken('keyword', 'enum'), buildToken('whitespace', ' '), buildToken('class-name', node.name)]\n    }, meta(node)),\n    EnumValueDefinition: node => Object.assign({\n      tokenizedText: [buildToken('plain', node.name)]\n    }, meta(node)),\n    ObjectTypeDefinition: node => Object.assign({\n      tokenizedText: [buildToken('keyword', 'type'), buildToken('whitespace', ' '), buildToken('class-name', node.name)]\n    }, meta(node)),\n    InputObjectTypeDefinition: node => Object.assign({\n      tokenizedText: [buildToken('keyword', 'input'), buildToken('whitespace', ' '), buildToken('class-name', node.name)]\n    }, meta(node)),\n    FragmentSpread: node => Object.assign({\n      tokenizedText: [buildToken('plain', '...'), buildToken('class-name', node.name)]\n    }, meta(node)),\n    InputValueDefinition: node => {\n      return Object.assign({\n        tokenizedText: [buildToken('plain', node.name)]\n      }, meta(node));\n    },\n    FieldDefinition: node => {\n      return Object.assign({\n        tokenizedText: [buildToken('plain', node.name)]\n      }, meta(node));\n    },\n    InlineFragment: node => node.selectionSet\n  };\n}\n\nfunction buildToken(kind, value) {\n  return {\n    kind,\n    value\n  };\n}\n\nfunction concatMap(arr, fn) {\n  const res = [];\n\n  for (let i = 0; i < arr.length; i++) {\n    const x = fn(arr[i], i);\n\n    if (Array.isArray(x)) {\n      res.push(...x);\n    } else {\n      res.push(x);\n    }\n  }\n\n  return res;\n}","map":{"version":3,"sources":["../src/getOutline.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { Kind, parse, visit, } from 'graphql';\nimport { offsetToPosition } from 'graphql-language-service-utils';\nconst { INLINE_FRAGMENT } = Kind;\nconst OUTLINEABLE_KINDS = {\n    Field: true,\n    OperationDefinition: true,\n    Document: true,\n    SelectionSet: true,\n    Name: true,\n    FragmentDefinition: true,\n    FragmentSpread: true,\n    InlineFragment: true,\n    ObjectTypeDefinition: true,\n    InputObjectTypeDefinition: true,\n    InterfaceTypeDefinition: true,\n    EnumTypeDefinition: true,\n    EnumValueDefinition: true,\n    InputValueDefinition: true,\n    FieldDefinition: true,\n};\nexport function getOutline(documentText) {\n    let ast;\n    try {\n        ast = parse(documentText);\n    }\n    catch (error) {\n        return null;\n    }\n    const visitorFns = outlineTreeConverter(documentText);\n    const outlineTrees = visit(ast, {\n        leave(node) {\n            if (visitorFns !== undefined && node.kind in visitorFns) {\n                return visitorFns[node.kind](node);\n            }\n            return null;\n        },\n    });\n    return { outlineTrees };\n}\nfunction outlineTreeConverter(docText) {\n    const meta = (node) => {\n        return {\n            representativeName: node.name,\n            startPosition: offsetToPosition(docText, node.loc.start),\n            endPosition: offsetToPosition(docText, node.loc.end),\n            kind: node.kind,\n            children: node.selectionSet || node.fields || node.values || node.arguments || [],\n        };\n    };\n    return {\n        Field: (node) => {\n            const tokenizedText = node.alias\n                ? [buildToken('plain', node.alias), buildToken('plain', ': ')]\n                : [];\n            tokenizedText.push(buildToken('plain', node.name));\n            return Object.assign({ tokenizedText }, meta(node));\n        },\n        OperationDefinition: (node) => (Object.assign({ tokenizedText: [\n                buildToken('keyword', node.operation),\n                buildToken('whitespace', ' '),\n                buildToken('class-name', node.name),\n            ] }, meta(node))),\n        Document: (node) => node.definitions,\n        SelectionSet: (node) => concatMap(node.selections, (child) => {\n            return child.kind === INLINE_FRAGMENT ? child.selectionSet : child;\n        }),\n        Name: (node) => node.value,\n        FragmentDefinition: (node) => (Object.assign({ tokenizedText: [\n                buildToken('keyword', 'fragment'),\n                buildToken('whitespace', ' '),\n                buildToken('class-name', node.name),\n            ] }, meta(node))),\n        InterfaceTypeDefinition: (node) => (Object.assign({ tokenizedText: [\n                buildToken('keyword', 'interface'),\n                buildToken('whitespace', ' '),\n                buildToken('class-name', node.name),\n            ] }, meta(node))),\n        EnumTypeDefinition: (node) => (Object.assign({ tokenizedText: [\n                buildToken('keyword', 'enum'),\n                buildToken('whitespace', ' '),\n                buildToken('class-name', node.name),\n            ] }, meta(node))),\n        EnumValueDefinition: (node) => (Object.assign({ tokenizedText: [buildToken('plain', node.name)] }, meta(node))),\n        ObjectTypeDefinition: (node) => (Object.assign({ tokenizedText: [\n                buildToken('keyword', 'type'),\n                buildToken('whitespace', ' '),\n                buildToken('class-name', node.name),\n            ] }, meta(node))),\n        InputObjectTypeDefinition: (node) => (Object.assign({ tokenizedText: [\n                buildToken('keyword', 'input'),\n                buildToken('whitespace', ' '),\n                buildToken('class-name', node.name),\n            ] }, meta(node))),\n        FragmentSpread: (node) => (Object.assign({ tokenizedText: [\n                buildToken('plain', '...'),\n                buildToken('class-name', node.name),\n            ] }, meta(node))),\n        InputValueDefinition: (node) => {\n            return Object.assign({ tokenizedText: [buildToken('plain', node.name)] }, meta(node));\n        },\n        FieldDefinition: (node) => {\n            return Object.assign({ tokenizedText: [buildToken('plain', node.name)] }, meta(node));\n        },\n        InlineFragment: (node) => node.selectionSet,\n    };\n}\nfunction buildToken(kind, value) {\n    return { kind, value };\n}\nfunction concatMap(arr, fn) {\n    const res = [];\n    for (let i = 0; i < arr.length; i++) {\n        const x = fn(arr[i], i);\n        if (Array.isArray(x)) {\n            res.push(...x);\n        }\n        else {\n            res.push(x);\n        }\n    }\n    return res;\n}\n//# sourceMappingURL=getOutline.js.map"]},"metadata":{},"sourceType":"module"}