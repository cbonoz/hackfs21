{"ast":null,"code":"import { notification } from \"antd\";\nimport Notify from \"bnc-notify\";\nimport { BLOCKNATIVE_DAPPID } from \"../constants\";\n\nconst {\n  ethers\n} = require(\"ethers\"); // this should probably just be renamed to \"notifier\"\n// it is basically just a wrapper around BlockNative's wonderful Notify.js\n// https://docs.blocknative.com/notify\n\n\nconst callbacks = {};\nconst DEBUG = true;\nexport default function Transactor(providerOrSigner, gasPrice, etherscan) {\n  if (typeof providerOrSigner !== \"undefined\") {\n    // eslint-disable-next-line consistent-return\n    return async (tx, callback) => {\n      let signer;\n      let network;\n      let provider;\n\n      if (ethers.Signer.isSigner(providerOrSigner) === true) {\n        provider = providerOrSigner.provider;\n        signer = providerOrSigner;\n        network = providerOrSigner.provider && (await providerOrSigner.provider.getNetwork());\n      } else if (providerOrSigner._isProvider) {\n        provider = providerOrSigner;\n        signer = providerOrSigner.getSigner();\n        network = await providerOrSigner.getNetwork();\n      }\n\n      console.log(\"network\", network);\n      var options = null;\n      var notify = null;\n\n      if (navigator.onLine) {\n        options = {\n          dappId: BLOCKNATIVE_DAPPID,\n          // GET YOUR OWN KEY AT https://account.blocknative.com\n          system: \"ethereum\",\n          networkId: network.chainId,\n          // darkMode: Boolean, // (default: false)\n          transactionHandler: txInformation => {\n            if (DEBUG) console.log(\"HANDLE TX\", txInformation);\n            const possibleFunction = callbacks[txInformation.transaction.hash];\n\n            if (typeof possibleFunction === \"function\") {\n              possibleFunction(txInformation.transaction);\n            }\n          }\n        };\n        notify = Notify(options);\n      }\n\n      let etherscanNetwork = \"\";\n\n      if (network.name && network.chainId > 1) {\n        etherscanNetwork = network.name + \".\";\n      }\n\n      let etherscanTxUrl = \"https://\" + etherscanNetwork + \"etherscan.io/tx/\";\n\n      if (network.chainId === 100) {\n        etherscanTxUrl = \"https://blockscout.com/poa/xdai/tx/\";\n      }\n\n      try {\n        let result;\n\n        if (tx instanceof Promise) {\n          if (DEBUG) console.log(\"AWAITING TX\", tx);\n          result = await tx;\n        } else {\n          if (!tx.gasPrice) {\n            tx.gasPrice = gasPrice || ethers.utils.parseUnits(\"4.1\", \"gwei\");\n          }\n\n          if (!tx.gasLimit) {\n            tx.gasLimit = ethers.utils.hexlify(120000);\n          }\n\n          if (DEBUG) console.log(\"RUNNING TX\", tx);\n          result = await signer.sendTransaction(tx);\n        }\n\n        if (DEBUG) console.log(\"RESULT:\", result); // console.log(\"Notify\", notify);\n\n        if (callback) {\n          callbacks[result.hash] = callback;\n        } // if it is a valid Notify.js network, use that, if not, just send a default notification\n\n\n        if (notify && [1, 3, 4, 5, 42, 100].indexOf(network.chainId) >= 0) {\n          const {\n            emitter\n          } = notify.hash(result.hash);\n          emitter.on(\"all\", transaction => {\n            return {\n              onclick: () => window.open((etherscan || etherscanTxUrl) + transaction.hash)\n            };\n          });\n        } else {\n          notification.info({\n            message: \"Local Transaction Sent\",\n            description: result.hash,\n            placement: \"bottomRight\"\n          }); // on most networks BlockNative will update a transaction handler,\n          // but locally we will set an interval to listen...\n\n          if (callback) {\n            const txResult = await tx;\n            const listeningInterval = setInterval(async () => {\n              console.log(\"CHECK IN ON THE TX\", txResult, provider);\n              const currentTransactionReceipt = await provider.getTransactionReceipt(txResult.hash);\n\n              if (currentTransactionReceipt && currentTransactionReceipt.confirmations) {\n                callback({ ...txResult,\n                  ...currentTransactionReceipt\n                });\n                clearInterval(listeningInterval);\n              }\n            }, 500);\n          }\n        }\n\n        if (typeof result.wait === \"function\") {\n          await result.wait();\n        }\n\n        return result;\n      } catch (e) {\n        if (DEBUG) console.log(e); // Accounts for Metamask and default signer on all networks\n\n        let message = e.data && e.data.message ? e.data.message : e.error && JSON.parse(JSON.stringify(e.error)).body ? JSON.parse(JSON.parse(JSON.stringify(e.error)).body).error.message : e.data ? e.data : JSON.stringify(e);\n\n        if (!e.error && e.message) {\n          message = e.message;\n        }\n\n        console.log(\"Attempt to clean up:\", message);\n\n        try {\n          let obj = JSON.parse(message);\n\n          if (obj && obj.body) {\n            let errorObj = JSON.parse(obj.body);\n\n            if (errorObj && errorObj.error && errorObj.error.message) {\n              message = errorObj.error.message;\n            }\n          }\n        } catch (e) {//ignore\n        }\n\n        notification.error({\n          message: \"Transaction Error\",\n          description: message\n        });\n\n        if (callback && typeof callback === \"function\") {\n          callback(e);\n        }\n      }\n    };\n  }\n}\n_c = Transactor;\n\nvar _c;\n\n$RefreshReg$(_c, \"Transactor\");","map":{"version":3,"sources":["/Users/chrisbuonocore/personal/hackathons/hackfs21/packages/react-app/src/helpers/Transactor.js"],"names":["notification","Notify","BLOCKNATIVE_DAPPID","ethers","require","callbacks","DEBUG","Transactor","providerOrSigner","gasPrice","etherscan","tx","callback","signer","network","provider","Signer","isSigner","getNetwork","_isProvider","getSigner","console","log","options","notify","navigator","onLine","dappId","system","networkId","chainId","transactionHandler","txInformation","possibleFunction","transaction","hash","etherscanNetwork","name","etherscanTxUrl","result","Promise","utils","parseUnits","gasLimit","hexlify","sendTransaction","indexOf","emitter","on","onclick","window","open","info","message","description","placement","txResult","listeningInterval","setInterval","currentTransactionReceipt","getTransactionReceipt","confirmations","clearInterval","wait","e","data","error","JSON","parse","stringify","body","obj","errorObj"],"mappings":"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","sourcesContent":["import { notification } from \"antd\";\nimport Notify from \"bnc-notify\";\nimport { BLOCKNATIVE_DAPPID } from \"../constants\";\n\nconst { ethers } = require(\"ethers\");\n\n// this should probably just be renamed to \"notifier\"\n// it is basically just a wrapper around BlockNative's wonderful Notify.js\n// https://docs.blocknative.com/notify\nconst callbacks = {};\n\nconst DEBUG = true;\n\nexport default function Transactor(providerOrSigner, gasPrice, etherscan) {\n  if (typeof providerOrSigner !== \"undefined\") {\n    // eslint-disable-next-line consistent-return\n    return async (tx, callback) => {\n      let signer;\n      let network;\n      let provider;\n      if (ethers.Signer.isSigner(providerOrSigner) === true) {\n        provider = providerOrSigner.provider;\n        signer = providerOrSigner;\n        network = providerOrSigner.provider && (await providerOrSigner.provider.getNetwork());\n      } else if (providerOrSigner._isProvider) {\n        provider = providerOrSigner;\n        signer = providerOrSigner.getSigner();\n        network = await providerOrSigner.getNetwork();\n      }\n\n      console.log(\"network\", network);\n\n      var options = null;\n      var notify = null;\n      if(navigator.onLine){\n        options = {\n          dappId: BLOCKNATIVE_DAPPID, // GET YOUR OWN KEY AT https://account.blocknative.com\n          system: \"ethereum\",\n          networkId: network.chainId,\n          // darkMode: Boolean, // (default: false)\n          transactionHandler: txInformation => {\n            if (DEBUG) console.log(\"HANDLE TX\", txInformation);\n            const possibleFunction = callbacks[txInformation.transaction.hash];\n            if (typeof possibleFunction === \"function\") {\n              possibleFunction(txInformation.transaction);\n            }\n          },\n        };\n\n        notify = Notify(options);\n      }\n\n\n      let etherscanNetwork = \"\";\n      if (network.name && network.chainId > 1) {\n        etherscanNetwork = network.name + \".\";\n      }\n\n      let etherscanTxUrl = \"https://\" + etherscanNetwork + \"etherscan.io/tx/\";\n      if (network.chainId === 100) {\n        etherscanTxUrl = \"https://blockscout.com/poa/xdai/tx/\";\n      }\n\n      try {\n        let result;\n        if (tx instanceof Promise) {\n          if (DEBUG) console.log(\"AWAITING TX\", tx);\n          result = await tx;\n        } else {\n          if (!tx.gasPrice) {\n            tx.gasPrice = gasPrice || ethers.utils.parseUnits(\"4.1\", \"gwei\");\n          }\n          if (!tx.gasLimit) {\n            tx.gasLimit = ethers.utils.hexlify(120000);\n          }\n          if (DEBUG) console.log(\"RUNNING TX\", tx);\n          result = await signer.sendTransaction(tx);\n        }\n        if (DEBUG) console.log(\"RESULT:\", result);\n        // console.log(\"Notify\", notify);\n\n        if (callback) {\n          callbacks[result.hash] = callback;\n        }\n\n        // if it is a valid Notify.js network, use that, if not, just send a default notification\n        if (notify && [1, 3, 4, 5, 42, 100].indexOf(network.chainId) >= 0) {\n          const { emitter } = notify.hash(result.hash);\n          emitter.on(\"all\", transaction => {\n            return {\n              onclick: () => window.open((etherscan || etherscanTxUrl) + transaction.hash),\n            };\n          });\n        } else {\n          notification.info({\n            message: \"Local Transaction Sent\",\n            description: result.hash,\n            placement: \"bottomRight\",\n          });\n          // on most networks BlockNative will update a transaction handler,\n          // but locally we will set an interval to listen...\n          if (callback) {\n            const txResult = await tx;\n            const listeningInterval = setInterval(async () => {\n              console.log(\"CHECK IN ON THE TX\", txResult, provider);\n              const currentTransactionReceipt = await provider.getTransactionReceipt(txResult.hash);\n              if (currentTransactionReceipt && currentTransactionReceipt.confirmations) {\n                callback({ ...txResult, ...currentTransactionReceipt });\n                clearInterval(listeningInterval);\n              }\n            }, 500);\n          }\n        }\n\n        if (typeof result.wait === \"function\") {\n          await result.wait();\n        }\n\n        return result;\n      } catch (e) {\n        if (DEBUG) console.log(e);\n        // Accounts for Metamask and default signer on all networks\n        let message = e.data && e.data.message ? e.data.message : e.error && JSON.parse(JSON.stringify(e.error)).body ? JSON.parse(JSON.parse(JSON.stringify(e.error)).body).error.message : e.data ? e.data : JSON.stringify(e);\n        if(!e.error && e.message){\n          message = e.message\n        }\n\n        console.log(\"Attempt to clean up:\", message);\n        try{\n          let obj = JSON.parse(message)\n          if(obj && obj.body){\n            let errorObj = JSON.parse(obj.body)\n            if(errorObj && errorObj.error && errorObj.error.message){\n              message = errorObj.error.message\n            }\n          }\n        }catch(e){\n          //ignore\n        }\n\n        notification.error({\n          message: \"Transaction Error\",\n          description: message,\n        });\n        if (callback && typeof callback === \"function\") {\n          callback(e);\n        }\n      }\n    };\n  }\n}\n"]},"metadata":{},"sourceType":"module"}